- [并发面试题](#并发面试题)
  - [进程与线程的区别是什么](#进程与线程的区别是什么)
  - [线程与线程之间通信有哪些方式](#线程与线程之间通信有哪些方式)
  - [进程与进程之间通信有哪些方式](#进程与进程之间通信有哪些方式)
  - [说一下线程的6种状态及转换关系](#说一下线程的6种状态及转换关系)
  - [说一下线程中断机制](#说一下线程中断机制)
  - [synchonized与Lock锁的相同与不同点](#synchonized与Lock锁的相同与不同点)
  - [JDK8中对并发做了哪些优化](#JDK8中对并发做了哪些优化)

# 并发面试题

### 进程与线程的区别是什么

TODO

### 线程与线程之间通信有哪些方式

线程中断机制、等待唤醒机制、还有吗 ?

### 进程与进程之间通信有哪些方式

TODO

### 说一下线程的6种状态及转换关系

![image](https://user-images.githubusercontent.com/10209135/97520335-eecbe380-19d5-11eb-8f81-5a6ce563b594.png)

NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED

RUNNALE 在 JVM 内部分为 READY（就绪）和 RUNNING（运行中）两种状态

线程新建后处于 NEW 状态，线程运行 start 方法或者被唤醒后，一般是先处于 READY 状态的，在获取了时间片后才处于 RUNNING 状态

Object、Thread、Locksuport 均有方法能让线程进入 WAITING 状态或者 TIMED_WAITING 状态

线程在等待获取 synchonized 监视器锁时，是 BLOCKED 状态

平时我们口语所说的“阻塞”，往往包含了 BLOCKED 与 WAITING 两种状态，把 Object#wait()、LockSupport.park() 等动作进入的等待状态也称为了“阻塞”，口语上这样说无妨，只要正确的理解AVA线程生命周期中 BLOCKED 与 WAITING 状态的区别，在需要区分的时候不要弄混淆即可

### 说一下线程中断机制

线程中断机制是一种线程间优雅的协作模式，并不是直接中断运行中的线程，但会让等待中的线程抛 InterruptedException

Thread#interrupt方法只是设置中断标志，Thread#isInterrupeted 不会清除中断标志，Thread.interrupted 会清除中断标志，而 Thread.interrupted 是检测的 currentThread

回忆：ThreadPoolExecutor 中 runWorker 方法，获取了 task 后，先进行判断，若线程池是 >= STOP 状态 且 Thread.interrupted() 且 !wt.isInterrupted()，则 wt.interrupt()

线程进入等待状态（WAITING 或 TIMED_WAITING）后，其他线程调用了该线程的 Thread#interrupt 方法后，都会被唤醒，进入运行状态（RUNNABLE），但有些情况会抛 InterruptedException，有些情况不会抛异常

会抛异常的情况：Object#wait、Thread#join、Thread.sleep；不会抛异常的情况：LockSupport.park

### synchonized与Lock锁的相同与不同点

TODO

### JDK8中对并发做了哪些优化

TODO
