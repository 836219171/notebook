- [并发面试题](#并发面试题)
  - [哪些情况线程进入等待后被Thread-interrupt会抛异常](#哪些情况线程进入等待后被Thread-interrupt会抛异常)

# 并发面试题

参考
- [JAVA线程基础.md](JAVA线程基础.md)

### 说一下线程的6种状态及转换关系

![image](https://user-images.githubusercontent.com/10209135/97520335-eecbe380-19d5-11eb-8f81-5a6ce563b594.png)

6种状态解析

- NEW，初始状态，表示线程被初始化（new Thread()），但未执行start方法
- RUNNABLE，运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行状态”
  - READY，就绪状态，属于JVM底层的状态，不属于JAVA层面，表示线程正在运行但还未分配到CPU时间片
  - RUNNING，运行状态，属于JVM底层的状态，不属于JAVA层面，表示线程获取到CPU时间片，正在运行
- BLOCKED，阻塞状态，表示线程正在阻塞于monitor锁，等待进入synchronized方法或块
- WAITING，等待状态，表示线程由于一些特定动作（Object#wait()、LockSupport.park()、Thread#join()）进入等待状态，当其他线程执行对应特定动作（Object#notify、LockSupport.unpark(Thread)、其他线程执行完毕）后会唤醒该线程，然后该线程进入运行状态
- TIMED_WAITING，超时等待状态，它与等待状态很类似，但可以设置指定超时时间，超时后线程会自动被唤醒，进入运行状态
- TERMINATED，终止状态，表示线程已经执行完毕

这里有几个点需要注意
- RUNNABLE在JVM底层包含READY和RUNNING两种状态，它们的区别点是线程是否分配到了CPU时间片，在线程运行start方法或者被唤醒后，往往是先处于READY状态的，在获取了时间片后才处于RUNNING状态
- Thread.yield()方法可以告诉线程调度器“主动放弃CPU时间片，不想用了”，线程调度器会从就绪队列中后去一个优先级最高的线程（也可能是刚才让出CPU时间片的线程）
- 平时我们口语所说的“阻塞”，往往包含了BLOCKED与WAITING两种状态，把Object#wait()、LockSupport.park()等动作进入的等待状态也称为了“阻塞”，口语上这样说无妨，只要正确的理解JAVA线程生命周期中BLOCKED与WAITING状态的区别，在需要区分的时候不要弄混淆即可

### 哪些情况线程进入等待后被Thread-interrupt会抛异常

线程进入等待状态（WAITING 或 TIMED_WAITING）后，其他线程调用了该线程的 Thread#interrupt 方法后，都会被唤醒，进入运行状态（RUNNABLE），但有些情况会抛异常 InterruptedException，有些情况不会抛异常

会抛异常的情况：Object#wait、Thread#join、Thread.sleep

不会抛异常的情况：LockSupport.park

另外一提的是，线程进入阻塞状态（等待获取synchonized监视器锁），即使其他线程调用了该线程的 Thread#interrupt，它也不会 moniter exit

