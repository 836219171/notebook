- [类加载机制](#类加载机制)
  - [类的定义](#类的定义)
  - [类加载的定义](#类加载的定义)
  - [类加载的输入和输出结果](#类加载的输入和输出结果)
  - [JAVA运行时环境逻辑图](#JAVA运行时环境逻辑图)
  - [InstanceKlass和InstanceMirrorKlass是什么](#InstanceKlass和InstanceMirrorKlass是什么)
  - [ArrayKlass和TypeArrayKlass和ObjArrayKlass是什么](#ArrayKlass和TypeArrayKlass和ObjArrayKlass是什么)
  - [类加载的五个过程](#类加载的五个过程)
  - [类加载之加载](#类加载之加载)
    - [加载的规范定义](#加载的规范定义)
    - [数组类的加载过程](#数组类的加载过程)
  - [类加载之验证](#类加载之验证)
    - [验证的规范定义](#验证的规范定义)
    - [四种验证方法](#四种验证方法)
  - [类加载之准备](#类加载之准备)
    - [准备的规范定义](#准备的规范定义)
    - [数据类型的零值](#数据类型的零值)
  - [类加载之解析](#类加载之解析)
    - [解析的规范定义](#解析的规范定义)
    - [符号引用替换为直接引用](#符号引用替换为直接引用)
  - [类加载之初始化](#类加载之初始化)
    - [初始化的规范定义](#初始化的规范定义)
    - [clinit方法的深入理解](#clinit方法的深入理解)
  - [类加载什么时候会进行](#类加载什么时候会进行)
    - [加载mainClass](#加载mainClass)
    - [new或getstatic或putstatic或invokestatic](#new或getstatic或putstatic或invokestatic)
    - [优先加载父类](#优先加载父类)
    - [反射](#反射)
  - [类加载之数组类](#类加载之数组类)
  - [类加载笔试题统一解法](#类加载笔试题统一解法)
  
# 类加载机制

### 类的定义

> In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods). From https://en.wikipedia.org/wiki/Class_(computer_programming)

类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起

类是对象的抽象，而对象是类的具体实例

### 类加载的定义

> The Java ClassLoader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine. The Java run time system does not need to know about files and file systems because of classloaders. Java classes aren't loaded into memory all at once, but when required by an application. From https://www.geeksforgeeks.org/classloader-in-java/

类加载（包括类加载器）是Java虚拟机运行时环境的一部分，它能够动态地将Java类文件加载进入JVM中

由于类加载等过程实现了多平台的支持，因此Java是跨平台的

类加载是懒加载模式，并非一次性将所有.class文件都加载，而是需要时加载

[口述版]类加载是Java虚拟机将class数据二进制字节流读入类加载器，解析出类的元信息（InstanceKlass）并写入方法区，解析出类的Class对象（InstanceMirrorKlass）并写入堆区等过程

### 类加载的输入和输出结果

类加载是JVM启动后靠前的几步之一

输入是.class文件

输出是许多数据写入内存区域，比如InstanceKlass到方法区，InstanceMirrorKlass到堆区

> 在第二版（7.3.1节）中，InstanceMirrorKlass（即java.lang.Class对象）是写在方法区中的，这是JDK7的逻辑；而在第三版（7.3.1节）中，InstanceMirrorKlass是写在堆内存中的，这是JDK8的逻辑

> 除了InstanceKlass和InstanceMirrorKlass，还有InstanceRefKlass、ArrayKlass、TypeArrayKlass、ObjArrayKlass，它们分别是写到内存区域中哪一块？

> 写入方法区和堆区有代码例子证明吗？

### JAVA运行时环境逻辑图

![image](http://tswork.peterpy.cn/java_runtime.png)

### InstanceKlass和InstanceMirrorKlass是什么

Klass是Java类在JVM中的存在形式（补充：OOP是JAVA对象在JVM中的存在形式）

InstanceKlass是类的元信息数据

InstanceMirrorKlass是类的Class对象

下面是这几个Klass的继承关系图

![image](https://user-images.githubusercontent.com/10209135/89729486-ced8f380-da68-11ea-81d4-e4b19825a4a0.png)

来看一下openjdk8源码

#### InstanceKlass

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/hotspot/src/share/vm/oops/instanceKlass.hpp#L138

```cpp
// An InstanceKlass is the VM level representation of a Java class.
// It contains all information needed for at class at execution runtime.

//  InstanceKlass layout:
//    [C++ vtbl pointer           ] Klass
//    [subtype cache              ] Klass
//    [instance size              ] Klass
//    [java mirror                ] Klass
//    [super                      ] Klass
//    [access_flags               ] Klass
//    [name                       ] Klass
//    [first subklass             ] Klass
//    [next sibling               ] Klass
//    [array klasses              ]
//    [methods                    ]
//    [local interfaces           ]
//    [transitive interfaces      ]
//    [fields                     ]
//    [constants                  ]
//    [class loader               ]
//    [source file name           ]
//    [inner classes              ]
//    [static field size          ]
//    [nonstatic field size       ]
//    [static oop fields size     ]
//    [nonstatic oop maps size    ]
//    [has finalize method        ]
//    [deoptimization mark bit    ]
//    [initialization state       ]
//    [initializing thread        ]
//    [Java vtable length         ]
//    [oop map cache (stack maps) ]
//    [EMBEDDED Java vtable             ] size in words = vtable_len
//    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
//      The embedded nonstatic oop-map blocks are short pairs (offset, length)
//      indicating where oops are located in instances of this klass.
//    [EMBEDDED implementor of the interface] only exist for interface
//    [EMBEDDED host klass        ] only exist for an anonymous class (JSR 292 enabled)

class InstanceKlass: public Klass {
  friend class VMStructs;
  friend class ClassFileParser;
  friend class CompileReplay;

 protected:
  // Constructor
  InstanceKlass(int vtable_len,
                int itable_len,
                int static_field_size,
                int nonstatic_oop_map_size,
                ReferenceType rt,
                AccessFlags access_flags,
                bool is_anonymous);
...
 protected:
  // Annotations for this class
  Annotations*    _annotations;
  // Array classes holding elements of this class.
  Klass*          _array_klasses;
  // Constant pool for this class.
  ConstantPool* _constants;
  // The InnerClasses attribute and EnclosingMethod attribute. The
  // _inner_classes is an array of shorts. If the class has InnerClasses
  // attribute, then the _inner_classes array begins with 4-tuples of shorts
  // [inner_class_info_index, outer_class_info_index,
  // inner_name_index, inner_class_access_flags] for the InnerClasses
  // attribute. If the EnclosingMethod attribute exists, it occupies the
  // last two shorts [class_index, method_index] of the array. If only
  // the InnerClasses attribute exists, the _inner_classes array length is
  // number_of_inner_classes * 4. If the class has both InnerClasses
  // and EnclosingMethod attributes the _inner_classes array length is
  // number_of_inner_classes * 4 + enclosing_method_attribute_size.
  Array<jushort>* _inner_classes;

  // the source debug extension for this klass, NULL if not specified.
  // Specified as UTF-8 string without terminating zero byte in the classfile,
  // it is stored in the instanceklass as a NULL-terminated UTF-8 string
  char*           _source_debug_extension;
  // Array name derived from this class which needs unreferencing
  // if this class is unloaded.
  Symbol*         _array_name;

  // Number of heapOopSize words used by non-static fields in this klass
  // (including inherited fields but after header_size()).
  int             _nonstatic_field_size;
  int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
  // Constant pool index to the utf8 entry of the Generic signature,
  // or 0 if none.
  u2              _generic_signature_index;
  // Constant pool index to the utf8 entry for the name of source file
  // containing this klass, 0 if not specified.
  u2              _source_file_name_index;
  u2              _static_oop_field_count;// number of static oop fields in this klass
  u2              _java_fields_count;    // The number of declared Java fields
  int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks

  // _is_marked_dependent can be set concurrently, thus cannot be part of the
  // _misc_flags.
  bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
  bool            _has_unloaded_dependent;

  enum {
    _misc_rewritten                = 1 << 0, // methods rewritten.
    _misc_has_nonstatic_fields     = 1 << 1, // for sizing with UseCompressedOops
    _misc_should_verify_class      = 1 << 2, // allow caching of preverification
    _misc_is_anonymous             = 1 << 3, // has embedded _host_klass field
    _misc_is_contended             = 1 << 4, // marked with contended annotation
    _misc_has_default_methods      = 1 << 5, // class/superclass/implemented interfaces has default methods
    _misc_declares_default_methods = 1 << 6  // directly declares default methods (any access)
  };
  u2              _misc_flags;
  u2              _minor_version;        // minor version number of class file
  u2              _major_version;        // major version number of class file
  Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recusive initialization)
  int             _vtable_len;           // length of Java vtable (in words)
  int             _itable_len;           // length of Java itable (in words)
  OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
  MemberNameTable* _member_names;        // Member names
  JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
  jmethodID*      _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
  nmethodBucket*  _dependencies;         // list of dependent nmethods
  nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
  BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
  // Array of interesting part(s) of the previous version(s) of this
  // InstanceKlass. See PreviousVersionWalker below.
  GrowableArray<PreviousVersionNode *>* _previous_versions;
  // JVMTI fields can be moved to their own structure - see 6315920
  // JVMTI: cached class file, before retransformable agent modified it in CFLH
  JvmtiCachedClassFileData* _cached_class_file;

  volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don't change

  // Class states are defined as ClassState (see above).
  // Place the _init_state here to utilize the unused 2-byte after
  // _idnum_allocated_count.
  u1              _init_state;                    // state of class
  u1              _reference_type;                // reference type

  JvmtiCachedClassFieldMap* _jvmti_cached_class_field_map;  // JVMTI: used during heap iteration

  NOT_PRODUCT(int _verify_count;)  // to avoid redundant verifies

  // Method array.
  Array<Method*>* _methods;
  // Default Method Array, concrete methods inherited from interfaces
  Array<Method*>* _default_methods;
  // Interface (Klass*s) this class declares locally to implement.
  Array<Klass*>* _local_interfaces;
  // Interface (Klass*s) this class implements transitively.
  Array<Klass*>* _transitive_interfaces;
  // Int array containing the original order of method in the class file (for JVMTI).
  Array<int>*     _method_ordering;
  // Int array containing the vtable_indices for default_methods
  // offset matches _default_methods offset
  Array<int>*     _default_vtable_indices;

  // Instance and static variable information, starts with 6-tuples of shorts
  // [access, name index, sig index, initval index, low_offset, high_offset]
  // for all fields, followed by the generic signature data at the end of
  // the array. Only fields with generic signature attributes have the generic
  // signature data set in the array. The fields array looks like following:
  //
  // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
  // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
  //      ...
  // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
  //     [generic signature index]
  //     [generic signature index]
  //     ...
  Array<u2>*      _fields;
```

这里贴一下这些成员变量的中文解释
```text
_annotations：保存该类的所有注解
_array_klasses：保存数组元素所关联的klass指针
_constants：保存该类的常量池指针
_inner_classes：保存内部类相关的信息
_array_name：如果该类是数组，就会生成数组类名词，如“[Ljava/lang/String;”
_nonstatic_field_size：非静态字段数量
_static_field_size：静态字段数量
_generic_signature_index：泛型签名在常量池中的索引
_source_file_name_index：文件名在常量池中的索引
_static_oop_field_count：该类包含的静态的引用类型字段个数
_java_fields_count：已声明的Java字段数量
_nonstatic_oop_map_size：非静态oop映射块的大小(以字为单位)
_is_marked_dependent：用于刷新和反优化期间打标
_minor_version：主版本号
_major_version：次版本号
_init_thread：初始化此类的线程
_vtable_len：虚函数表的大小
_itable_len：接口函数表的大小
_oop_map_cache：该类所有方法的OopMapCache(延迟分配)
_member_names：MemberNameTable指针
_jni_ids：存放jni_id单向链表的首地址（什么是jni_id?）
_methods_jmethod_ids：与method_idnum对应的jmethodIDs，如果没有，则为NULL
_dependencies：存放nmethod的Bucket的首地址
_osr_nmethods_head：栈上替换nmethods的链表的首地址
_breakpoints：断点链表首地址
_previous_versions：此实例的前一个版本的有趣部分的数组。请参见下面的PreviousVersionWalker
_cached_class_file：缓存的类文件
_idnum_allocated_count：已经分配的idnum的个数
_init_state：该类的状态，值：allocated（已分配内存但未链接）、loaded（加载并插入到类层次结构中但仍未链接）、linked（验证及链接成功但未初始化）、being_initialized（正在初始化）、fully_initialized（已完成初始化）、initialization_error（初始化出错）
_reference_type：引用类型
_methods：存储该类的所有方法对象的指针的数组指针
_default_methods：存储从接口继承的所有方法对象的指针的数组指针
_local_interfaces：数组指针，存储所有实现的接口的指针
_transitive_interfaces：数组，存储直接实现的接口指针+接口间继承实现的接口指针
_method_ordering：包含类文件中方法的原始顺序的Int数组，JVMTI需要用到
_default_vtable_indices：默认构造方法在虚表中的索引
_fields：类的成员属性
```

#### InstanceMirrorKlass

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/hotspot/src/share/vm/oops/instanceMirrorKlass.hpp#L41

```cpp
// An InstanceMirrorKlass is a specialized InstanceKlass for
// java.lang.Class instances.  These instances are special because
// they contain the static fields of the class in addition to the
// normal fields of Class.  This means they are variable sized
// instances and need special logic for computing their size and for
// iteration of their oops.

class InstanceMirrorKlass: public InstanceKlass {
  friend class VMStructs;
  friend class InstanceKlass;

 private:
  static int _offset_of_static_fields;

  // Constructor
  InstanceMirrorKlass(int vtable_len, int itable_len, int static_field_size, int nonstatic_oop_map_size, ReferenceType rt, AccessFlags access_flags,  bool is_anonymous)
    : InstanceKlass(vtable_len, itable_len, static_field_size, nonstatic_oop_map_size, rt, access_flags, is_anonymous) {}

 public:
  InstanceMirrorKlass() { assert(DumpSharedSpaces || UseSharedSpaces, "only for CDS"); }
  // Type testing
  bool oop_is_instanceMirror() const             { return true; }
```

#### InstanceKlass和InstanceMirrorKlass

可以看出来
- InstanceKlass中定义了Java运行时环境类所需的所有数据信息，比如 constants 常量池、static field size 静态成员变量大小、methods 方法 等（An InstanceKlass is the VM level representation of a Java class. It contains all information needed for at class at execution runtime.）
- InstanceMirrorKlass是InstanceKlass的一个子类
- InstanceMirrorKlass是java.lang.Class类专用的InstanceKlass（An InstanceMirrorKlass is a specialized InstanceKlass for java.lang.Class instances.）

简单总结一下，InstanceKlass包含了Java运行时环境中类所需的所有数据信息，在类加载这一步，类加载器会将.class文件读入类加载器的class content，然后以InstanceKlass的形式写入JVM内存区域的方法区中，而InstanceMirrorKlass是类所对应的Class对象（java.lang.Class）的InstanceKlass

> 辗转反侧了很久，终于理解了InstanceKlass和InstanceMirrorKlass

> 对于InstanceKlass，在Java中，对于所有类，类的内部属性轮廓是不是可以认为是一样的？类都有父类、实现接口、变量、方法、代码块等，而变量和方法也有属性，即可访问性（public、private、protected、default）、静态与非静态，还有数组形式的。无论如何，类的内部属性以及属性的属性，是有限的、可列举的，那么在JVM中以C++代码就可以用一个类来表示，它就是InstanceKlass，这一层是比较好理解的

> 对于InstanceMirrorKlass的理解，首先需要理解什么是java.lang.Class，我们来看一下这个类的注释吧：Instances of the class Class represent classes and interfaces in a running Java application. 翻译过来说，就是类或接口在Java运行时环境中的一个表达方式，再看看java.lang.Class的方法就知道，getConstructors()、getMethods()、getFields()、getDeclaredFields()，这些都是类的内部属性，且对于任何类来说，都可以用形如A.class的方法来获取java.lang.Class，即每个Java类都有一个java.lang.Class，那么在JVM中以C++代码表示，每个类的java.lang.Class就是InstanceMirrorKlass。java.lang.Class也是一个类，InstanceMirrorKlass是InstanceKlass的子类

### ArrayKlass和TypeArrayKlass和ObjArrayKlass是什么

在理解了InstanceKlass后，这三个类就很好理解了

- ArrayKlass表示的是数组类型（ArrayKlass is the abstract baseclass for all array classes）
- TypeArrayKlass表示基本数组类型（A TypeArrayKlass is the klass of a typeArray, It contains the type and size of the elements），type是八大基本类型
- ObjArrayKlass表示引用数组类型（ObjArrayKlass is the klass for objArrays），type是Reference

下面的源码部分

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/hotspot/src/share/vm/oops/arrayKlass.hpp
```cpp
// ArrayKlass is the abstract baseclass for all array classes

class ArrayKlass: public Klass {
  friend class VMStructs;
 private:
  int      _dimension;         // This is n'th-dimensional array.
  Klass* volatile _higher_dimension;  // Refers the (n+1)'th-dimensional array (if present).
  Klass* volatile _lower_dimension;   // Refers the (n-1)'th-dimensional array (if present).
  int      _vtable_len;        // size of vtable for this klass
  oop      _component_mirror;  // component type, as a java/lang/Cl
```

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/hotspot/src/share/vm/oops/typeArrayKlass.hpp
```cpp
// A TypeArrayKlass is the klass of a typeArray
// It contains the type and size of the elements

class TypeArrayKlass : public ArrayKlass {
  friend class VMStructs;
 private:
  jint _max_length;            // maximum number of elements allowed in an array

  // Constructor
  TypeArrayKlass(BasicType type, Symbol* name);
  static TypeArrayKlass* allocate(ClassLoaderData* loader_data, BasicType type, Symbol* name, TRAPS);
 public:
  TypeArrayKlass() {} // For dummy objects.
```

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/hotspot/src/share/vm/oops/objArrayKlass.hpp
```cpp
// ObjArrayKlass is the klass for objArrays

class ObjArrayKlass : public ArrayKlass {
  friend class VMStructs;
 private:
  Klass* _element_klass;            // The klass of the elements of this array type
  Klass* _bottom_klass;             // The one-dimensional type (InstanceKlass or TypeArrayKlass)

  // Constructor
  ObjArrayKlass(int n, KlassHandle element_klass, Symbol* name);
  static ObjArrayKlass* allocate(ClassLoaderData* loader_data, int n, KlassHandle klass_handle, Symbol* name, TRAPS);
 public:
  // For dummy objects
  ObjArrayKlass() {}
```

#### InstanceRefKlass 的理解

描述java.lang.ref.Reference的子类，这部分的概念与强软弱虚引用、垃圾回收有关系，见后续章节

### 类加载的五个过程

生命周期是由7个阶段组成，类的加载说的是前5个阶段，即加载=>验证=>准备=>解析=>初始化

> 提一点，不要认为类加载是严格地前一阶段结束后一阶段开始，加载阶段尚未完成时，连接阶段（验证、准备、解析）可能已经开始了，但它们的开始时间是保持着固定的先后顺序的

![image](https://user-images.githubusercontent.com/10209135/92302466-f30fed80-ef9e-11ea-9b2b-a1615c445177.png)

### 类加载之加载

#### 加载的规范定义

- 通过一个的全限定名（类名+包名）来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口

> 在【类加载的输入和输出结果】中我们提过，输入是.class文件，输出是许多数据写入内存区域，比如InstanceKlass到方法区，InstanceMirrorKlass到堆区，与上面这段话是对应着的

> 上面的类加载过程能在JVM源码中找到位置吗？

#### 广义的类文件是二进制字节流

狭义的class文件，指某个存在于具体磁盘中的文件

广义的class文件，指二进制字节流（符合class文件格式），比如ZIP、JAR、EAR、WAR包中的class文件，从网络中获取的（典型场景：Applet），运行时计算生成的（反射技术），由其他文件生成的（JSP文件生成对应的Class类），从数据库中获取的（应用较少，比如SAP Netweaver），都可以。虚拟机规范没有指明加载方法、位置等，因此具体实现的舞台很大

#### 运行期动态类加载是特性

Java里天生可以动态拓展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的

例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义加载器，让一个本地的应用程序可以在运行时从网络其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序中

#### 数组类的加载过程

对于数组类而言，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建

创建过程遵循以下规则

- 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用 自定义类加载器 => 应用程序类加载器 => 拓展类加载器 => 启动类加载器 的加载过程
- 如果数组的组件类型是基本类型（比如 int[]数组），就标记为与引导类加载器（我理解为启动类加载器）关联

new一个数组对象时，是不会加载对应的类的，在下文会有具体解释说明

### 类加载之验证

#### 验证的规范定义

确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

> 第一，验证这个动作对于编写JVM的程序员来说，一定是一件非常繁琐的事情，因为需要考虑的因素非常之多，但是，对于JAVA应用层业务层的程序员来说，有一点点前人修路后人走路的感觉，而且这个前人修的路还不会坏，后人可以随意的走，因为虚拟机经过了好几代的迭代，到了JDK8及以后，验证这一步已经非常成熟了，连虚拟机规范都从最初的10页不到内容，增加到了130页（2011年发布的《Java虚拟机规范（JavaSE7版）》）

> 第二，如果是经过javac编译器编译出的class文件，理论上应该不需要进行那么复杂的检查流程，比如公司内部老员工给另一个老员工传了份文件，还检查什么呢。但是编写JVM的程序员很辛苦，他们当然不能只考虑到一种情况，还要考虑到种种意外的可能情况

> 总的来说，个人觉得验证这一步不是那么的重要，不需要去特别记忆，但是验证的过程实际上是对Class文件结构的更深入理解，从这个角度来看就存在重要性了

#### 四种验证方法

- 文件格式验证：字节流内容是否符合Class文件格式规范
- 元数据验证：字节码描述的语义信息是否符合Java语言规范
- 字节码验证：字节码语义（主要是方法体）是否可执行无危害；但由于停机问题，无法100%验证
- 符号引用验证：符号引用转化为直接引用是否符合规范，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验

下面简单的列举一下虚拟机中的四种验证以及验证点

##### 文件格式验证

第一阶段需要验证字节流是否符合Class文件格式的规范

比如
- 是否以魔数0xCAFEABE开头
- 常量池中的常量中是否有不被支持的常量类型（检查常量tag标志）
- Class文件中各个部分及文件本身是否有被删除的或附加的其他信息

这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流

##### 元数据验证

第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求

比如
- 这个类是否有父类（除了java.lang.Object以外，所有的类应当都有父类）
- 这个类的父类是否继承了不允许被继承的类（被final修饰的类）
- 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
- 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载等）

##### 字节码验证

第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的

第二阶段会对元数据信息的数据类型进行校验，这一阶段是将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件

比如
- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，比如不会出现这样的情况：在操作数栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中
- 保证跳转指令不会跳转到方法体以外的字节码指令上
- 保证方法体中的类型转换是有效的，比如父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的

如果一个类的方法体的字节码没有通过字节码验证，那肯定是有问题的，但是，如果一个方法体通过了字节码验证，也不能说明一定是安全的，即时字节码验证之中进行了大量的校验检查，也不能保证这一点，这里涉及了离线数学中一个很著名的问题“Halting Problem”

> 停机问题（英语：halting problem）是逻辑数学中可计算性理论的一个问题。通俗地说，停机问题就是判断任意一个程序是否能在有限的时间之内结束运行的问题。该问题等价于如下的判定问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者死循环。艾伦·图灵在1936年用对角论证法证明了，不存在解决停机问题的通用算法。参考：https://wiwiki.kfd.me/wiki/停机问题

##### 符号引用验证

最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段————解析阶段中发生

符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验

比如
- 符号引用中通过字符串描述的全限定名是否能找到对应的类
- 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
- 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问

> 上面四种验证及验证点，能在JVM源码中找到位置吗？

#### 关闭大部分验证措施

对于虚拟机的类加载机制来说，验证阶段时一个非常重要的阶段，但不是一定必要的。如果所运行代码都已经被反复使用和验证过，那么在实施阶段可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间

### 类加载之准备

#### 准备的规范定义

准备阶段正式为静态变量（static修饰的）分配内存于堆区，并设置静态变量的零值（final修饰的除外）。这里不包括普通实例变量

> 在JDK7及之前，Hotspot使用的永久代来实现方法区时，静态变量（也成为类变量）是在方法区中分配的，而JDK8及以后，静态变量会随着Class对象一起移到Java堆中

#### 数据类型的零值

这里再加一点干货：基本数据类型的长度、范围、自动转换关系

|数据类型|零值|长度|范围|
|--|--|--|--|
|boolean|false|1个字节|true或false|
|byte|(byte)0|1个字节|-128~127|
|char|'\u0000'|2个字节|从字符型对应的整型数来划分，其表示范围是0~65535|
|short|(short)0|2个字节|-32768~32767|
|int|0|4个字节|-2147483648~2147483647|
|long|0L|8个字节|-9223372036854775808 ~ 9223372036854775807|
|float|0.0f|4个字节|-3.4E38~3.4E38|
|double|0.0d|8个字节|-1.7E308~1.7E308|
|reference|null|-|-|

##### 自动转换关系

- (byte，short，char) -> int -> long -> float -> double
- 不符合上面关系链的，由高到低的，需要强制转换，比如 int a = 0; char c = (char) a;
- boolean不支持与其他基本类型转换，包括强制转换
- long占8个字节，float占4个字节，但long可以自动转换为float，是因为long是有符号整形，float、double是浮点表示法表示的，二者底层表示方式不一样

#### static+final修饰的变量

static、final同时修饰的变量，不会赋零值，而会赋初值

在javac编译时会为变量生成ConstantValue属性，在准备阶段虚拟机会初始化为ConstantValue属性所指定的值

比如
```java
public static int v1 = 123;
public static final int v2 = 123;
```
在准备阶段结束后，v1是0，v2是123

> 这里要说明的更清楚一些，准备阶段后面还有一个初始化阶段，在初始化阶段，会给静态变量赋初值

> 因此在做题时，不要因为准备阶段是赋零值，而去思考输出结果可能是零值，实际上你无法做到实现一个Java代码，准备阶段后（初始化阶段没进行）输出变量结果，必须要初始化阶段结束，才可能System.out.println的

### 类加载之解析

#### 解析的规范定义

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info

解析动作具体来看，有
- 类或接口的解析。假设有一个类D，要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，分C是或不是数组类型来处理
  - 如果C不是一个数组类型，那么虚拟机会把代表N的全限定名传递给D的类加载器，去加载这个类C（第1点）
  - 如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“【Ljava/lang/Integer”的形式，那么将会按照（第1点）的规则加载数组元素类型，接着虚拟机会生成一个代表此数组维度和元素的数组对象
- 字段解析。需要对字段表内的class_index项中索引的CONSTANT_Class_info符号引用（字段所属的类或接口的符号引用）进行解析
- 类方法解析。需要对方法表的class_index项中索引的CONSTANT_Methodref_info符号引用（方法所属的类或接口的符号引用）进行解析
- 接口方法解析。需要对接口方法表的class_index项中索引的CONSTANT_InterfaceMethodref_info符号引用（方法所属的类或接口的符号引用）进行解析

> 解析阶段的部分关键词是：常量池、符号引用、直接引用、指针、字段表、方法表等，理解这个阶段，需要对运行时常量池、Class文件中的常量池有一定的理解

> 不要认为常量池只是与字符串常量、基本类型数据常量有关系而已，它还与类方法、接口方法等有关系

#### 符号引用替换为直接引用

符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可

直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄

> 其实上面的说法，个人认为是比较讳莫如深的，下面我们举一个代码例子来理解

代码例子

```java
package com.peter.jvm.example;

public class SymbolicReferencesToDirectReferencesTest {

    public static void main(String[] args) {
        SymbolicReferencesToDirectReferencesTest test = new SymbolicReferencesToDirectReferencesTest();
        //while(true);
    }
}
```

用jclasslib分析一下

查看字节码中的常量池（Constant Pool）部分

Constant_Class_info内容为Class name: cp_info_#20 <com/peter/jvm/example/SymbolicReferencesToDirectReferencesTest>

此时是符号引用

![image](https://user-images.githubusercontent.com/10209135/92321733-f074cd00-f05e-11ea-8d0f-5bd7c74c90b2.png)

再用HSDB分析一下

Constant Type = JVM_CONSTANT_Class 时，Constant Value = public class com.peter.jvm.example.SymbolicReferencesToDirectReferencesTest @0x00000007c0060828

此时已经是直接引用了（转换为了内存地址）

![image](https://user-images.githubusercontent.com/10209135/92321723-d9ce7600-f05e-11ea-8ba7-6ab97c1b1991.png)

### 类加载之初始化

#### 初始化的规范定义

初始化阶段是执行类构造器clinit方法的过程
  
clinit方法是由编译器自动收集类中所有静态变量的赋值动作和静态代码块中的语句合并产生的，编辑器收集的顺序是由语句在源文件中出现的顺序所决定的

#### clinit方法的深入理解

> 下面这些总结来自于《深入理解JAVA虚拟机》第二版7.3.5节，我个人觉得挺精髓的，它诠释了clinit方法的功能及特点，clinit与init方法的关系，父子类执行clinit的先后关系，clinit方法的必要性，在接口中执行clinit方法的逻辑，多线程下执行clinit方法的逻辑。整个类加载最核心（从对虚拟机理解层面上讲，相对而言）的两个阶段：加载、初始化。初始化就是执行构造器clinit方法的过程。对于初级程序员来讲，理解了clinit与init两个方法，对JAVA的理解就上了一个台阶了。

##### clinit方法是什么

clinit方法是类构造器方法，编译器会收集所有静态变量的赋值动作、所有静态代码块，合并产生一个方法，即clinit，该方法在类加载中“初始化”阶段被调用

##### clinit方法的功能及特点

- clinit方法会执行静态代码块，给静态变量赋值
- clinit方法执行顺序由源文件中语句出现顺序决定
- 静态代码块中只能访问到定义在静态代码块之前的变量
- 静态代码块中可以给定义在它之后的变量赋值，但不能访问
- 代码例子
```java
public class Test {
  static {
    i = 0; // 给静态变量赋值可以正常编译通过
    System.out.print(i); // 定义在静态代码块之后的变量无法访问，会报编译错误
  }
  static int i = 1;
}
```
##### clinit与init方法的关系

- clinit方法不需要显示地调用父类构造器，init方法需要（这里所说的显示调用应该是指super.xxx()方式）
- 对于new语句，clinit先执行，再执行init，但clinit在一个进程中一般只会执行一次

##### 父子类执行clinit方法的先后关系

- 虚拟机会保证在子类的clinit方法执行之前，父类的clinit访问已经执行完毕（这里只指类，不指接口）
- 由于父类必先比子类加载，因此虚拟机中第一个被执行的clinit方法的类是java.lang.Object的

##### clinit方法的必要性

- clinit方法对于类或接口来说并不是必需的，如果一个类中没有静态代码块，也没有静态变量的赋值，编译器可以不为这个类生成clinit方法
- 代码例子，下面这个代码生成的class文件，查看字节码中是没有clinit方法的
```java
package com.peter.jvm.example;
public class NoClinitTest {
    static String a;
    public static void main(String[] args) {
        a = "1";
    }
}
```

##### 在接口中执行clinit方法的逻辑

- 接口中不能使用静态代码块，但仍然有变量（默认是static、final的）初始化赋值的操作，因此接口与类一样都会生成clinit方法
- 接口与类不同的是，执行接口的clinit方法不需要先执行父接口的方法
- 只有当父接口中定义的变量使用时，父接口的clinit方法才会被执行
- 接口的实现类在执行clinit方法前也不需要先执行接口的clinit方法

##### 多线程下执行clinit方法的逻辑

- 虚拟机会保证一个类的clinit方法再多线程环境中被正确的加锁、同步
- 如果多线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit方法，其他线程都需要阻塞等待，直到活动线程执行clinit方法完毕
- 如果一个类的clinit方法中有耗时很长的操作，就可能造成多个线程阻塞

### 类加载什么时候会进行

参考《深入理解Java虚拟机》第二版 7.2节

五种情况
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类
- 遇到 new、getstatic、putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
- 档使用 JDK1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getstatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化

第五种情况可以忽略不讨论

前四种情况分别举一下例子

#### 加载mainClass

当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类

```java
package com.peter.jvm.example;

public class MainClassTest1 {

    static {
        System.out.println("11");
    }

    public static void main(String[] args) {

    }
}
```

会输出11，虚拟机会对主类进行类加载

来看下openjdk8源码：https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/bin/java.c#L444

```cpp
int JNICALL
JavaMain(void * _args)
{
...
/*
     * Get the application's main class.
     ...
*/
    mainClass = LoadMainClass(env, mode, what);
..
    mainID = (*env)->GetStaticMethodID(env, mainClass, "main",
                                       "([Ljava/lang/String;)V");
...
    (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);
```

#### new或getstatic或putstatic或invokestatic

遇到 new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化

##### new

```java
package com.peter.jvm.example;

public class ByteCodeNewTest1 {

    public static void main(String[] args) {
        ByteCodeNewTest1 t = new ByteCodeNewTest1();
    }
}

class ByteCodeNewTest12 {

    static {
        System.out.println("11");
    }

    ByteCodeNewTest12() {
        System.out.println(a);
        a = "22";
        System.out.println(a);
    }

    static String a = "33";

    static {
        System.out.println(a);
        a = "44";
        System.out.println(a);
    }
}
```

输出结果
```
11
33
44
44
22
```

字节码
```
0 new #2 <com/peter/jvm/example/ByteCodeNewTest12>
3 dup
4 invokespecial #3 <com/peter/jvm/example/ByteCodeNewTest12.<init>>
7 astore_1
8 return
```

解释

ByteCodeNewTest12 t = new ByteCodeNewTest12(); 对应 new ByteCodeNewTest12，ByteCodeNewTest12，输出11、a、a，第一个a是33，第二个a是44，然后调用构造函数，invokespecial ByteCodeNewTest12.init，输出a、a，第一个a是44，第二个a是22

注意：newarray，anewarray不会触发类加载

##### getstatic

```java
package com.peter.jvm.example;

public class ByteCodeGetStaticTest1 {
    
    public static void main(String[] args) {
        String a = ByteCodeGetStaticTest11.a;
        String b = ByteCodeGetStaticTest11.a;
    }
}

class ByteCodeGetStaticTest11 {

    static {
        System.out.println("11");
    }

    public static String a = "22";

    static {
        System.out.println("33");
    }
}
```

输出结果
```
11
33
```

字节码
```
0 getstatic #2 <com/peter/jvm/example/ByteCodeGetStaticTest11.a>
3 astore_1
4 getstatic #2 <com/peter/jvm/example/ByteCodeGetStaticTest11.a>
7 astore_2
8 return
```

解释

String a = ByteCodeGetStaticTest11.a; 对应 getstatic ByteCodeGetStaticTest11.a，会触发ByteCodeGetStaticTest11的类加载，输出11、33

String b = ByteCodeGetStaticTest11.a; 对应 getstatic ByteCodeGetStaticTest11.a，会尝试ByteCodeGetStaticTest11的类加载，发现加载过了，就不加载了

##### putsatic

```java
package com.peter.jvm.example;

public class ByteCodePutStaticTest1 {

    public static void main(String[] args) {
        ByteCodePutStaticTest11.a = "44";
        String a = ByteCodePutStaticTest11.a;
        System.out.println(a);
    }
}

class ByteCodePutStaticTest11 {

    static {
        System.out.println("11");
        //System.out.print(a); // 编译不过
    }

    public static String a = "22";

    static {
        System.out.println("33");
        System.out.println(a);
    }
}
```

输出结果
```
11
33
22
44
```

字节码
```
 0 ldc #2 <44>
 2 putstatic #3 <com/peter/jvm/example/ByteCodePutStaticTest11.a>
 5 getstatic #3 <com/peter/jvm/example/ByteCodePutStaticTest11.a>
 8 astore_1
 9 getstatic #4 <java/lang/System.out>
12 aload_1
13 invokevirtual #5 <java/io/PrintStream.println>
16 return
```

解释

ByteCodePutStaticTest1.a = "44"; 对应 putstatic ByteCodePutStaticTest1.a，会触发对ByteCodePutStaticTest1类加载，输出11、33、a，此时a还是22

String a = ByteCodePutStaticTest1.a; 对应 getstatic ByteCodePutStaticTest1.a，会尝试对ByteCodePutStaticTest1类加载，由于已经加载过了，不加载，a变为44

System.out.println(a); 输出44

##### invokestatic

```java
package com.peter.jvm.example;

public class ByteCodeInvokeStaticTest1 {

    public static void main(String[] args) {
        ByteCodeInvokeStaticTest11.aa();
    }
}

class ByteCodeInvokeStaticTest11 {

    {
        System.out.println("33");
    }

    static {
        System.out.println("44");
    }

    static void aa() {
        System.out.println(a);
    }

    static {
        System.out.println("66");
    }

    public static String a = new String("11");

    public String b = new String("22");

    void bb() {
        System.out.println("55");
    }
}
```

输出结果
```
44
66
11
```

字节码
```
0 invokestatic #2 <com/peter/jvm/example/ByteCodeInvokeStaticTest11.aa>
3 return
```

解释

ByteCodeInvokeStaticTest11.aa(); 对应着 invokestatic ByteCodeInvokeStaticTest11.aa，会先触发对ByteCodeInvokeStaticTest11类加载，输出44、66，再invoke aa，输出11

#### 优先加载父类

当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化

下面以invokestatic举例子（new、getstatic、putstatic同理）

##### 加载一个类时，会先去加载它的父类

```java
public class ByteCodeInvokeStaticSuperClassTest1 {

    public static void main(String[] args) {
        ByteCodeInvokeStaticSuperClassTest11.aa();
    }
}

class ByteCodeInvokeStaticSuperClassTest11 extends ByteCodeInvokeStaticSuperClassTest12 {

    static {
        System.out.println("11");
    }

    ByteCodeInvokeStaticSuperClassTest11() {
        System.out.println("22");
    }

    static void aa() {
        System.out.println("33");
    }

    static {
        System.out.println("44");
    }
}

class ByteCodeInvokeStaticSuperClassTest12 {

    static {
        System.out.println("55");
    }

    ByteCodeInvokeStaticSuperClassTest12() {
        System.out.println("66");
    }

    static void aa() {
        System.out.println("77");
    }

    static {
        System.out.println("88");
    }

}
```

输出结果
```
55
88
11
44
33
```

字节码
```
0 invokestatic #2 <com/peter/jvm/example/ByteCodeInvokeStaticSuperClassTest11.aa>
3 return
```

解释

ByteCodeInvokeStaticSuperClassTest11.aa(); 对应着 invokestatic ByteCodeInvokeStaticSuperClassTest11.aa，会先对父类ByteCodeInvokeStaticSuperClassTest11加载，输出55、88，然后对子类ByteCodeInvokeStaticSuperClassTest11加载，输出11、44，最后invokestatic ByteCodeInvokeStaticSuperClassTest11.aa，输出33

##### 加载一个类时，不会去加载它的子类

```java
package com.peter.jvm.example;

public class ByteCodeInvokeStaticSubClassTest1 {

    public static void main(String[] args) {
        ByteCodeInvokeStaticSubClassTest12.aa();
    }
}

class ByteCodeInvokeStaticSubClassTest11 extends ByteCodeInvokeStaticSubClassTest12 {

    static {
        System.out.println("11");
    }

    ByteCodeInvokeStaticSubClassTest11() {
        System.out.println("22");
    }

    static void aa() {
        System.out.println("33");
    }

    static {
        System.out.println("44");
    }
}

class ByteCodeInvokeStaticSubClassTest12 {

    static {
        System.out.println("55");
    }

    ByteCodeInvokeStaticSubClassTest12() {
        System.out.println("66");
    }

    static void aa() {
        System.out.println("77");
    }

    static {
        System.out.println("88");
    }

}
```

输出结果
```
55
88
77
```

字节码
```
0 invokestatic #2 <com/peter/jvm/example/ByteCodeInvokeStaticSubClassTest12.aa>
3 return
```

解释

ByteCodeInvokeStaticSubClassTest12.aa(); 对应着 invokestatic ByteCodeInvokeStaticSubClassTest12.aa，会触发对类ByteCodeInvokeStaticSubClassTest12加载，输出55、88，然后invokestatic ByteCodeInvokeStaticSubClassTest12.aa，输出77。由于ByteCodeInvokeStaticSubClassTest11是子类，对父类加载不会触发对子类加载

#### 反射

使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化

```java
package com.peter.jvm.example;

public class ReflectClassTest1 {

    public static void main(String[] args) {
        try {
            Class c = ReflectClassTest11.class;
            c.getMethod("b").invoke(new Object());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class ReflectClassTest11 {

    static {
        System.out.println("11");
    }

    public static String a = "22";

    static {
        System.out.println("33");
    }

    public static void b() {
        System.out.println("44");
    }
}
```

输出结果
```
11
33
44
```

解释

通过反射，调用函数b，会先进行类加载

如果try代码块中改成 Class c = Class.forName("com.peter.jvm.example.ReflectClassTest11");，也会进行类加载

#### 关于抽象类

与普通类规则一样

#### 关于接口（Interface）

- 接口中可以定义域（field），即变量，但隐式的都是static和final的
- 对接口进行类加载时，会对其成员变量（默认都是static的）进行初始化
- 对接口进行类加载时，不会加载其父接口
- 对实现一个接口的类进行类加载时，不会对接口进行类加载

```java
public class InterfaceClassLoaderTest1 implements InterfaceClassLoaderTest11 {

    public static void main(String[] args) {
        InterfaceClassLoaderTest1 t = new InterfaceClassLoaderTest1();
        System.out.println("11");
        InterfaceClassLoaderTest11.a.toString();
    }
}

interface InterfaceClassLoaderTest11 extends InterfaceClassLoaderTest12 {
    InterfaceClassLoaderTest13 a = new InterfaceClassLoaderTest13();
    InterfaceClassLoaderTest15 b = new InterfaceClassLoaderTest15();
}

interface InterfaceClassLoaderTest12 {
    InterfaceClassLoaderTest14 a = new InterfaceClassLoaderTest14();
}

class InterfaceClassLoaderTest13 {
    static {
        System.out.println("33");
    }
}

class InterfaceClassLoaderTest14 {
    static {
        System.out.println("44");
    }
}

class InterfaceClassLoaderTest15 {
    static {
        System.out.println("55");
    }
}
```

输出结果
```
11
33
55
```

字节码
```
 0 new #2 <com/peter/jvm/example/InterfaceClassLoaderTest1>
 3 dup
 4 invokespecial #3 <com/peter/jvm/example/InterfaceClassLoaderTest1.<init>>
 7 astore_1
 8 getstatic #4 <java/lang/System.out>
11 ldc #5 <11>
13 invokevirtual #6 <java/io/PrintStream.println>
16 getstatic #7 <com/peter/jvm/example/InterfaceClassLoaderTest11.a>
19 invokevirtual #8 <java/lang/Object.toString>
22 pop
23 return
```

解释

InterfaceClassLoaderTest1 t = new InterfaceClassLoaderTest1 (); 对应 new InterfaceClassLoaderTest1 ，会对类InterfaceClassLoaderTest1 进行类加载，但不会对接口InterfaceClassLoaderTest11 进行类加载，因此无输出

System.out.println("11");，输出11

InterfaceClassLoaderTest11.a.toString(); 对应 getstatic InterfaceClassLoaderTest11.a，会对InterfaceClassLoaderTest11进行类加载，InterfaceClassLoaderTest13 a和InterfaceClassLoaderTest15 b都是static的，它们都执行了new，都会加载这两个类，因此输出33和55

对接口进行类加载时，不会加载其父接口

### 类加载之数组类

数组本质也是一个类，注意不要与它的元素类搞混淆，比如B[] b = new B[100]，B[]是数组类，B是元素类

new一个数组对象时，是不会加载对应的元素类

```java
public class ArraysTest {

    public static void main(String[] args) {
        A a = new A();
        B[] b = new B[100];
    }

    private static class A {
        static {
            System.out.println("A");
        }
    }

    private static class B {
        static {
            System.out.println("B");
        }
    }
}
```

输出结果
```
A
```

解释

B[] b = new B[100]; 只是初始化了一个数组对象，为该数组对象分配了内存，但没有为100个数组元素分配内存。假设B占1个字节，B[] b = new B[100]; 这句话会分配100个字节的内存，这样理解是不正确的。很显然new B[100]之后每个元素都是null，null是没有内存地址的，只有在数组元素初始化时才会去分配内存

这里最大的质疑问题是：加载一个数组，需要知道分配多少内存，分配内存就需要类加载，可为什么不需要加载元素类呢

在学完对象内存布局后，上面的质疑就可以清晰地回答了
- 数组也是一个类，叫数组类，它与普通类有区别，类加载过程不太一样
- A[] a = new A[3]; 这句话，是对A[] 这个数组类加载了，没有对A这个元素类加载
- 加载A[] 这个数组类，是需要知道要分配多少内存的，这个肯定
- 就需要看一看数组对象 内部结构了，如下
  - 对象头（包括MarkWord、类型指针、数组长度）
  - 实例数据
  - 对齐填充
- 关键在于实例数据，比如A[] a = new A[3]; 其中3个元素是分配在实例数据中的，而关键又在于分配的是什么
- 如果一个数组 int[] a = new int[3]; 这种情况下，实例数据占12个字节，因为int占4个，有3个int
- 如果一个数组 A[] a = new A[3]; 这种情况下，若开启指针压缩，实例数据占 12 个字节，若不开启指针压缩，实例数据占 24 个字节
- 这里有个概念，1个引用类型，开启指针压缩是4个字节，不开启是8个字节
- 然后可以看出来，对一个数组类分配内存的时候，其实是不需要知道元素类占多少内存的，数组对象中实例数据存储的是引用，也就是一个指向堆区对象的指针引用，它是4个字节或8个字节（是否开启指针压缩），只存储引用，不需要关心元素类占多少内存，也就不需要元素类的类加载了

### 类加载笔试题统一解法

通过上面例子，我们见到了一些关于类加载触发时机、父子类类加载关系的题目，基本上题型都一样，给一段简单的代码，请问代码的输出结果是什么，有的是问答题，有的是选择题，这类题目在Java基础笔试题中占一定比重

经过总结，统一解法满足以下十条规则
- 规则一：main函数所在类最先进行加载，结束后执行main方法
- 规则二：加载一个类之前，会先加载该类的父类，但不会加载该类实现的接口
- 规则三：加载一个接口，不会加载其父接口
- 规则四：默认情况下，同一个类加载器，已经加载过的类不会加载（非默认情况是指自定义类加载器）
- 规则五：类加载会在“初始化”阶段，调用clinit方法，执行静态代码块，对静态变量赋值，二者优先级一致
- 规则六：clinit方法执行顺序与代码书写顺序保持一致
- 规则七：当遇到 反射调用 或者new、getstatic、putstatic、invokestatic这4条字节码指令时，会插入结算新的类加载，再执行指令，再继续旧的类加载
- 规则八：每次实例化一个类时，都会先实例化父类
- 规则九：每次实例化一个类时，都会先执行完所有构造代码块，再执行构造函数
- 规则十：new一个数组对象时，不会加载对应的元素类

下面举一个例子来充实上面的规则

```java
package com.peter.jvm.example;

public class ClassLoaderAllTest {

    static {
        System.out.println("ClassLoaderAllTest clinit 1");
    }

    static ClassLoaderAllTest1 test1 = new ClassLoaderAllTest1();

    static {
        System.out.println("ClassLoaderAllTest clinit 2");
    }

    public static void main(String[] args) throws Exception {
        System.out.println("ClassLoaderAllTest main 1");
        ClassLoaderAllTest6 test6 = ClassLoaderAllTest4.test6;
        System.out.println("ClassLoaderAllTest main 2");
        Class classTest5 = Class.forName("com.peter.jvm.example.ClassLoaderAllTest5");
        classTest5.getMethod("test5").invoke(0);
    }
}

class ClassLoaderAllTest1 extends ClassLoaderAllTest2 implements ClassLoaderAllTest4, ClassLoaderAllTest5 {
    static {
        System.out.println("ClassLoaderAllTest1 clinit");
        ClassLoaderAllTest3.test3_1 = "ClassLoaderAllTest3 test3_1 Test1";
    }
    ClassLoaderAllTest1() {
        System.out.println("ClassLoaderAllTest1 init");
    }
    {
        System.out.println("ClassLoaderAllTest1 init without function");
    }
}

class ClassLoaderAllTest2 {
    {
        System.out.println("ClassLoaderAllTest2 init without function 1");
    }
    static {
        System.out.println("ClassLoaderAllTest2 clinit");
        System.out.println(ClassLoaderAllTest3.test3_2);
    }
    ClassLoaderAllTest2() {
        System.out.println("ClassLoaderAllTest2 init");
    }
    {
        System.out.println("ClassLoaderAllTest2 init without function 2");
    }
}

class ClassLoaderAllTest3 {
    static String test3_1 = "ClassLoaderAllTest3 test3_1";
    static final String test3_2 = "ClassLoaderAllTest3 test3_2";
    static {
        System.out.println(test3_1);
    }
}

interface ClassLoaderAllTest4 extends ClassLoaderAllTest5 {
    ClassLoaderAllTest7 test7 = new ClassLoaderAllTest7();
    ClassLoaderAllTest6 test6 = new ClassLoaderAllTest6();
}

interface ClassLoaderAllTest5 {
    ClassLoaderAllTest7 test7 = new ClassLoaderAllTest7();
    ClassLoaderAllTest8 test8 = new ClassLoaderAllTest8();
    static void test5() {
        System.out.println("ClassLoaderAllTest5 test5");
    }
}

class ClassLoaderAllTest6 {
    static {
        System.out.println("ClassLoaderAllTest6 clinit");
    }
}

class ClassLoaderAllTest7 {
    static {
        System.out.println("ClassLoaderAllTest7 clinit");
    }
}

class ClassLoaderAllTest8 {
    static {
        System.out.println("ClassLoaderAllTest8 clinit");
    }
}
```

输出结果
```
ClassLoaderAllTest clinit 1
ClassLoaderAllTest2 clinit
ClassLoaderAllTest3 test3_2
ClassLoaderAllTest1 clinit
ClassLoaderAllTest3 test3_1
ClassLoaderAllTest2 init without function 1
ClassLoaderAllTest2 init without function 2
ClassLoaderAllTest2 init
ClassLoaderAllTest1 init without function
ClassLoaderAllTest1 init
ClassLoaderAllTest clinit 2
ClassLoaderAllTest main 1
ClassLoaderAllTest7 clinit
ClassLoaderAllTest6 clinit
ClassLoaderAllTest main 2
ClassLoaderAllTest8 clinit
ClassLoaderAllTest5 test5
```

#### 解释
##### 程序开始
##### 加载ClassLoaderAllTest类开始
- 由于规则一，因此最先加载ClassLoaderAllTest类
- 由于规则五、六，因此执行System.out.println("ClassLoaderAllTest clinit 1"); 再执行static ClassLoaderAllTest1 test1 = new ClassLoaderAllTest1(); 再执行System.out.println("ClassLoaderAllTest static 2");
- 由于执行了System.out.println("ClassLoaderAllTest clinit 1"); 因此输出ClassLoaderAllTest clinit 1
- 再执行static ClassLoaderAllTest1 test1 = new ClassLoaderAllTest1()
- static ClassLoaderAllTest1 test1 = new ClassLoaderAllTest1();对应的字节码是new #9 <com/peter/jvm/example/ClassLoaderAllTest1>
- 由于规则七，因此先加载ClassLoaderAllTest1类，再new
##### 加载ClassLoaderAllTest1类开始（尚未开始）
- class ClassLoaderAllTest1 extends ClassLoaderAllTest2，即ClassLoaderAllTest2是ClassLoaderAllTest1的父类
- 由于规则二，因此先加载ClassLoaderAllTest2类
- class ClassLoaderAllTest1 implements ClassLoaderAllTest4, ClassLoaderAllTest5，即ClassLoaderAllTest1实现了ClassLoaderAllTest4、ClassLoaderAllTest5接口
- 由于规则三，因此不会加载ClassLoaderAllTest4、ClassLoaderAllTest5接口
##### 加载ClassLoaderAllTest2类开始
- 由于规则五、六，因此执行System.out.println("ClassLoaderAllTest2 clinit"); 再执行System.out.println(ClassLoaderAllTest3.test3_2);
- 由于执行了System.out.println("ClassLoaderAllTest2 clinit"); 因此输出ClassLoaderAllTest2 clinit
- 再执行System.out.println(ClassLoaderAllTest3.test3_2); 因此输出ClassLoaderAllTest3 test3_2
- System.out.println(ClassLoaderAllTest3.test3_2);对应字节码是getstatic #2 <java/lang/System.out>、ldc #6 <ClassLoaderAllTest3 test3_2>、invokevirtual #4 <java/io/PrintStream.println>，这里没有getstatic ClassLoaderAllTest3.test3_2，因此不会去加载ClassLoaderAllTest3
- 没有getstatic ClassLoaderAllTest3.test3_2的原因是test3_2是final修饰的，编译器会对它做处理，在准备阶段就会初始化为一个ConstantValue属性所指定的值
##### 加载ClassLoaderAllTest2类完毕
- 加载完ClassLoaderAllTest2类，回来，加载ClassLoaderAllTest1类
##### 加载ClassLoaderAllTest1类开始（正式开始）
- 由于规则五、六，执行System.out.println("ClassLoaderAllTest1 clinit"); 再执行ClassLoaderAllTest3.test3_1 = "ClassLoaderAllTest3 test3_1 Test1";
- 由于执行了System.out.println("ClassLoaderAllTest1 clinit");，因此输出ClassLoaderAllTest1 clinit
- 再执行ClassLoaderAllTest3.test3_1 = "ClassLoaderAllTest3 test3_1 Test1";
- ClassLoaderAllTest3.test3_1 = "ClassLoaderAllTest3 test3_1 Test1";对应字节码是putstatic #6 <com/peter/jvm/example/ClassLoaderAllTest3.test3_1>
- 由于规则七，因此先加载ClassLoaderAllTest3类，再putstatic
##### 加载ClassLoaderAllTest3类开始
- 由于规则五、六，因此执行static String test3_1 = "ClassLoaderAllTest3 test3_1"; 再执行System.out.println(test3_1); 再执行ClassLoaderAllTest3.test3_1 = "ClassLoaderAllTest3 test3_1 Test1";
- 由于执行了System.out.println(test3_1); 因此输出ClassLoaderAllTest3 test3_1，而不是输出ClassLoaderAllTest3 test3_1 Test1
##### 加载ClassLoaderAllTest3类完毕
##### 加载ClassLoaderAllTest1类完毕
- 加载完ClassLoaderAllTest1类，回来，执行new #9 <com/peter/jvm/example/ClassLoaderAllTest1>，实例化ClassLoaderAllTest1类
##### 实例化ClassLoaderAllTest1类开始
- class ClassLoaderAllTest1 extends ClassLoaderAllTest2，即ClassLoaderAllTest2是ClassLoaderAllTest1的父类
- 由于规则八，因此先实例化ClassLoaderAllTest2类
##### 实例化ClassLoaderAllTest2类开始
- 由于规则九，因此先执行所有构造代码块，再执行构造函数
- 由于执行了System.out.println("ClassLoaderAllTest2 init without function 1"); 因此输出ClassLoaderAllTest2 init without function 1
- 由于执行了System.out.println("ClassLoaderAllTest2 init without function 2"); 因此输出ClassLoaderAllTest2 init without function 2
- 由于执行了System.out.println("ClassLoaderAllTest2 init"); 因此输出ClassLoaderAllTest2 init
##### 实例化ClassLoaderAllTest2类结束
- 由于规则九，因此先执行所有构造代码块，再执行构造函数
- 由于执行了System.out.println("ClassLoaderAllTest1 init without function"); 因此输出ClassLoaderAllTest1 init without function
- 由于执行了System.out.println("ClassLoaderAllTest1 init"); 因此输出ClassLoaderAllTest1 init
##### 实例化ClassLoaderAllTest1类结束
- 实例化完ClassLoaderAllTest1类，回来，执行System.out.println("ClassLoaderAllTest clinit 2");
- 由于执行了System.out.println("ClassLoaderAllTest clinit 2"); 因此输出ClassLoaderAllTest clinit 2
##### 加载ClassLoaderAllTest类完毕
- 由于规则一，加载完ClassLoaderAllTest类，执行main方法
##### 执行ClassLoaderAllTest的main方法开始
- 由于执行了System.out.println("ClassLoaderAllTest main 1"); 因此输出ClassLoaderAllTest main 1
- 再执行ClassLoaderAllTest6 test6 = ClassLoaderAllTest4.test6;
- ClassLoaderAllTest6 test6 = ClassLoaderAllTest4.test6;对应的字节码是getstatic #5 <com/peter/jvm/example/ClassLoaderAllTest4.test6>
- 由于规则七，因此先加载ClassLoaderAllTest4接口，再getstatic
- interface ClassLoaderAllTest4 extends ClassLoaderAllTest5，即ClassLoaderAllTest5是ClassLoaderAllTest4的父接口
- 由于规则三，因此不会加载ClassLoaderAllTest5接口
##### 加载ClassLoaderAllTest4接口开始
- 接口中的变量都是默认static、final修饰的
- 由于规则五、六，执行ClassLoaderAllTest7 test7 = new ClassLoaderAllTest7(); 再执行ClassLoaderAllTest6 test6 = new ClassLoaderAllTest6();
- ClassLoaderAllTest7 test7 = new ClassLoaderAllTest7();对应的字节码是new #1 <com/peter/jvm/example/ClassLoaderAllTest7>
- 由于规则七，因此先加载ClassLoaderAllTest7类，再new
##### 加载ClassLoaderAllTest7类开始
- 由于规则五、六，执行System.out.println("ClassLoaderAllTest7 clinit");
- 由于执行了System.out.println("ClassLoaderAllTest7 clinit"); 因此输出ClassLoaderAllTest7 clinit
##### 加载ClassLoaderAllTest7类结束
- ClassLoaderAllTest6 test6 = new ClassLoaderAllTest6();对应字节码是new #4 <com/peter/jvm/example/ClassLoaderAllTest6>
- 由于规则七，因此先加载ClassLoaderAllTest6类，再new
##### 加载ClassLoaderAllTest6类开始
- 由于规则五、六，执行System.out.println("ClassLoaderAllTest6 clinit");
- 由于执行了System.out.println("ClassLoaderAllTest6 clinit"); 因此输出ClassLoaderAllTest6 clinit
##### 加载ClassLoaderAllTest6类结束
##### 加载ClassLoaderAllTest4接口结束
- 回到main方法
- 由于执行了System.out.println("ClassLoaderAllTest main 2"); 因此输出ClassLoaderAllTest main 2
- 继续，执行Class classTest5 = Class.forName("com.peter.jvm.example.ClassLoaderAllTest5");
- Class classTest5 = Class.forName("com.peter.jvm.example.ClassLoaderAllTest5");对应着ldc #7 <com.peter.jvm.example.ClassLoaderAllTest5> 以及 invokestatic #8 <java/lang/Class.forName>
- 由于规则七，因此先加载ClassLoaderAllTest5类
##### 加载ClassLoaderAllTest5类开始
- 由于规则五、六，执行ClassLoaderAllTest7 test7 = new ClassLoaderAllTest7(); 再ClassLoaderAllTest8 test8 = new ClassLoaderAllTest8();
- ClassLoaderAllTest7 test7 = new ClassLoaderAllTest7();对应字节码是new #4 <com/peter/jvm/example/ClassLoaderAllTest7>
- 由于规则七，因此先加载ClassLoaderAllTest7类，再new
- 由于规则四，已经加载过的类不会加载
- ClassLoaderAllTest8 test8 = new ClassLoaderAllTest8();对应字节码是new #7 <com/peter/jvm/example/ClassLoaderAllTest8>
- 由于规则七，因此先加载ClassLoaderAllTest8类，再new
##### 加载ClassLoaderAllTest8类开始
- 由于规则五、六，执行System.out.println("ClassLoaderAllTest8 clinit");
- 由于执行了System.out.println("ClassLoaderAllTest8 clinit"); 因此输出ClassLoaderAllTest8 clinit
##### 加载ClassLoaderAllTest8类结束
##### 加载ClassLoaderAllTest5类结束
- 继续，执行classTest5.getMethod("test5").invoke(0);
- classTest5.getMethod("test5").invoke(0);对应字节码是invokevirtual #14 <java/lang/reflect/Method.invoke>，会调用ClassLoaderAllTest5的test5方法
- 由于执行了System.out.println("ClassLoaderAllTest5 test5"); 因此输出ClassLoaderAllTest5 test5
##### 执行ClassLoaderAllTest的main方法结束
##### 程序结束
