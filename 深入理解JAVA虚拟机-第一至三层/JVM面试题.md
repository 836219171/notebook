- [JVM面试题](#JVM面试题)
  - [为什么说JAVA是一种半编译半解释型语言](#为什么说JAVA是一种半编译半解释型语言)
  - [什么情况下需要破坏双亲委派模型](#什么情况下需要破坏双亲委派模型)
  - [GCRoots的作用以及哪些引用可以作为GCRoots](#GCRoots的作用以及哪些引用可以作为GCRoots)
  - [说下常用垃圾收集器的工作原理](#说下常用垃圾收集器的工作原理)
  - [如何选择一款垃圾收集器](#如何选择一款垃圾收集器)
  - [GC调优策略经验总结](#GC调优策略经验总结)
  - [CPU占用过高问题排查](#CPU占用过高问题排查)

# JVM面试题

### 为什么说JAVA是一种半编译半解释型语言

JAVA代码并不像C++那样，是一步将代码编译成机器码，交由CPU处理器执行的，而是先编译成class文件，然后交由虚拟机运行，虚拟机还需要翻译字节码成机器码，这就是“半”的含义

体现在两个方面，一是 JAVAC 编译，JAVA 运行，二是解释器解释执行，编译器编译执行

JAVA代码通过JAVAC编译器编译成class文件，虚拟机运行时通过类加载读入class文件，转化为方法区中的类的元信息数据，同时启动Main类的main方法，通过字节码执行引擎执行字节码

字节码是不能被CPU处理器识别的指令，它需要被翻译成汇编码和机器码，翻译的过程最初只有解释器逐行解释执行，后来演化出了编译器将热点代码直接编译成汇编码或机器码的方式来编译执行，还演化出了如栈上分配、指令重排序等优化技术

### 什么情况下需要破坏双亲委派模型

ClassLoader 类中的 loadClass 方法负责进行类加载，其中的关键逻辑是，如果存在父类加载器，优先交给父类加载器加载，若加载失败，则交由 findClass 方法加载，这就是双拼委派模型的实现

双亲委派模型是对系统关键类的保护机制，防止JDK中的类被子类加载器给加载了，它应当就只能被启动类加载器加载

而有些场景下，需要让父类加载器去加载非它管辖范围内的类时，就需要打破双亲委派了，比如 java.sql.DriverManager 是由启动类加载器管辖的，但各厂商对 java.sql.Driver 有不同的实现类，此时启动类加载器就需要委托应用程序类加载器加载实现类了，这就破坏了双亲委派模型。这里具体代码可见 DriverManager 类的 getConnection、isDriverAllowed 方法

### GCRoots的作用以及哪些引用可以作为GCRoots

GCRoots 与可达性分析算法有关，可达性分析算法是用于扫描已创建的对象哪些是没有被直接或间接引用，可以被回收的了，算法中采用了类似图论的方式，将众多引用到对象的有向边联结起来，构建成一张图，那么图的许多起点就是 GCRoots，从 GCRoots 开始能到达的对象说明存在引用关系，而不能到达的对象认为可以被回收

可以作为GCRoots的引用有
- 栈帧的局部变量表中的引用
- 方法区中类变量的引用
- 字符串常量池中的引用
- synchonized持有的对象引用

### 说下常用垃圾收集器的工作原理

TODO

### 如何选择一款垃圾收集器

根据应用场景来选择（三个角度：吞吐量、延迟、内存占用）
- 如果是数据分析、科学计算类的任务，目标是能尽快算出结果，那吞吐量就是主要关注点
- 如果是SLA应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点
- 如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的
- 如果你接手的是遗留系统，软硬件基础设施和JDK版本都比较落后，那就根据内存规模衡量一下，对于大概4GB到6GB以下的堆内存，CMS一般能处理得比较好，而对于更大的堆内存，可重点考察一下G1

还需结合基础设施来选择
- 运行应用的基础设施，譬如硬件规格，要涉及的系统架构是x86-32/64、SPARC还是ARM/Aarch64
- 处理器的数量多少，分配内存的大小
- 选择的操作系统是Linux、Solaris还是Windows等
- 使用JDK的发行商、版本号

当然，以上都是仅从理论出发的分析，实战中切不可纸上谈兵，根据系统实际情况去测试才是选择收集器的最终依据

### GC调优策略经验总结

JVM调优经验基本可以等价于GC调优经验，试想，如果GC堆能稳定分配对象并清理垃圾，不会出现OOM、慢执行的情况，那么还有什么是需要调优的呢

因此，但凡谈到JVM调优，都可以往GC堆、GC策略、新生代、老年代方面去谈

下面是经验总结（供参考）
- （1）如果满足这样的指标，则一般不需要进行 GC 优化。即 MinorGC 执行时间不到50ms，Minor GC 执行不频繁，约 10秒 到 120 秒一次（看具体业务）。Full GC 执行时间不到1s，Full GC 执行频率不算频繁，约 10分钟 到 1小时一次（看具体业务）
- （2）项目上线前，要设置好虚拟机堆区的最大值以及内部区域的比例值，通过监控工具（VisualVM等）测试观察堆区内存变化，是否会频繁发生Full GC，是否可能会内存溢出。同时要设置好虚拟机参数，比如 -XX:+HeapDumpOnOutOfMemoryError，以便能在OOM 时生成堆转储快照
- （3）优化思路，将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过 -Xmn 命令调节新生代大小，最大限度降低新对象直接进入老年代的情况
- （4）大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的，但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 Full GC。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦，写代码应避免之）。-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小
- （5）合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小（最高为15），减少老年代的内存占用，降低 Full GC 发生的频率。同时还要注意虚拟机的一个策略————动态年龄判断
- （6）当出现 OOM 或 GC Overhead Limit Exceeded 时，生成内存堆转储快照或者GC日志，可以使用VisualVM来进行分析，判断内存泄漏还是内存溢出，如果是内存泄漏，则使用工具对GC Roots的引用链进行分析，判断为何垃圾收集器无法回收这些对象；如果是内存溢出，那就应当检查虚拟机的堆参数（-Xmx、-Xms、-Xmn），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗

#### CPU占用过高问题排查

这是一道经典的面试问题

解决办法思路：（1）查到占CPU高的进程和线程ID（2）通过线程堆栈工具查找堆栈日志（3）分析业务代码

关于（1），可以用 VisualVM、Arthas，而 Linux 上还可以用 top 命令

关于（2），可以用 jstack、VisualVM、Arthas

以Linux上举例
- top，查到占CPU最高的进程ID
- top -H -p < 进程ID >，查到进程中占CPU最高的线程ID
- 将线程ID从十进制转十六进制
- jstack 进程ID | grep 十六进制线程ID -A 30，查看线程堆栈，可定位到哪一行代码导致的

CPU占用过高、死循环、死锁问题，都可以用 VisualVM、Arthas 来分析

