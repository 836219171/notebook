- [JVM面试题](#JVM面试题)
  - [为什么说JAVA是一种半编译半解释型语言](#为什么说JAVA是一种半编译半解释型语言)
  - [GCRoots的作用以及哪些引用可以作为GCRoots](#GCRoots的作用以及哪些引用可以作为GCRoots)
  - [如何选择一款垃圾收集器](#如何选择一款垃圾收集器)
  - [GC调优策略总结参考](#GC调优策略总结参考)

# JVM面试题

### 为什么说JAVA是一种半编译半解释型语言

JAVA代码并不像C++那样，是一步将代码编译成机器码，交由CPU处理器执行的，而是先编译成class文件，然后交由虚拟机运行，虚拟机还需要翻译字节码成机器码，这就是“半”的含义

体现在两个方面，一是 JAVAC 编译，JAVA 运行，二是解释器解释执行，编译器编译执行

JAVA代码通过JAVAC编译器编译成class文件，虚拟机运行时通过类加载读入class文件，转化为方法区中的类的元信息数据，同时启动Main类的main方法，通过字节码执行引擎执行字节码

字节码是不能被CPU处理器识别的指令，它需要被翻译成汇编码和机器码，翻译的过程最初只有解释器逐行解释执行，后来演化出了编译器将热点代码直接编译成汇编码或机器码的方式来编译执行，还演化出了如栈上分配、指令重排序等优化技术

### GCRoots的作用以及哪些引用可以作为GCRoots

GCRoots 与可达性分析算法有关，可达性分析算法是用于扫描已创建的对象哪些是没有被直接或间接引用，可以被回收的了，算法中采用了类似图论的方式，将众多引用到对象的有向边联结起来，构建成一张图，那么图的许多起点就是 GCRoots，从 GCRoots 开始能到达的对象说明存在引用关系，而不能到达的对象认为可以被回收

可以作为GCRoots的引用有
- 栈帧的局部变量表中的引用
- 方法区中类变量的引用
- 字符串常量池中的引用
- synchonized持有的对象引用

### 如何选择一款垃圾收集器

根据应用场景来选择（三个角度：吞吐量、延迟、内存占用）
- 如果是数据分析、科学计算类的任务，目标是能尽快算出结果，那吞吐量就是主要关注点
- 如果是SLA应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点
- 如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的
- 如果你接手的是遗留系统，软硬件基础设施和JDK版本都比较落后，那就根据内存规模衡量一下，对于大概4GB到6GB以下的堆内存，CMS一般能处理得比较好，而对于更大的堆内存，可重点考察一下G1

还需结合基础设施来选择
- 运行应用的基础设施，譬如硬件规格，要涉及的系统架构是x86-32/64、SPARC还是ARM/Aarch64
- 处理器的数量多少，分配内存的大小
- 选择的操作系统是Linux、Solaris还是Windows等
- 使用JDK的发行商、版本号

当然，以上都是仅从理论出发的分析，实战中切不可纸上谈兵，根据系统实际情况去测试才是选择收集器的最终依据

### GC调优策略总结参考

下面是经验总结（供参考）
- 策略 1：将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况
- 策略 2：大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小
- 策略 3：合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率
- 策略 4：设置稳定的堆大小，堆大小设置有两个参数：-Xms 初始化堆大小，-Xmx 最大堆大小
- 策略 5：注意： 如果满足下面的指标，则一般不需要进行 GC 优化：MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次
