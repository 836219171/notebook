- [垃圾收集机制](#垃圾收集机制)
  - [垃圾收集算法](#垃圾收集算法)
    - [标记清除算法](#标记清除算法)
    - [标记整理算法](#标记整理算法)
    - [复制算法](#复制算法)
  - [垃圾收集的实现](#垃圾收集的实现)
    - [分代收集算法](#分代收集算法)
    - [引用计数算法](#引用计数算法)
    - [可达性分析算法](#可达性分析算法)
  - [垃圾收集器](#垃圾收集器)
    - TODO
  - [理解GC日志](#理解GC日志)
  - [内存分配与回收策略](#内存分配与回收策略)
    - [对象优先在Eden区分配](#对象优先在Eden区分配)
    - [长期存活的对象进入老年代](#长期存活的对象进入老年代)
    - [动态年龄判断](#动态年龄判断)
    - [大对象直接进入老年代](#大对象直接进入老年代)
    - [空间分配担保](#空间分配担保)
    - [栈上分配策略](#栈上分配策略)

# 垃圾收集机制

> 本章核心：以实际代码例子及垃圾收集器的GC日志，带入理解垃圾收集算法原理、内存分配回收策略

> 在写这篇文章前，我非常地纠结，或者说无从下笔，因为我一直找不到一个连贯的思路把垃圾收集机制中内容连串起来，反复之下，我只能先将文章轮廓大概给规划出来，至少知道该写哪些部分，但具体如何写，花了挺长时间进行摸索。直到我接触到了一个“垃圾收集算法C++实现DEMO”项目后，才慢慢有了些眉目。这个项目的代码在：https://github.com/peteryuanpan/garbage-collect-demo

> 我的问题在于，对垃圾收集完整的过程理解不清晰，不清楚切入点在哪。现在我的理解是这样的：垃圾收集与内存分配是息息相关，不可区分的。因为垃圾收集的触发时机，是对应区域（Eden区对应MinorGC、老年代对应FullGC）内存无法分配时触发的（我确认过很多次，可以认为不存在其他时机），而我之前的认识中，一直没有将这二者关联起来，甚至还想过“内存分配与回收策略”单独放到上一章“对象的生命周期”来写（怎么说也是对象在堆区中被管理的过程嘛）

> 在逐步理解了后，我再去看《深入理解JAVA虚拟机》（垃圾收集这一章第三版比第二版多了不少内容）以及视频课，就基本知道这一章到底该如何写了，我准备从4个方面来谈，分别是：垃圾收集算法、垃圾收集的实现、垃圾收集器、内存分配与回收策略
> - 第一部分，我将先从3个最基础的垃圾收集算法讲起，它们分别是：标记清除算法、标记整理算法、复制算法。我会把“垃圾收集算法C++实现DEMO”中的思想与输出结果融入到文章中路来，这3个算法是所有后续算法与实现的基础，理解了它们之后再去看其他内容
> - 第二部分

### 垃圾收集算法

TODO：加上垃圾收集算法C++实现项目的理解

#### 标记清除算法

思想：标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程用到引用计数算法、可达性分析算法，还有并发三色标记（标记清除算法是最基础的算法，后续的收集算法都是基于标记清除算法而改进的）

缺点：一，标记和清除效率都低，二，大量不连续的内存碎片，可能由于内存不够导致频繁垃圾回收

#### 标记整理算法

思想：与标记清除类似，标记过程不变，但整理过程是将所有对象移向一端，回收后存活的对象内存是连续的

优点：回收后可使用的内存都是连续的了，弥补了标记清除“大量不连续内存碎片”的缺点

缺点：标记过程效率不高

#### 复制算法

思想：将可用内存按容量分为大小相等的两块，每次只使用其中一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉

优点：实现简单，运行高效

缺点：占用一半内存，未免太高了一点，对象存活多的情况下，垃圾回收会变得频繁

### 垃圾收集的实现

#### 分代收集算法

#### 引用计数算法

#### 可达性分析算法

可达性分析算法基本思想是，通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，用图论的话来说，当从GCRoots到这个对象不可达时，这个对象即是可回收的

在Java语言中，可作为GCRoots的对象主要有
- 栈帧的局部变量表中引用的对象
- 方法区中类静态变量引用的对象
- 方法区中常量引用的对象、字符串常量池中引用的对象
- 被同步锁（synchronzied）持有的对象

TODO：STW、准确式GC、OopMap、安全点、并发三色标记、读写屏障、强软弱虚引用

### 垃圾收集器

### 理解GC日志

### 内存分配与回收策略

#### 对象优先在Eden区分配

大多数情况下，对象在新生代Eden区分配（如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，TLAB是从Eden区申请的内存）。而少数情况下，会直接分配在老年代，下文会提及

垃圾收集的时机（简单的理解）
- 当Eden区空间不足时，虚拟机将发起一次MinorGC
- 当老年代空间不足时，虚拟机将发起一次FullGC

两种GC方式
- 新生代GC（MinorGC）：指发生在新生代的垃圾收集动作，因为Java对象大多数都具备朝夕生灭的特性，所以MinorGC非常频繁，一般回收速度也比较快
- 老年代GC（MajorGC、FullGC）：指发生在老年代的GC，出现了MajorGC，经常会伴随至少一次的MinorGC（但非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）。MajorGC的速度一般会比MinorGC慢10倍以上

如果对象在Eden区出生并经过第一MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1

#### 长期存活的对象进入老年代

如果对象在Eden区出生并经过第一MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1

当对象的年龄增加到一定程度（默认是15岁），就会被晋升到老年代中，这是最自然地进入老年代的一种方式

可以通过参数-XX:MaxTenuringThreshold设置

TODO：具体例子

#### 动态年龄判断

虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄

分解一下上面的话
- Survivor空间中存在一些对象，这些对象都是同一个年龄，称为年龄A
- 年龄A的所有对象内存大小总和超过了一个Survivor区的一半
- 年龄大于或等于年龄A的对象可以直接进入老年代

TODO：具体例子

#### 大对象直接进入老年代

所谓大对象，是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组

大对象对虚拟机内存分配来说就是一个坏消息，而更坏的是，遇到一群“朝生夕灭”的“短命大对象”，写程序时应当避免

虚拟机提供了一个参数-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法）

TODO：具体例子

#### 空间分配担保

新生代MinorGC时，从Eden区到Survivor区，但若Survivor区不够放，会考虑放入老年代，这就是空间担保

考虑进入老年代是有条件的：在发生MinorGC前，虚拟机先检查老年代最大可用的连续内存是否大于新生代所有对象总空间，如果这个条件成立，那么MinorGC可以确保是安全的，如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败（没错，是失败），如果允许，那么会继续检查老年代最大可用连续内存是否大于历次晋升到老年代对象的平均大小，如果大于将尝试着进行一次MinorGC，尽管这次MinorGC是有风险的，如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次FullGC

取平均值进行比较其实仍然是一种动态概率的手段，如果进行了MinorGC单空间担保失败了话，只好进行一次FullGC，但一般情况下，HandlePromotionFailure开关还是会打开，避免FullGC过于频繁（FullGC的效率是MinorGC的10倍以上）

TODO：具体例子

#### 栈上分配策略

创建对象，除了在堆上分配内存外，还可能在栈上直接分配内存，称为栈上分配（Stack Allocation）

来看下面的例子

```java
package com.luban.ziya.runengine;

public class StackAlloc {

    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        long start = System.currentTimeMillis();

        for (int i = 0; i < 1000000; i++) {
            alloc();
        }

        long end = System.currentTimeMillis();

        System.out.println((end - start) + " ms");

        while (true);
    }

    public static void alloc() {
        StackAlloc obj = new StackAlloc();
    }
}
```

在不发生GC（垃圾回收）的条件下，生成了一个对象100万次，看堆区是不是有100万个，如果没有，就存在栈上分配

打开HSDB，用jps找到进程ID，attach进去，点击Tools > Object Histogram，可以得到如下结果

默认情况下的执行结果，可以发现没有100万个com.luban.ziya.runengine.StackAlloc，说明栈上分配是存在的

![image](https://user-images.githubusercontent.com/10209135/90543418-4240da80-e1b8-11ea-8b08-21100b04e140.png)

将逃逸分析给关掉，VM options中加一行：-XX:-DoEscapeAnalysis，可以发现有100万个，说明关掉逃逸分析后，栈上分配就关闭了

![image](https://user-images.githubusercontent.com/10209135/90544294-884a6e00-e1b9-11ea-8783-b69183b5d3e1.png)
