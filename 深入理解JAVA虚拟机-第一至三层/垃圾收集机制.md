- [垃圾收集机制](#垃圾收集机制)
  - [垃圾收集思想](#垃圾收集思想)
  - [理解GC日志](#理解GC日志)
  - [垃圾可收集判断](#垃圾可收集判断)
    - [引用计数算法](#引用计数算法)
    - [可达性分析算法](#可达性分析算法)
    - [GCRoots例子分析](#GCRoots例子分析)
    - [三色标记与读写屏障](#三色标记与读写屏障)
    - [强软弱虚引用](#强软弱虚引用)
  - [垃圾收集算法](#垃圾收集算法)
    - [分代收集算法](#分代收集算法)
    - [标记清除算法](#标记清除算法)
    - [标记整理算法](#标记整理算法)
    - [复制算法](#复制算法)
  - [垃圾收集器](#垃圾收集器)
  - [堆上内存管理](#堆上内存管理)
    - [新生代的内存管理](#新生代的内存管理)
    - [老年代的内存管理](#老年代的内存管理)
      - [长期存活的对象](#长期存活的对象)
      - [动态年龄判断](#动态年龄判断)
      - [大对象直接进入](#大对象直接进入)
      - [空间分配担保](#空间分配担保)
  - [栈上内存管理](#栈上内存管理)
    - [栈帧与线程](#栈帧与线程)
    - [栈上分配](#栈上分配)
    - [逃逸分析与标量替换](#逃逸分析与标量替换)
  - [Golang中的垃圾收集]

# 垃圾收集机制

> 本章核心：以实际代码例子及垃圾收集器的GC日志，带入理解垃圾收集算法原理

> 垃圾收集机制是面试时的重点考点，这一块的问题需要着重分析与理解

> 对于算法部分，定一个小要求：若需要的话，自己用ProcessOn画算法原理图，以此来理解

### 垃圾收集思想

JVM内存区域中的五个区域，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，内存自然跟着回收了，相对来说在编译期也可知晓有多少内存需要分配

然而Java堆和方法区则不一样，这部分内存分配和回收都是动态的，对象的垃圾收集重点关注这两个区域

讨论垃圾收集，需要从几个思路来谈
- 垃圾可收集判断：如何判断对象是垃圾，可以进行回收
- 垃圾收集算法：如何对垃圾进行回收（不影响程序正常进行）
- 垃圾收集器如何使用垃圾收集算法
- 运行时数据区域的内存管理

### 理解GC日志

TODO

### 垃圾可收集判断

如何判断对象是垃圾，可以进行回收，有两种主流算法：引用计数算法、可达性分析算法

#### 引用计数算法

引用计数算法实现简单，判定效率也高，也有许多著名例子，但它的缺点是很难解决对象之间相互循环引用问题

TODO

#### 可达性分析算法

可达性分析算法基本思想是，通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，用图论的话来说，当从GCRoots到这个对象不可达时，这个对象即是可回收的

在Java语言中，可作为GCRoots的对象有
- 虚拟机栈（栈帧中的局部变量表）中引用的对象
- 类静态属性引用的对象，比如Java类的引用类型静态变量
- 常量引用的对象，比如字符串常量池（StringTable）里的引用
- 本地方法栈中JNI（即一般说的native方法）引用的对象
- Java虚拟机内部的引用，比如数据类型的Class对象，一些常驻的异常对象（NullPointException、OutOfMemoryError等），还有系统类加载器
- 所有被同步锁（synchronzied）持有的对象

#### GCRoots例子分析

TODO

#### 三色标记与读写屏障

TODO

#### 强软弱虚引用

可以看到，两种对象已死判断算法，都是与“引用”有关，在JDK1.2之后，Java对引用的概念进行了扩充
- 强引用（Strong Reference）：程序中普遍存在的，类似"Object obj = new Object()"这种，只有强引用还在，垃圾收集器永远不会回收掉被引用的对象
- 软引用（Soft Reference）：描述一些还有用但不是必须的对象。JVM在将要发生内存溢出异常之前，会先把软引用列进回收范围进行第二次回收，如果依然还没有足够的内存，才会抛出内存溢出异常
- 弱引用（Weak Refernce）：也是描述非必须的对象，但强度比软引用还更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉值被弱引用关联的对象
- 虚引用（Phantom Reference）：最弱的一种引用关系，一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知

TODO

### 垃圾收集算法

#### 分代收集算法

分代收集算法，是根据内存区域来使用不同的算法

新生代使用复制算法，但不是1:1，而是Eden:From:To=8:1:1，若From或To区内存不够了，则空间担保到老年代

老年代使用标记整理或标记清除算法

#### 标记清除算法

思想：标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程用到引用计数算法、可达性分析算法，还有并发三色标记（标记清除算法是最基础的算法，后续的收集算法都是基于标记清除算法而改进的）

缺点：一，标记和清除效率都低，二，大量不连续的内存碎片，可能由于内存不够导致频繁垃圾回收

#### 标记整理算法

思想：与标记清除类似，标记过程不变，但整理过程是将所有对象移向一端，回收后存活的对象内存是连续的

优点：回收后可使用的内存都是连续的了，弥补了标记清除“大量不连续内存碎片”的缺点

缺点：标记过程效率不高

#### 复制算法

思想：将可用内存按容量分为大小相等的两块，每次只使用其中一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉

优点：实现简单，运行高效

缺点：占用一半内存，未免太高了一点，对象存活多的情况下，垃圾回收会变得频繁

### 垃圾收集器

TODO

### 堆上内存管理

堆是对象创建、回收的主要区域... TODO

对象的内存分配，从区域上看，有两种，一是堆上分配（这是最常见的），二是栈上分配（JIT编译后被拆散为标量类型并栈上分配）

#### 新生代的内存管理

大多数情况下，对象在新生代Eden区分配（如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，TLAB是从Eden区申请的内存）。而少数情况下，会直接分配在老年代，下文会提及

垃圾收集的时机（简单的理解）
- 当Eden区空间不足时，虚拟机将发起一次MinorGC
- 当老年代空间不足时，虚拟机将发起一次FullGC

两种GC方式
- 新生代GC（MinorGC）：指发生在新生代的垃圾收集动作，因为Java对象大多数都具备朝夕生灭的特性，所以MinorGC非常频繁，一般回收速度也比较快
- 老年代GC（MajorGC、FullGC）：指发生在老年代的GC，出现了MajorGC，经常会伴随至少一次的MinorGC（但非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）。MajorGC的速度一般会比MinorGC慢10倍以上

如果对象在Eden区出生并经过第一MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1

#### 老年代的内存管理

TODO：老年代采用标记清除、标记整理算法

对象进入老年代有四种情况：长期存活的对象、大对象直接进入、空间分配担保、动态年龄判断

##### 长期存活的对象

如果对象在Eden区出生并经过第一MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1

当对象的年龄增加到一定程度（默认是15岁），就会被晋升到老年代中，这是最自然地进入老年代的一种方式

可以通过参数-XX:MaxTenuringThreshold设置

TODO：具体例子

##### 动态年龄判断

虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄

分解一下上面的话
- Survivor空间中存在一些对象，这些对象都是同一个年龄，称为年龄A
- 年龄A的所有对象内存大小总和超过了一个Survivor区的一半
- 年龄大于或等于年龄A的对象可以直接进入老年代

TODO：具体例子

##### 大对象直接进入

所谓大对象，是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组

大对象对虚拟机内存分配来说就是一个坏消息，而更坏的是，遇到一群“朝生夕灭”的“短命大对象”，写程序时应当避免

虚拟机提供了一个参数-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法）

TODO：具体例子

##### 空间分配担保

新生代MinorGC时，从Eden区到Survivor区，但若Survivor区不够放，会考虑放入老年代，这就是空间担保

考虑进入老年代是有条件的：在发生MinorGC前，虚拟机先检查老年代最大可用的连续内存是否大于新生代所有对象总空间，如果这个条件成立，那么MinorGC可以确保是安全的，如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败（没错，是失败），如果允许，那么会继续检查老年代最大可用连续内存是否大于历次晋升到老年代对象的平均大小，如果大于将尝试着进行一次MinorGC，尽管这次MinorGC是有风险的，如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次FullGC

取平均值进行比较其实仍然是一种动态概率的手段，如果进行了MinorGC单空间担保失败了话，只好进行一次FullGC，但一般情况下，HandlePromotionFailure开关还是会打开，避免FullGC过于频繁（FullGC的效率是MinorGC的10倍以上）

TODO：具体例子

### 栈上内存管理

TODO：栈帧的回收、栈上创建对象

#### 栈帧与线程

#### 栈上分配

创建对象，除了在堆上分配内存外，还可能在栈上直接分配内存，栈上分配（Stack Allocation）与逃逸分析（Escape Analysis）、标量替换（Scalar Replacement）有关系

来看下面的例子

```java
package com.luban.ziya.runengine;

public class StackAlloc {

    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        long start = System.currentTimeMillis();

        for (int i = 0; i < 1000000; i++) {
            alloc();
        }

        long end = System.currentTimeMillis();

        System.out.println((end - start) + " ms");

        while (true);
    }

    public static void alloc() {
        StackAlloc obj = new StackAlloc();
    }
}
```

在不发生GC（垃圾回收）的条件下，生成了一个对象100万次，看堆区是不是有100万个，如果没有，就存在栈上分配

打开HSDB，用jps找到进程ID，attach进去，点击Tools > Object Histogram，可以得到如下结果

默认情况下的执行结果，可以发现没有100万个com.luban.ziya.runengine.StackAlloc，说明栈上分配是存在的

![image](https://user-images.githubusercontent.com/10209135/90543418-4240da80-e1b8-11ea-8b08-21100b04e140.png)

将逃逸分析给关掉，VM options中加一行：-XX:-DoEscapeAnalysis，可以发现有100万个，说明关掉逃逸分析后，栈上分配就关闭了

![image](https://user-images.githubusercontent.com/10209135/90544294-884a6e00-e1b9-11ea-8783-b69183b5d3e1.png)

#### 逃逸分析与标量替换

逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的技术，它的基本行为是分析对象动态作用域

当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸；甚至还有可能被外部线程访问到，比如赋值给类变量或者可以在其他线程中访问的实例变量，称为线程逃逸

如果能证明一个对象不会逃逸到方法或线程外，也就是别的方法或线程无法通过任何途径访问到这个对象，那就可以做一些优化，比如：栈上分配、同步消除、标量替换

栈上分配（Stack Allocation）：如果确定一个对象不会逃逸出方法之外，那让这个对象的栈上分配内存将会是一个很不错的注意，对象所占用的空间就可以随栈帧出栈而销毁

标量替换（Scalar Replacement）：标量是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中原始数据类型（int、long、reference等）都不能再进一步分解，它们就可以称为标量，相对的，如果一个数据可以再继续分解，则可以称为聚合量。Java中最典型的聚合量是对象，如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候，将可能不创建这个对象，而改为直接创建它若干个被这个方法使用到的成员变量来代替

要说明的是，逃逸分析在目前主要虚拟机中都还处于比较初级的阶段，不成熟的原因主要是不能保证逃逸分析的性能收益必定高于它的消耗。试想，如果逃逸分析需要耗时比较久，最后发现存在逃逸，不能栈上分配、标量替换，那岂不是得不偿失，还不如直接创建对象了。目前Hotspot中只能采用不那么准确，但时间压力相对较小的算法来完成逃逸分析。相信在未来的时候，逃逸分析技术肯定会撑起一系列使用有效的优化技术
