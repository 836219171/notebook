- [对象的生命周期](#对象的生命周期)
  - [对象的创建过程](#对象的创建过程)
    - [类加载检查](#类加载检查)
    - [内存分配](#内存分配)
      - [指针碰撞](#指针碰撞)
      - [空闲列表](#空闲列表)
      - [TLAB技术](#TLAB技术)
    - [初始化零值](#初始化零值)
    - [设置对象头](#设置对象头)
    - [执行init方法](#执行init方法)
  - [对象的内存布局](#对象的内存布局)
    - [对象头](#对象头)
      - [MarkWord](#MarkWord)
      - [类型指针](#类型指针)
    - [实例数据](#实例数据)
    - [对齐填充](#对齐填充)
    - [计算对象大小](#计算对象大小)
    - [指针压缩](#指针压缩)
  - [对象的访问定位](#对象的访问定位)
    - [句柄访问](#句柄访问)
    - [直接指针](#直接指针)
  - [对象的垃圾收集](#对象的垃圾收集)
    - [对象已死判断](#对象已死判断)
    - [垃圾收集算法](#垃圾收集算法)
  - [堆上分配策略](#堆上分配策略)
    - [优先创建在Eden区](#优先创建在Eden区)
    - [Eden区到Survivor区](#Eden区到Survivor区)
    - [新生代到老年代](#新生代到老年代)
      - [长期存活的对象](#长期存活的对象)
      - [大对象直接进入](#大对象直接进入)
      - [空间分配担保](#空间分配担保)
      - [动态年龄判断](#动态年龄判断)
  - [栈上分配策略](#栈上分配策略)
    - [逃逸分析](#逃逸分析)

# 对象的生命周期

> 对象是Java程序员非常熟悉的东西之一，因为许多Java程序员都渴望有一个对象，哦不，跑题了...

> 对象主要是分配在堆区，它的生命周期有好几个过程：对象的创建过程，对象的访问定位，对象的垃圾收集。除此外，还涉及到了对象的内存布局、堆上分配策略、栈上分配策略

> 可以看出来，本章与 第3章运行时数据区域 以及 第6章垃圾收集机制 息息相关，对象的创建和访问定位都关联于 方法区、堆区、栈 三块区域，对象的垃圾收集尤其关联堆区。所以本章的核心不仅仅是一章，而是更深层的概念------与第3章及第6章一起关联理解

### 对象的创建过程

JAVA中创建对象有 创建普通类对象（对应字节码new）、创建数组类对象（对应字节码newarray、anewarray、multianewarray）、创建Class对象（类加载后虚拟机内部自动完成），本文主要讨论的是创建普通类对象，不涉及后面两种

#### 字节码指令new

代码
```java
public static void main(String[] args) {
    Test test = new Test();
}
```

对应字节码
```
 0 new #3 <com/qimingnan/adjust/Test>
 3 dup
 4 invokespecial #4 <com/qimingnan/adjust/Test.<init>>
 7 astore_1
```

解释
- new Test：1.在堆区生成一个对象，注意，这时候的对象只是一个空壳子；2.将对象的引用压入栈顶
- dup：1.复制栈顶元素，即复制对象的引用；2.将复制的对象引入压入栈顶
  - 为什么要执行dup。因为下一步要执行默认构造方法，执行默认构造方法需要用到this指针，这个复制压入栈的值就是为了这个目的。
- invokespecial init：执行该类的默认构造方法，这时候这个对象才是一个完整的对象
- astore_1：1.pop出栈顶元素，即完整对象的指针；2.将完整对象的指针赋值给局部变量表中index=1位置的元素，即变量test

由此可以看出，new字节码并不是原子操作，new在Java代码层面虽然只是一句代码，但是反映到字节码层面，是四句代码，如果反映到openjdk源码层面，是更多行代码，所以肯定不是原子操作

#### 字节码解释器与new

下面的代码是Hotpot中字节码解释器处理new字节码的逻辑，虽然目前主流的都是模板解释器（如果有即时编译那差异就更大了），但是用于解释new字节码的执行逻辑是没问题的

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L2161

```cpp
...
CASE(_new): {
    /*
        获取目标类在运行时常量池中的索引
        class文件中是这样的：bb 00 04
        
        pc + 1即越过new指令占用的硬编码0xbb
    */
    u2 index = Bytes::get_Java_u2(pc+1);
    // 获取正在执行的方法所属类的常量池
    ConstantPool* constants = istate->method()->constants();
    // 判断目标类是否已被解析，如已解析，进入if段
    if (!constants->tag_at(index).is_unresolved_klass()) {
      // Make sure klass is initialized and doesn't have a finalizer
      // 判断从常量池中获取的klass指针是否是InstanceKlass类型
      Klass* entry = constants->slot_at(index).get_klass();
      assert(entry->is_klass(), "Should be resolved klass");
      Klass* k_entry = (Klass*) entry;
      assert(k_entry->oop_is_instance(), "Should be InstanceKlass");
      InstanceKlass* ik = (InstanceKlass*) k_entry;
      // 1、判断目标类是否已完成初始化
      // 2、判断目标类能否使用快速分配方式创建
      if ( ik->is_initialized() && ik->can_be_fastpath_allocated() ) {
        // 获取基于目标类生成的对象的大小  
        size_t obj_size = ik->size_helper();
        oop result = NULL;
        // If the TLAB isn't pre-zeroed then we'll have to do it
        bool need_zero = !ZeroTLAB;
        // 判断是否启用TLAB
        if (UseTLAB) {
          // 在线程的TLAB上分配内存  
          result = (oop) THREAD->tlab().allocate(obj_size);
        }
        // 如果result = null，说明在TLAB上分配内存失败
        if (result == NULL) {
          need_zero = true;
          // Try allocate in shared eden
          // 指针碰撞在堆区分配内存（其实就是循环执行CAS）
    retry:
          HeapWord* compare_to = *Universe::heap()->top_addr();
          HeapWord* new_top = compare_to + obj_size;
          if (new_top <= *Universe::heap()->end_addr()) {
            if (Atomic::cmpxchg_ptr(new_top, Universe::heap()->top_addr(), compare_to) != compare_to) {
              goto retry;
            }
            result = (oop) compare_to;
          }
        }
        // 如果在堆区分配内存成功
        if (result != NULL) {
          // Initialize object (if nonzero size and need) and then the header
          if (need_zero ) {
            // 除对象头外的内存清零  
            HeapWord* to_zero = (HeapWord*) result + sizeof(oopDesc) / oopSize;
            obj_size -= sizeof(oopDesc) / oopSize;
            if (obj_size > 0 ) {
              memset(to_zero, 0, obj_size * HeapWordSize);
            }
          }
          // 向对象头区域设置偏向锁
          if (UseBiasedLocking) {
            result->set_mark(ik->prototype_header());
          } else {
            result->set_mark(markOopDesc::prototype());
          }
          // 对齐填充
          result->set_klass_gap(0);
          // 设置对象的klass pointer
          result->set_klass(k_entry);
          // 对象入栈
          SET_STACK_OBJECT(result, 0);
          // 更新程序计数器
          UPDATE_PC_AND_TOS_AND_CONTINUE(3, 1);
        }
      }
    }
    // Slow case allocation
    // 慢速分配
    CALL_VM(InterpreterRuntime::_new(THREAD, METHOD->constants(), index),
            handle_exception);
    SET_STACK_OBJECT(THREAD->vm_result(), 0);
    THREAD->set_vm_result(NULL);
    UPDATE_PC_AND_TOS_AND_CONTINUE(3, 1);
  }
...
```

参考：[启明南：没对象?那就new一个](https://mp.weixin.qq.com/s/2nHGg5zq4xzD41j06kL7qw)

可以看出，大致逻辑如下
- 根据new后面的操作数获取到目标类的运行时常量池
- 判断目标类是否完成了解析，如果已被解析，走快速分配逻辑，如果没有，走慢速分配
- 继续判断目标类是否完成了初始化并满足快速分配条件，走快速分配，否则走慢速分配
- 如果启用了TLAB，先在TLAB上分配内存
- 如果在TLAB上分配失败，通过指针碰撞的方式去堆上分配，分配到内存就清零对象头之外的区域
- 设置偏向锁、对齐填充、类型指针、压入栈、重置重新计数器...

这里的概念很多，重点选择5个过程记录为new一个对象的过程，分别是 1.类加载检查（new会触发类加载）；2.内存分配（指针碰撞、空闲列表、TLAB技术）；3.初始化零值；4.设置对象头；5.执行init方法（对象完全创建）。可以看得出来，重点是内存分配，但这5个过程需要牢记

#### 类加载检查

在类加载机制中记录过，类加载有四种情况
- main函数所在类会被加载
- 遇到new、getstatic、putstatic、invokestatic 4个字节码会类加载（没有 newarray、anewarray、multianewarray）
- 反射调用会类加载
- 加载一个类，优先加载父类

new字节码执行之前，会检查类加载，若加载了，走快速分配逻辑，若没有加载，走慢速分配逻辑，慢速分配中应该会执行类加载

```cpp
    // 判断目标类是否已被解析，如已解析，进入if段
    if (!constants->tag_at(index).is_unresolved_klass()) {
    ...
    }
    // Slow case allocation
    // 慢速分配
    CALL_VM(InterpreterRuntime::_new(THREAD, METHOD->constants(), index),
            handle_exception);
    SET_STACK_OBJECT(THREAD->vm_result(), 0);
    THREAD->set_vm_result(NULL);
    UPDATE_PC_AND_TOS_AND_CONTINUE(3, 1);
```

#### 内存分配

内存分配是创建对象过程的重点

在类加载完成后，一个类的对象需要分配多少内存就已经确定了的，从代码中可以看出来，new字节码执行中，对象的大小（obj_size）是从类的元信息（InstanceKlass）中获取的
```
CASE(_new): {
...
    InstanceKlass* ik = (InstanceKlass*) k_entry;
    ...
    // 获取基于目标类生成的对象的大小  
    size_t obj_size = ik->size_helper();
...
```

那么分配内存有两种主流的策略：指针碰撞、空闲列表。这两种策略能保证并发环境下分配内存的原子性

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定

此外，还有更高效的分配内存策略，即TLAB技术

##### 指针碰撞

指针压缩只能用于内存规整的环境中，即一边是已使用的内存，一边是未使用的内存，交界处即为碰撞处，名曰分界点的指示器

具体过程：将指示器向未使用内存这边移动一段对象大小的距离，底层是通过CAS循环碰撞，CAS执行成功即碰撞成功，成功分配到内存

可以发现这种方式的核心是前期使用内存的约束要做好，因为不需要借助其他数据结构辅助实现，所以保证了分配内存的高效性

![image](https://user-images.githubusercontent.com/10209135/96273016-6f1b3d80-1001-11eb-9eb2-c5d6cd35ecc8.png)

JVM分配内存的方式就是指针碰撞（至少字节码解释器是这样），因为新生代采用的是分代-复制算法，所以堆内存是规整的

```
...
    // 指针碰撞在堆区分配内存（其实就是循环执行CAS）
    retry:
          HeapWord* compare_to = *Universe::heap()->top_addr();
          HeapWord* new_top = compare_to + obj_size;
          if (new_top <= *Universe::heap()->end_addr()) {
            if (Atomic::cmpxchg_ptr(new_top, Universe::heap()->top_addr(), compare_to) != compare_to) {
              goto retry;
            }
            result = (oop) compare_to;
          }
...
```

##### 空闲列表

如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，这时候会用空闲列表

空闲列表是借助两个数据结构，一个记录所有已使用的内存，一个记录所有可用的内存，当需要分配内存的时候，去查可用的内存列表，拿到一块

这种内存分配策略被称为万能方案，window底层就是通过这种方式来管理内存的

来一段代码帮助理解（并不清楚哪里来的）
```cpp
class MemoryChunk {

private:
    list<MemoryCell *> m_available_table;
    list<MemoryCell *> m_used_table;

    /**
     * 整理内存时中转用，暂存打了标记的对象，对象移动后释放
     */
    list<MemoryCell *> m_transer_table;
...
```

##### TLAB技术

在堆上分配内存前，会先判断是否启用TLAB技术，若启用，优先在TLAB上分配，若失败才到堆上分配

```cpp
...
        // 判断是否启用TLAB
        if (UseTLAB) {
          // 在线程的TLAB上分配内存  
          result = (oop) THREAD->tlab().allocate(obj_size);
        }
        // 如果result = null，说明在TLAB上分配内存失败
        if (result == NULL) {
...
```

TLAB是线程的一块私有内存（从Eden区申请的），即这块buffer只给当前线程使用。意思是，只有当前线程可以向这块内存写入数据，但是写入的数据依然是线程共享的，即TLAB只有当前线程可写，所有线程可读

TLAB的优势是，在多线程环境下申请内存就不存在竞争，直接在当前线程的buffer上分配即可（指针碰撞底层使用了CAS循环碰撞，空闲列表借助其他数据结构记录，为了保证原子性等，带来了额外的性能开销）

JDK6以后TLAB默认是开启的，可以通过参数-XX:+/-UseTLAB设置开启或关闭，建议开启。在TLAB分配内存过程中，存在一个步骤，判断TLAB的剩余空间是否大于且等于需要的内存大小，如果满足条件，则从TLAB中分到内存，如果不满足条件，则返回null

TLAB的数据结构（hotspot/src/share/vm/memory/threadLocalAllocBuffer.hpp）
```cpp
class ThreadLocalAllocBuffer: public CHeapObj<mtThread> {
  friend class VMStructs;
private:
  HeapWord* _start;                              // address of TLAB
  HeapWord* _top;                                // address after last allocation
  HeapWord* _pf_top;                             // allocation prefetch watermark
  HeapWord* _end;                                // allocation end (excluding alignment_reserve)
  size_t    _desired_size;                       // desired size   (including alignment_reserve)
  size_t    _refill_waste_limit;                 // hold onto tlab if free() is larger than this
  size_t    _allocated_before_last_gc;           // total bytes allocated up until the last gc

  static size_t   _max_size;                     // maximum size of any TLAB
  static unsigned _target_refills;               // expected number of refills between GCs

  unsigned  _number_of_refills;
  unsigned  _fast_refill_waste;
  unsigned  _slow_refill_waste;
  unsigned  _gc_waste;
  unsigned  _slow_allocations;

  AdaptiveWeightedAverage _allocation_fraction;  // fraction of eden allocated in tlabs
...
```

下面贴出的是jdk8环境下，TLAB相关的参数及默认值，前面加上-XX就是调优参数。这些参数在openjdk关于TLAB的源码中都能看到身影

|参数|默认值|功能|
|--|--|--|
|FastTLABRefill|true|是否启用快速填充TLAB，调优参数：-XX:-FastTLABRefill|
|MinTLABSize|2048|TLAB最小值，即2K，调优参数：-XX:MinTLABSize=|
|PrintTLAB|false|打印TLAB信息，调优参数：-XX:+/-PrintTLAB|
|ResizeTLAB|true|是否自动调整TLABRefillWasteFraction阈值，调优参数：-XX:+/-ResizeTLAB|
|TLABAllocationWeight|35|控制平均值平均多快忘掉旧值（了解即可）|
|TLABRefillWasteFraction|64|能进入TLAB的单个对象大小，默认为64，如果对象大小大于等于TLAB空间的1/64，即直接在堆区分配，如果对象大小小于TLAB的1/64，则在TLAB上分配|
|TLABSize|0|设置TLAB的大小|建议：不要手动设置，采用默认值，调优参数：-XX:TLABSize|
|TLABStats|true|TLAB状态（了解即可）|
|TLABWasteIncrement|4|动态的增加浪费空间的字节数（了解即可）|
|TLABWasteTargetPercent|1|TLAB占用Eden区的百分比，调优参数：-XX:TLABWasteTargetPercent|
|UseTLAB|true|开启或关闭TLAB，调优参数：-XX:+/-UseTLAB|
|ZeroTLAB|false|是否清零TLAB区域，调优参数：-XX:+/-ZeroTLAB

#### 初始化零值

#### 设置对象头

#### 执行init方法

### 对象的内存布局
#### 对象头
##### MarkWord
##### 类型指针
#### 实例数据
#### 对齐填充
#### 计算对象大小
#### 指针压缩

### 对象的访问定位
#### 句柄访问
#### 直接指针

### 对象的垃圾收集
#### 对象已死判断
#### 垃圾收集算法

#### 堆上分配策略
#### 优先创建在Eden区
#### Eden区到Survivor区
#### 新生代到老年代
##### 长期存活的对象
##### 大对象直接进入
##### 空间分配担保
##### 动态年龄判断

### 栈上分配策略
#### 逃逸分析
