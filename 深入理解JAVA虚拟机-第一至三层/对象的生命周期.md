- [对象的生命周期](#对象的生命周期)

# 对象的生命周期

> 对象是Java程序员非常熟悉的东西之一，因为许多Java程序员都渴望有一个对象，哦不，跑题了...

> 对象主要是分配在堆区，它的生命周期有好几个过程：对象的创建，对象的访问定位，对象的垃圾收集。除此外，还涉及到了对象的内存布局，栈上分配和逃逸分析（新分配对象方式）等

> 可以看出来，本章与 第3章JVM内存之运行时数据区域 以及 第6章垃圾收集机制实战 息息相关，对象的创建和访问定位都关联于 方法区、堆区、栈 三块区域，对象的垃圾收集尤其关联堆区。所以本章的核心不仅仅是一章，而是更深层的概念------与第3章及第6章一起关联理解

> 这一章是是第6章的理论基础铺垫，重理论分析，不进行实战演练，具体的垃圾收集机制实战、GC日志分析、新生代到老年代实战等，将在第6章讲解

### 对象的创建

检查类加载、对象内存分配、初始化零值、对象头设置、执行init方法

### 对象的内存布局

计算对象大小、指针压缩

### 对象的访问定位

句柄访问、直接指针

### 垃圾收集策略

#### 优先创建在Eden区

大多数情况下，对象在新生代的Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC

提一下MinorGC、FullGC

#### Eden区到Survivor区

策略、空间担保

#### 新生代到老年代

##### 长期存活的对象

如果对象在Eden区出生并经过第一次MinorGC后仍然能存活，并且能被Survivor容纳的话，将被移动到Survivor区中，并且对象年龄设为1

对象在Survivor区每“熬过”一次MinorGC，年龄就增加1，直到15岁后（默认），就会晋升到老年代中

可以通过参数 -XX:MaxTenuringThreshold=A 来设置晋升年龄为A，不设置则A默认是15

HotSpot实现，JDK8版本中，由于分代年龄占4个bit，因此MaxTenuringThreshold只能设置为0到15，测试过JDK6和JDK7无此限制

##### 大对象直接进入老年代

大对象是指需要连续内存空间的Java对象，典型的是很长的字符串及数组，比如 byte[] a = new byte[VERY_LONG];

可以通过参数 -XX:PretenureSizeThreshold 来设置，对象大小超过该值则直接在老年代分配

注意：PretenureSizeThreshold参数只能设置字节，比如3145728，不能写形如3M这样的简写

> 比遇到一个大对象更加坏的消息是，遇到一群朝生夕灭的短命大对象，写程序的时候应当避免

> 据子牙老师说，默认情况下，对象大小超过50%Eden区内存大小，就会进入老年代，但我没测试出来

> PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，也不需要设置，如果遇到必须要使用该参数的场合，可以考虑ParNew加CMS的收集器组合

##### 空间分配担保

TODO

##### 动态对象年龄判断

TODO

### 垃圾收集算法

提一下对象已死判断算法、垃圾收集算法，不具体展开
