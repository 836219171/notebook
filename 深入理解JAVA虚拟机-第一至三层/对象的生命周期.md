- [对象的生命周期](#对象的生命周期)

# 对象的生命周期

> 对象是Java程序员非常熟悉的东西之一，因为许多Java程序员都渴望有一个对象，哦不，跑题了...

> 对象主要是分配在堆区，它的生命周期有好几个过程：对象的创建（分配内存、初始化零值、设置对象头、执行init方法、引用指向），对象的访问定位（句柄访问、直接指针），对象的垃圾收集（对象已死判断、垃圾收集策略、垃圾收集算法）。除此外，还涉及到了对象的内存布局（对象头、实例数据、对齐填充），栈上分配和逃逸分析（新分配对象方式）等

> 可以看出来，本章与 第3章JVM内存之运行时数据区域 以及 第6章垃圾收集算法与垃圾收集器 息息相关，对象的创建和访问定位都关联于 方法区、堆区、栈 三块区域，对象的垃圾收集尤其关联堆区。所以本章的核心不仅仅是一章，而是更深层的概念------与第3章及第6章一起关联理解

### 对象的创建

内存分配、实例化

### 对象的内存布局

指针压缩？

### 对象的访问定位

### 对象进入老年代

#### Eden区到Survivor区

优先创建在Eden区、Eden区到Survivor区

#### 新生代到老年代

##### 情况一-长期存活的对象将进入老年代

如果对象在Eden区出生并经过第一次MinorGC后仍然能存活，并且能被Survivor容纳的话，将被移动到Survivor区中，并且对象年龄设为1

对象在Survivor区每“熬过”一次MinorGC，年龄就增加1，直到15岁后（默认），就会晋升到老年代中

可以通过参数 -XX:MaxTenuringThreshold=A 来设置晋升年龄为A，不设置则A默认是15

HotSpot实现，JDK8版本中，由于分代年龄占4个bit，因此MaxTenuringThreshold只能设置为0到15，测试过JDK6和JDK7无此限制

##### 情况二-大对象直接进入老年代

大对象是指需要连续内存空间的Java对象，典型的是很长的字符串及数组，比如 byte[] a = new byte[VERY_LONG];

可以通过参数 -XX:PretenureSizeThreshold 来设置，对象大小超过该值则直接在老年代分配

注意：PretenureSizeThreshold参数只能设置字节，比如3145728，不能写形如3M这样的简写

> 比遇到一个大对象更加坏的消息是，遇到一群朝生夕灭的短命大对象，写程序的时候应当避免

> 据子牙老师说，默认情况下，对象大小超过50%Eden区内存大小，就会进入老年代，但我没测试出来

> PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，也不需要设置，如果遇到必须要使用该参数的场合，可以考虑ParNew加CMS的收集器组合

##### 情况三-空间分配担保

TODO

##### 情况四-动态对象年龄判断

TODO

### 对象的垃圾收集

TODO
