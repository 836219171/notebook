- [对象的生命周期](#对象的生命周期)
  - [对象的创建过程](#对象的创建过程)
    - [检查类加载](#检查类加载)
    - [内存分配](#内存分配)
    - [初始化零值](#初始化零值)
    - [设置对象头](#设置对象头)
    - [执行init方法](#执行init方法)
  - [对象的内存布局](#对象的内存布局)
    - [对象头](#对象头)
      - [MarkWord](#MarkWord)
      - [类型指针](#类型指针)
    - [实例数据](#实例数据)
    - [对齐填充](#对齐填充)
    - [计算对象大小](#计算对象大小)
    - [指针压缩](#指针压缩)
  - [对象的访问定位](#对象的访问定位)
    - [句柄访问](#句柄访问)
    - [直接指针](#直接指针)
  - [对象的垃圾收集](#对象的垃圾收集)
    - [对象已死判断](#对象已死判断)
    - [垃圾收集算法](#垃圾收集算法)
  - [堆上分配策略](#堆上分配策略)
    - [优先创建在Eden区](#优先创建在Eden区)
    - [Eden区到Survivor区](#Eden区到Survivor区)
    - [新生代到老年代](#新生代到老年代)
      - [长期存活的对象](#长期存活的对象)
      - [大对象直接进入](#大对象直接进入)
      - [空间分配担保](#空间分配担保)
      - [动态年龄判断](#动态年龄判断)
  - [栈上分配策略](#栈上分配策略)
    - [逃逸分析](#逃逸分析)

# 对象的生命周期

> 对象是Java程序员非常熟悉的东西之一，因为许多Java程序员都渴望有一个对象，哦不，跑题了...

> 对象主要是分配在堆区，它的生命周期有好几个过程：对象的创建过程，对象的访问定位，对象的垃圾收集。除此外，还涉及到了对象的内存布局、堆上分配策略、栈上分配策略

> 可以看出来，本章与 第3章运行时数据区域 以及 第6章垃圾收集机制 息息相关，对象的创建和访问定位都关联于 方法区、堆区、栈 三块区域，对象的垃圾收集尤其关联堆区。所以本章的核心不仅仅是一章，而是更深层的概念------与第3章及第6章一起关联理解

### 对象的创建过程

Hotpot中new字节码的执行逻辑

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp#L2161

```cpp
      // 字节码是new
      CASE(_new): {
        u2 index = Bytes::get_Java_u2(pc+1);
        ConstantPool* constants = istate->method()->constants();
        // 确保常量池中存放的是已解释的类
        if (!constants->tag_at(index).is_unresolved_klass()) {
          // 断言确保是klassOop和instanceKlassOop
          Klass* entry = constants->slot_at(index).get_klass();
          assert(entry->is_klass(), "Should be resolved klass");
          Klass* k_entry = (Klass*) entry;
          assert(k_entry->oop_is_instance(), "Should be InstanceKlass");
          InstanceKlass* ik = (InstanceKlass*) k_entry;
          // 确保对象所属类型已经经过初始化阶段
          if ( ik->is_initialized() && ik->can_be_fastpath_allocated() ) {
            // 取对象长度
            size_t obj_size = ik->size_helper();
            oop result = NULL;
            // 记录是否需要将对象所有字段置零值
            bool need_zero = !ZeroTLAB;
            // 是否在TLAB中分配对象
            if (UseTLAB) {
              result = (oop) THREAD->tlab().allocate(obj_size);
            }
            // Disable non-TLAB-based fast-path, because profiling requires that all
            // allocations go through InterpreterRuntime::_new() if THREAD->tlab().allocate
            // returns NULL.
#ifndef CC_INTERP_PROFILE
            if (result == NULL) {
              need_zero = true;
              // 直接在eden中分配对象
            retry:
              HeapWord* compare_to = *Universe::heap()->top_addr();
              HeapWord* new_top = compare_to + obj_size;
              // cmpxchg是x86中的CAS指令，这里是一个C++方法，通过CAS方式分配空间，并发失败的话，转到retry中重试直至成功分配为止
              if (new_top <= *Universe::heap()->end_addr()) {
                if (Atomic::cmpxchg_ptr(new_top, Universe::heap()->top_addr(), compare_to) != compare_to) {
                  goto retry;
                }
                result = (oop) compare_to;
              }
            }
#endif
            if (result != NULL) {
              // 如果需要，为对象初始化零值
              if (need_zero ) {
                HeapWord* to_zero = (HeapWord*) result + sizeof(oopDesc) / oopSize;
                obj_size -= sizeof(oopDesc) / oopSize;
                if (obj_size > 0 ) {
                  memset(to_zero, 0, obj_size * HeapWordSize);
                }
              }
              // 根据是否启用偏向锁，设置对象头信息
              if (UseBiasedLocking) {
                result->set_mark(ik->prototype_header());
              } else {
                result->set_mark(markOopDesc::prototype());
              }
              result->set_klass_gap(0);
              result->set_klass(k_entry);
              OrderAccess::storestore();
              // 将对象引用入栈，继续执行下一条指令
              SET_STACK_OBJECT(result, 0);
              UPDATE_PC_AND_TOS_AND_CONTINUE(3, 1);
            }
          }
        }
```

#### 检查类加载
#### 内存分配
#### 初始化零值
#### 设置对象头
#### 执行init方法

### 对象的内存布局
#### 对象头
##### MarkWord
##### 类型指针
#### 实例数据
#### 对齐填充
#### 计算对象大小
#### 指针压缩

### 对象的访问定位
#### 句柄访问
#### 直接指针

### 对象的垃圾收集
#### 对象已死判断
#### 垃圾收集算法

#### 堆上分配策略
#### 优先创建在Eden区
#### Eden区到Survivor区
#### 新生代到老年代
##### 长期存活的对象
##### 大对象直接进入
##### 空间分配担保
##### 动态年龄判断

### 栈上分配策略
#### 逃逸分析
