# 深入理解JAVA虚拟机-第一至三层

### 前言

我希望写多篇文章，组合成一份文章集，包含关于JAVA虚拟机的入门原理、常见问题、代码例子证明等

读者阅读它，能像读小说一样，从第一篇文章，读到最后一篇文章，尽量把讳莫如深难懂的内容写得简单易懂，当然这也需要读者具有一定的JAVA功底

引用《深入理解JAVA虚拟机》第二版6.3节的话：力求在保证逻辑准确的前提下，用尽量通俗的语言和案例去讲述虚拟机中与开发关系最为密切的内容

### 声明

转载请注明出处：https://github.com/peteryuanpan/notebook/blob/master/深入理解JAVA虚拟机-第一至三层

作者：潘缘，来自电子科技大学，2017届

本文部分内容来自鲁班学院的课程，感谢老师们以及同学们对我的帮助

还有部分内容来自《深入理解JAVA虚拟机》第二版以及第三版，第二版是基于JDK7的，第三版是基于JDK8及以后的，本文内容是基于JDK8的（Hotspot实现），我会去对比第二版与第三版的差异点，并记录在文中

### JAVA虚拟机的定义

无论讨论什么，我们先需要将定义讨论清楚，否则就会有无穷的争执

JAVA虚拟机是一种能够运行JAVA字节码程序的虚拟机器

> A Java virtual machine (JVM) is a virtual machine that enables a computer to run Java programs as well as programs written in other languages that are also compiled to Java bytecode. From https://en.wikipedia.org/wiki/Java_virtual_machine.

### JAVA语言的水深

JAVA这潭大湖，从上往下，一共有7层（人为定义的）

- JAVA语法
- JAVA字节码
- JVM原理
- JVM源码
- 操作系统层
- 汇编码层
- 硬编码层

笔者的能力是有限的，望大家见谅，这篇文章能接触到的水深，只有第 1-3 层 + 第4层表面，第4层JVM源码往下，这篇文章不会深入包含

如果读者要问我为何第4层开始往下不深入包含了，我只能说，我也很无奈呀，实在能力有限，短时间内还做不到呐

### 关于第4层

第4层是JVM源码

在准备这份笔记同时，实际上是我在整理自己对JVM原理的理解

但是我发现，纯理论的理解，是有瓶颈的，你可以通过图表去加深理解，可以通过网上更多资料细节去巩固理解，但是你永远只是停留在理论上，没有实践

就好比，高中时上化学课，背元素周期表、化学反应方程式、基础化学分子的现象特征等，这些固然需要，但你希望深入理解化学，深入记忆，只停留在理论不足以的，一定需要实践，即做实验，这也是我国学生的一个普遍问题点------动手能力差

鲁班学院的子牙老师，有提供Ubuntu虚拟机环境的镜像，上面可以调试jvm，查看源码并理解，我做了个笔记，记录于：[Windows上用虚拟机运行Ubuntu环境并调试JVM](https://github.com/peteryuanpan/notebook/issues/89) ，这份笔记非常有用，但也只是个开始

综上，虽然这篇文章接触到的水深，只有第 1-3 层 + 第4层表面，但是我也会尽量的通过第 4 层，拿出源码例子，来帮助第 3 层加深理解

不深入包含第 4 层，含义是只是用源码例子来解释，但不会去深入分析，甚至去编写JVM源码的一部分code来理解。。做不到

我push了一份jvm源码到 https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror ，接下来分析、Debug都用它

### 如何学习JVM

两个方向：内存模型、字节码

学习方法
- 学习了一块知识点后，自己梳理成文章总结（这是重要的第一步，大概需要耗时几天）
- 然后自己将内容讲解出来，一遍一遍地过，直到能让人听明白为止（这是重要的第二步）
- 注意，写出来和说出来对于理解的提高是非常不一样的，先写再说，直到讲明白了，就通透了

### 文章导读

辗转反侧，改了很久，最终决定用多篇文章形式来输出，每一篇文章以一个markdown文档形式，大概就是下面你看到的目录章节，章节之间的顺序关系是有逻辑的，在顺序安排上我花了很大功夫，调整了又调整，包括截止目前还没完全定稿

说一下我的思路，我认为可以使用一张图来概括JAVA虚拟机运行时环境，并且从头到尾讲解虚拟机运行逻辑，细节问题再逐步探讨，这张图就是 [JAVA运行时环境逻辑图](类加载机制.md#JAVA运行时环境逻辑图) 

**第1章是类加载机制与类加载器**。本章作为首章节，这一点与《深入理解JAVA虚拟机》这本书逻辑不同，本书是业界经典，将类加载放到书中的第7章才讲，前面有 Java内存区域与内存溢出异常、垃圾收集器与内存分配策略、虚拟机性能监控与故障处理工具、调优案例分析与实战、类文件结构

我这么安排的理由是，请参考JAVA运行时环境逻辑图，可以看到，类加载是JAVA虚拟机运行逻辑的第一步，它对一个有一定基础的JAVA程序员来讲，是相对比较好理解的（相信完全没有JAVA基础的程序员，也不会看明白这篇文章内容，也不是我所考虑的读者群体）。有一定JAVA基础的程序员，他们一定用IDE运行过JAVA程序，了解什么是jar包，见过class文件，可能了解字节码，再深入一下，应该知晓JAVA底层是JVM，JVM主要是用C++来实现的，JAVA代码运行本质是虚拟机运行class文件，而读入class文件的字节流并写入内存区域，这就是类加载的过程，因此我放到第1章讲

类加载只是虚拟机运行的一部分，它关键阶段是将class文件字节流读入class content，解析成InstanceKlass（JAVA类在JVM中的存在形式）并写入内存区域的方法区中，同时生成对应的InstanceMirrorKlass（java.lang.Class在JVM中的存在形式）并写入堆区（JDK8及以后），此时就需要讲一讲JVM内存模型中的运行时数据区域了，这也是很多书籍、总结文章最先讲的一个部分，因此我放到第3章

**第2章是类文件结构与字节码指令**。本章是相对独立的一个章节，但它同时又是所有章节的底层基础。起初，我希望将本章放到第3章JVM运行时数据区后再讲解，但目前已确定放入第2章，因为其他章节中，往深入下去，一定会遇到类文件中常量池、字节码指令等概念，既然如此，我们不妨优先讲完类文件结构与字节码指令。如果对类文件结构、字节码指令比较熟悉的读者，或者希望先快速了解JVM运行时数据区概念的读者，可以先跳过本章，但不能完全忽略本章，一定要回头来看

本章将以一个ParseClassFile项目为例子，能实际解析Class文件，将其中的魔数、常量池、字段表集合、方法表集合等信息全部打印出来，深入理解类文件结构

同时，对字节码会进行分类，每个字节码举一个简单的例子来说明其作用、功能等

**第3章是JVM运行时数据区域**。JVM运行时数据区域是一个大的轮廓，它讲明白了JVM在操作系统内存中申请的一块内存有哪些部分，简单来说，包括程序计数器、虚拟机栈、本地方法栈、方法区、堆区，另外还有运行时常量池（属于方法区）、字符串常量池（属于堆区，JDK8及以后）

在JDK6、7、8中，方法区的实现发生了较大的变化，JDK6及之前使用的是永久代来实现方法区，JDK7开始将字符串常量池、静态变量等从方法区移到堆区，保留了类的元信息、运行时常量池等，到了JDK8，完全摒弃了永久代，改用元空间的方式来实现，用到了直接内存，将方法区剩余部分内容都移到了元空间中

堆区是垃圾收集器管理的主要区域，也称为GC堆，其包括新生代（Eden空间、From空间、To空间）和老年代，两个区域有不同的对象存放逻辑。关于垃圾回收策略将在第6章深入讲解

JVM内存模型中还有虚拟机栈、本地方法栈两个概念，它们描述了JAVA方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧，栈帧中有局部变量表、操作数栈、动态链接、方法返回地址（恢复现场）等信息，栈帧是虚拟机栈的基本元素，栈帧在虚拟机栈里面从入栈到出栈的过程，是由字节码执行引擎来完成的。关于栈帧将在第4章深入讲解

值得一提的是，本章是第4、5、6章的引导章节。之所以这么说，是因为本章是一个轮廓，它包含的5个区域都可以指向后续某一个章节，来做进一步的讲解。比如虚拟机栈和本地方法栈，指向字节码执行引擎；堆区内分配内存以及栈中的引用，指向对象的创建使用、字符串常量池；堆区中对象的垃圾回收，指向垃圾回收算法与垃圾回收器等

**第4章是字节码执行引擎与即时编译器**。字节码执行引擎输入的是字节码文件，输出的是执行结果，执行过程有解释执行（通过解释器执行）和编译执行（通过即使编译器产生本地代码执行）两种选择。这里面最关键的问题是，如何理解JAVA是一种半编译半解释的语言，把这个概念解释清楚即可了

解释执行的过程：JAVAC编译器将JAVA代码编译成class文件，交由解释器一行一行翻译执行；编译执行的过程：JAVAC编译器将JAVA代码编译成class文件，在运行时，即时编译器（JIT编译器，Just In Time Complier）将热点字节码编译成与本地平台相关的机器码，交由机器执行。除了JAVAC编译器、JIT编译器外，还有AOT编译器（Ahead OF Time Compiler），可以直接将JAVA代码编译成本地机器码

字节码执行引擎的执行模式有三种：第一种是interpreted mode，即纯解释执行模式（-Xint），这时编译器完全不介入；第二种是complied mode，即编译执行模式（-Xcomp），这时优先编译方式执行，但解释器仍然要在编译无法进行的情况下介入执行过程；第三种是miexd mode，即混合模式（-Xmixed），采用解释器与编译器搭配使用的方式执行。第三种混合模式是目前最主流的运行模式

即时编译是在运行期进行的，它的功能是将热点代码编译成与本地平台相关的机器码，并进行各种层次优化，作用是提高热点代码的运行效率。早期的JVM只有解释器，没有即时编译。HotSpot虚拟机中内置了两个即时编译器，分别称为C1编译器（Client Complier）和C2编译器（Server Compiler）。即时编译器是JVM不断优化的产物，它的性能好坏、代码优化程度的高低是衡量一款虚拟机优秀与否的最关键指标之一，也是虚拟机中最核心且最能体现技术水平的部分。理解即时编译器，就更能理解为何JAVA是一种半编译半解释的语言，因此在第3章中还包括了即时编译器

**第5章是对象的生命周期与字符串常量池**。本章是第3章运行时数据区域的延续，它具体的讲解了一个对象的生命周期，包括分配内存、实例化、内存布局、访问定位，回收策略等。本章还深入讲解了字符串常量池，以常用的字符串为例子，补充对堆区的认识。本章是最贴近普通JAVA业务代码的，编写一段JAVA代码，一定少不了对象的创建和使用，形如 A a = new A(); 的代码，一定经常出现，还有字符串处理，比如 String a = "1"; String b = new String("2"); String c = a + b; 还有运行时常量池、字符串常量池的概念等。是否有思考过，这些代码的底层逻辑是怎么样的？一个对象是创建在JVM运行时数据区域的什么地方？虚拟机栈中的对象，实际上只是个引用，它指向的是堆中的对象，那么堆中分配的对象有哪些？它们之间有什么关系？这些问题都很值得思考。理解了对象是什么，对象在虚拟机内存中是如何存储，它的创建和使用具体过程等，对于编写JAVA业务代码是有很大好处的

**第6章是垃圾收集算法与垃圾收集器**。我特意将本章放到后面，并不是认为这部分内容不重要，而是认为这部分内容相对独立。垃圾收集技术是JVM的亮点，它让一个项目开发，尤其是涉及到团队多人协作时，变的更简单容易。作为JAVA程序员，你不需要特别为内存泄漏而烦恼，但你需要了解垃圾回收策略、垃圾回收算法等。垃圾回收策略重点讲解，对象在新生代中的分配逻辑、大对象直接进入老年代、长期存活的对象进入老年代等，与第3章衔接。确定哪些对象可回收的算法有：引用计数算法、可达性分析算法。垃圾回收算法有：标记-清除算法、标记-整理算法、复制算法、分代收集算法。垃圾收集器有：Serial收集器、ParNew收集器、Parallel Scavenge收集器、CMS收集器、G1收集器

**第7章是JVM运维工具与调优案例分析**。本章是所有章节中，在实际项目中可应用性最高的了，因此也需要好好了解。JDK的命令行工具有：jps、jstat、jinfo、jmap、jhat、jstack、HSDIS，JDK的可视化工具有：JConsole、ViusalVM。我希望能结合实际的项目案例来讲解，熟悉这些工具如何使用的，理解使用这些工具的真正价值。此外，还有许多经典的调优案例分析，这些案例对实际项目有很大帮助，有些是刻骨铭心的

**第8章是JAVA多线程高并发**。本章是非常重要的一个章节，并发问题考验了一个程序员的功底深厚，我将本章独立出来，作为一个更大的课题（深入理解JAVA多线程高并发）来书写

**第9章JVM面试问题总结**。对于面试来说，本章是最重要的，而前8章是本章的基础理论。我会搜集网上出现频率高的，关于JVM的面试题，其中有一些开放性的概念问题，比如请讲述一下虚拟机类加载机制，JVM中垃圾回收算法有哪些；还有一些是具体的问题，比如给一段简短的程序，请问输出结果（在第1章 类加载笔试题统一解法 有总结），给几个String对象，进行赋值、new、相加等操作，请问a==b吗。这些问题我了解的还不够，需要继续深入。从某种程度上说，可以边写前面章节边写本章，它能够审视前面章节，哪些内容是面试重点，哪些内容只是理论但面试几乎不考（比如类文件结构可能）。前7章都是有条理有逻辑的对一系列知识点进行总结，而本章会从中拎出某个重点知识点，这能起到完善前面章节内容的作用

### 文章目录

#### 第1章：类加载机制与类加载器
- [类加载机制](类加载机制.md)
  - [类的定义](类加载机制.md#类的定义)
  - [类加载的定义](类加载机制.md#类加载的定义)
  - [类加载的输入和输出结果](类加载机制.md#类加载的输入和输出结果)
  - [JAVA运行时环境逻辑图](类加载机制.md#JAVA运行时环境逻辑图)
  - [InstanceKlass和InstanceMirrorKlass是什么](类加载机制.md#InstanceKlass和InstanceMirrorKlass是什么)
  - [ArrayKlass和TypeArrayKlass和ObjArrayKlass是什么](类加载机制.md#ArrayKlass和TypeArrayKlass和ObjArrayKlass是什么)
  - [类加载的五个过程](类加载机制.md#类加载的五个过程)
  - [类加载之加载](类加载机制.md#类加载之加载)
    - [加载的规范定义](类加载机制.md#加载的规范定义)
    - [数组类的加载过程](类加载机制.md#数组类的加载过程)
  - [类加载之验证](类加载机制.md#类加载之验证)
    - [验证的规范定义](类加载机制.md#验证的规范定义)
    - [四种验证方法](类加载机制.md#四种验证方法)
  - [类加载之准备](类加载机制.md#类加载之准备)
    - [准备的规范定义](类加载机制.md#准备的规范定义)
    - [数据类型的零值](类加载机制.md#数据类型的零值)
  - [类加载之解析](类加载机制.md#类加载之解析)
    - [解析的规范定义](类加载机制.md#解析的规范定义)
    - [符号引用替换为直接引用](类加载机制.md#符号引用替换为直接引用)
  - [类加载之初始化](类加载机制.md#类加载之初始化)
    - [初始化的规范定义](类加载机制.md#初始化的规范定义)
    - [clinit方法的深入理解](类加载机制.md#clinit方法的深入理解)
  - [类加载什么时候会进行](类加载机制.md#类加载什么时候会进行)
    - [加载mainClass](类加载机制.md#加载mainClass)
    - [new或getstatic或putstatic或invokestatic](类加载机制.md#new或getstatic或putstatic或invokestatic)
    - [优先加载父类](类加载机制.md#优先加载父类)
    - [反射](类加载机制.md#反射)
  - [类加载笔试题统一解法](类加载机制.md#类加载笔试题统一解法)
- [类加载器](类加载器.md)
  - [类加载器的定义](类加载器.md#类加载器的定义)
  - [类加载的唯一性](类加载器.md#类加载的唯一性)
  - [双亲委派模型的定义](类加载器.md#双亲委派模型的定义)
  - [启动类加载器](类加载器.md#启动类加载器)
    - [启动类加载器的定义](类加载器.md#启动类加载器的定义)
    - [启动类加载器的管辖范围](类加载器.md#启动类加载器的管辖范围)
  - [拓展类加载器](类加载器.md#拓展类加载器)
    - [拓展类加载器的定义](类加载器.md#拓展类加载器的定义)
    - [拓展类加载器的管辖范围](类加载器.md#拓展类加载器的管辖范围)
  - [应用类程序加载器](类加载器.md#应用类程序加载器)
    - [应用类程序加载器的定义](类加载器.md#应用类程序加载器的定义)
    - [应用类程序加载器的管辖范围](类加载器.md#应用类程序加载器的管辖范围)
  - [深入理解双亲委派模型源码](类加载器.md#深入理解双亲委派模型源码)
  - [破坏双亲委派模型的定义](类加载器.md#破坏双亲委派模型的定义)
  - [自定义类加载器](类加载器.md#自定义类加载器)
    - [自定义类加载器打破双亲委派的关键](类加载器.md#自定义类加载器打破双亲委派的关键)
    - [自定义类加载器经典例子](类加载器.md#自定义类加载器经典例子)
    - [自定义类加载器例子之OSGi](类加载器.md#自定义类加载器例子之OSGi)
  - [SPI机制与线程上下文类加载器](类加载器.md#SPI机制与线程上下文类加载器)
    - [SPI机制的定义](类加载器.md#SPI机制的定义)
    - [SPI机制例子之ServiceLoader](类加载器.md#SPI机制例子之ServiceLoader)
    - [SPI机制例子之JDBCMysql](类加载器.md#SPI机制例子之JDBCMysql)
    - [线程上下文类加载器](类加载器.md#线程上下文类加载器)
- [类加载与Tomcat]
- [类加载与Spring]

#### 第2章：类文件结构与字节码指令
- [类文件结构](类文件结构.md)
  - TODO
- [字节码指令](字节码指令.md)
  - TODO

#### 第3章：JVM内存之运行时数据区域
- [JVM内存之运行时数据区域](JVM内存之运行时数据区域.md)
  - [运行时数据区域的定义](JVM内存之运行时数据区域.md#运行时数据区域的定义)
  - [程序计数器](JVM内存之运行时数据区域.md#程序计数器)
  - [虚拟机栈与本地方法栈](JVM内存之运行时数据区域.md#虚拟机栈与本地方法栈)
    - [虚拟机栈与本地方法栈的定义](JVM内存之运行时数据区域.md#虚拟机栈与本地方法栈的定义)
    - [栈帧的概念](JVM内存之运行时数据区域.md#栈帧的概念)
    - [虚拟机栈与本地方法栈溢出](JVM内存之运行时数据区域.md#虚拟机栈与本地方法栈溢出)
  - [方法区](JVM内存之运行时数据区域.md#方法区)
    - [方法区的定义](JVM内存之运行时数据区域.md#方法区的定义)
    - [永久代及元空间](JVM内存之运行时数据区域.md#永久代及元空间)
    - [元空间取代永久代的理由](JVM内存之运行时数据区域.md#元空间取代永久代的理由)
    - [运行时常量池](JVM内存之运行时数据区域.md#运行时常量池)
    - [方法区溢出](JVM内存之运行时数据区域.md#方法区溢出)
      - [例子1-基于JDK6的字符串常量池溢出](JVM内存之运行时数据区域.md#例子1-基于JDK6的字符串常量池溢出)
      - [例子2-使用CGLib让方法区内存溢出](JVM内存之运行时数据区域.md#例子2-使用CGLib让方法区内存溢出)
  - [堆区](JVM内存之运行时数据区域.md#堆区)
    - [堆区的定义](JVM内存之运行时数据区域.md#堆区的定义)
    - [新生代与老年代与永久代](JVM内存之运行时数据区域.md#新生代与老年代与永久代)
    - [Eden区与两个Survivor区](JVM内存之运行时数据区域.md#Eden区与两个Survivor区)
    - [字符串常量池](JVM内存之运行时数据区域.md#字符串常量池)
    - [堆区溢出](JVM内存之运行时数据区域.md#堆区溢出)
      - [例子1-创建过多对象导致堆区溢出](JVM内存之运行时数据区域.md#例子1-创建过多对象导致堆区溢出)
      - [例子2-再看字符串常量池溢出](JVM内存之运行时数据区域.md#例子2-再看字符串常量池溢出)
  - [直接内存](JVM内存之运行时数据区域.md#直接内存)
    - [直接内存的定义](JVM内存之运行时数据区域.md#直接内存的定义)
    - [直接内存与元空间](JVM内存之运行时数据区域.md#直接内存与元空间)
    - [直接内存溢出例子](JVM内存之运行时数据区域.md#直接内存溢出例子)
      - [例子1-使用Unsafe让直接内存溢出](JVM内存之运行时数据区域.md#例子1-使用Unsafe让直接内存溢出)
  - [调优命令](JVM内存之运行时数据区域.md#调优命令)
    - [查看各区域内存大小](JVM内存之运行时数据区域.md#查看各区域内存大小)
    - [修改各区域内存大小](JVM内存之运行时数据区域.md#修改各区域内存大小)
  - [区域间的指向关系含义](JVM内存之运行时数据区域.md#区域间的指向关系含义)

#### 第4章：字节码执行引擎与即时编译器

#### 第5章：对象的生命周期与字符串常量池

#### 第6章：垃圾收集算法与垃圾收集器

#### 第7章：JVM运维工具与调优案例分析

#### 第8章：JAVA多线程高并发
- [深入理解JAVA多线程高并发](../深入理解JAVA多线程高并发)
  - [第1章：并发编程基础概念](../深入理解JAVA多线程高并发#第1章并发编程基础概念)

#### 第9章：JVM100道面试问题
- [JVM100道面试问题](JVM100道面试问题.md)
