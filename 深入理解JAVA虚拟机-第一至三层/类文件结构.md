- [类文件结构](#类文件结构)
  - [类文件的定义](#类文件的定义)
  - [类文件的数据紧凑性](#类文件的数据紧凑性)
  - [类文件的结构轮廓](#类文件的结构轮廓)
  - [无符号数与表](#无符号数与表)
  - [类文件例子](#类文件例子)
  - [魔数](#魔数)
  - [次版本号与主版本号](#次版本号与主版本号)
  - [常量池](#常量池)
    - [常量池的定义](#常量池的定义)
    - [常量池容量计数器](#常量池容量计数器)
    - [常量池的结构轮廓](#常量池的结构轮廓)
    - [CONSTANT_Utf8_info](#CONSTANT_Utf8_info)
    - [CONSTANT_Integer_info](#CONSTANT_Integer_info)
    - [8种基本数据类型及自动转换关系](#8种基本数据类型及自动转换关系)
    - [CONSTANT_Float_info](#CONSTANT_Float_info)
    - [IEEE754二进制浮点数算术标准](#IEEE754二进制浮点数算术标准)
      - [例子-十进制浮点数转32位二进制浮点数](#例子-十进制浮点数转32位二进制浮点数)
      - [例子-32位二进制浮点数转十进制浮点数](#例子-32位二进制浮点数转十进制浮点数)
    - [CONSTANT_Class_info](#CONSTANT_Class_info)
    - [全部常量池项结构](#全部常量池项结构)
  - [类访问标志](#类访问标志)
  - [本类父类接口](#本类父类接口)
    - [类索引](#类索引)
    - [父类索引](#父类索引)
    - [接口计数器](#接口计数器)
    - [接口索引集合](#接口索引集合)
  - [字段表](#字段表)
    - [字段表计数器](#字段表计数器)
    - [字段表结构](#字段表结构)
    - [字段表访问标志](#字段表访问标志)
    - [访问权限修饰符的作用域](#访问权限修饰符的作用域)
    - [描述符](#描述符)
  - [方法表](#方法表)
    - [方法表计数器](#方法表计数器)
    - [方法表结构](#方法表结构)
    - [方法表访问标志](#方法表访问标志)
    - [重写与重载](#重写与重载)
    - [clinit与init](#clinit与init)
  - [属性表](#属性表)
    - [属性表计数器](#属性表计数器)
    - [属性表通用结构](#属性表通用结构)
    - [全部属性表项](#全部属性表项)
    - [Code](#Code)
    - [Exceptions](#Exceptions)
    - [try-catch-finally语句逻辑](#try-catch-finally语句逻辑)
    - [ConstantValue](#ConstantValue)
    - [InnerClasses](#InnerClasses)

# 类文件结构

> 终于开始类文件结构章节的书写了，为了写这一篇章节，我花了至少7天的时间完成了一个ParseClassFile项目，项目链接：https://github.com/peteryuanpan/ParseClassFile 。刚刚写完了这个项目的介绍文档，它的核心功能，是读入一份类文件，将每一个字节的含义按照特有的格式输出。对该项目感兴趣的朋友，可以进去看看文档和源码，我也非常建议结合两份文档一起来阅读，单独阅读本文章肯定是枯燥乏味的，解析类文件过程就是这样，无法避免

> 我将会在文章中以类文件为具体例子，介绍类文件的组成部分，还会穿插JavaSE中的基础问题、面试问题等

> 在准备的过程中，我发现一个点，解析类文件结构，实际上是对JAVA语法更深入的理解，比如try catch语句、throws Exception语句，它们对应类文件的哪一个部分，具体内容是什么，比如float和double分别是4个字节和8个字节，但表示的数字范围很大，浮点表示法的原理是什么，比如一个方法完整有哪些组成部分等等。所以，在书写文章的过程中，我不仅会逐一介绍类文件结构的组成部分，还会穿插着JavaSE中的基础问题、面试问题

> 多提一点，这里并不涉及到字节码指令（非指Java字节码），字节码指令只是方法表中的一个属性（Code）而已，关于字节码我们会在 [字节码指令](字节码指令.md) 章节中讲解

> 需要说清楚一点，Java bytecode直译是Java字节码，但我认为不准确，更准确的翻译是二进制字节流。JAVA虚拟机定义是一种能够运行Java字节码程序的虚拟机器，这里的Java字节码是广义的指二进制字节流，而狭义的是指字节码指令。二进制字节流包括类文件，虚拟机加载的一般是类文件，不是只加载字节码指令。字节码指令是指描述Java语句的指令，主要存在于方法表中，它只是类文件的一部分，比如new、putstatic、getstatic这些指令

### 类文件的定义

类文件是一种可以被虚拟机执行的包含了字节码数据的文件；Java类文件通常被Javac编译器从JAVA源文件编译而来，同时，其他语言也可以编译成类文件，比如Jython，Scala，Kotlin

> A Java class file is a file (with the .class filename extension) containing Java bytecode that can be executed on the Java Virtual Machine (JVM). A Java class file is usually produced by a Java compiler from Java programming language source files (.java files) containing Java classes (alternatively, other JVM languages can also be used to create class files).

在类加载这一章节中，我们已经说的比较清楚了，类文件无关乎从哪个语言而来，无关乎在哪里存储，准确的说，它是一组二进制字节流

### 类文件的数据紧凑性

Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在

当遇到需要占用8位字节以上空间的数据项时，会按照高位在前（Big-Endian）的方式分割成若干个8位字节进行存储

> Big-Edian，也称为大端，具体是指最高位字节在地址最低位、最低位字节在地址最高位的顺序来存储数据，它是SPARC、PowerPC等处理器的默认多字节存储顺序，而x86等处理器则是使用了相反的“Little-Endian”顺序来存储数据，Little-Endian称为小端

> 其实我个人认为，不需要去纠结大端小端，你知道怎么读数据就好了，否则容易把自己弄晕，后面例子中若有超过8位字节的数据，会关联说明一下大端和小端

### 类文件的结构轮廓

类文件的结构轮廓（Layout）有16个元素，分别如下

|序号|类型|名称|数量|
|--|--|--|--|
|1|U4|magic|1|
|2|U2|minor_version|1|
|3|U2|major_version|1|
|4|U2|costant_pool_count|1|
|5|cp_info|costant_pool|costant_pool_count - 1|
|6|U2|access_flags|1|
|7|U2|this_class|1|
|8|U2|super_class|1|
|9|U2|interfaces_count|1|
|10|U2|interfaces|interfaces_count|
|11|U2|fields_count|1|
|12|field_info|field|fields_count|
|13|U2|methods_count|1|
|14|method_info|method|methods_count|
|15|U2|attributes_count|1|
|16|attribute_info|attributes|attributes_count|

其中类型中含有U1、U2、U4、U8四种，它们是无符号数，除了无符号数外，剩下都称之为表，表是一种复合型数据类型

可以看出，类文件结构轮廓中有4项属于表，分别是constant_pool、fields、methods、attributes，其他都是无符号数

### 无符号数与表

根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要以这两种数据类型为基础

无符号数属于基本的数据类型，以U1、U2、U4、U8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数

无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值

表是由多个无符号数或者其他表作为数据项构成的复合数据类型

表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表

### 类文件例子

我们举2个类文件例子，用于以后篇幅的说明解释

#### VerySimpleClassFile

第一份是非常简单的程序，这个Java程序够简单了吧，表面看上去它几乎什么都没有，就一个package和class信息

VerySimpleClassFile.java
[VerySimpleClassFile.java](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/VerySimpleClassFile.java)
```java
package classfile;

public class VerySimpleClassFile {
}
```

它class文件如下

[VerySimpleClassFile.class](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/VerySimpleClassFile.class)
```
cafe babe 0000 0034 000d 0a00 0300 0a07
000b 0700 0c01 0006 3c69 6e69 743e 0100
0328 2956 0100 0443 6f64 6501 000f 4c69
6e65 4e75 6d62 6572 5461 626c 6501 000a
536f 7572 6365 4669 6c65 0100 1856 6572
7953 696d 706c 6543 6c61 7373 4669 6c65
2e6a 6176 610c 0004 0005 0100 1d63 6c61
7373 6669 6c65 2f56 6572 7953 696d 706c
6543 6c61 7373 4669 6c65 0100 106a 6176
612f 6c61 6e67 2f4f 626a 6563 7400 2100
0200 0300 0000 0000 0100 0100 0400 0500
0100 0600 0000 1d00 0100 0100 0000 052a
b700 01b1 0000 0001 0007 0000 0006 0001
0000 0003 0001 0008 0000 0002 0009 
```

#### VeryUsefulClassFile

这份文件会有一些长度，但非常有用

[VeryUsefulClassFile.java](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/VeryUsefulClassFile.java)
```java
package classfile;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Orange(getName = "3333",getValue = "4444")
public class VeryUsefulClassFile implements Interface1, Interface2, Interface3 {

    boolean boolean1 = false;
    boolean boolean2 = true;
    boolean boolean3 = Boolean.FALSE;
    boolean boolean4 = Boolean.TRUE;

    byte byte1 = 123;
    byte byte2 = Byte.valueOf("12345");
    byte byte3 = Byte.MAX_VALUE;
    byte byte4 = Byte.MIN_VALUE;

    char char1 = 'A';
    char char2 = '\0';
    char char3 = Character.MAX_VALUE;
    char char4 = Character.MIN_VALUE;

    short short1 = 12345;
    short short2 = Short.valueOf("123456");
    short short3 = Short.MAX_VALUE;
    short short4 = Short.MIN_VALUE;

    int int1 = 123;
    int int2 = 123456789;
    int int3 = Integer.MAX_VALUE;
    int int4 = Integer.MIN_VALUE;

    final int int5 = 987;

    float float1 = 100;
    float float2 = Float.valueOf("1234567");
    float float3 = Float.MAX_VALUE;
    float float4 = Float.MIN_VALUE;

    long long1 = 12345678987654321L;
    long long2 = -12345678987654321L;
    long long3 = Long.valueOf("12345678");
    long long4 = Long.MAX_VALUE;
    long long5 = Long.MIN_VALUE;

    double double1 = 1e3;
    double double2 = 1e100;
    double double3 = Double.valueOf("123456789");
    double double4 = Double.MAX_VALUE;
    double double5 = Double.MIN_VALUE;

    public static String string1 = "string1";
    String string2 = new String("string2");
    String string3 = string1 + string2;

    Interface1 interface1 = new Interface1() {
        public int aaa(int a) { return -1; }
        public double bbb() { return 0.0; }
    };
    int interface1_aaa1 = interface1.aaa(1);
    public double interface1_bbb1 = interface1.bbb();

    public VeryUsefulClassFile() throws InterruptedException {
        Thread.sleep(100);
        try {
            Thread.sleep(200);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Deprecated
    public int aaa(int aa) {
        return 0;
    }

    public double bbb() {
        return 0;
    }

    public static void main(String[] args) {
        Runnable x = () -> {
        };
    }

    static class SubClass1 {
        int a;
    }

    class SubClass2 {
        int b;
    }
}

interface Interface1 {
    int aaa(int a);
    double bbb();
}

interface Interface2 {
}

interface Interface3 {
}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Orange {
    String getName();
    String getValue();
}
```

由于内容过长，VeryUsefulClassFile的类文件和解析结果，我就不在篇幅里贴出了，需要查看可以参考：[VeryUsefulClassFile.class](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/VeryUsefulClassFile.class) 和 [ResultVeryUsefulClassFile.txt](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/ResultVeryUsefulClassFile.txt)

### 魔数

每个Class文件的头4个字节称为魔数（magic，第1项），它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件，很多文件存储标准中都使用魔数来进行身份识别，不如gif、jpeg文件头中都有魔数

Class文件的魔数很具有“浪漫气息”，值为：0xCAFEBABE，经常被戏称为“咖啡宝贝”，这个魔数值在Java还称作“Oak”语言时（大概1991年前后）就已经确定了，据说是为了象征著名咖啡品牌Peet's Coffee中深受欢迎的Baristas咖啡而起的

可以看到，VerySimpleClassFile.class开头8个字符是cafebabe，每一个字符表示1个十六进制数（0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f）

1个十六进制数可以由4位二进制数表示，8位是1字节，因此2个十六进制数是1个字节，那么8个十六进制数就是4个字节，魔数（magic）也是一个U4类型，表示4个字节的无符号数

使用ParseClassFile项目解析VeryUsefulClassFile的魔数，得到如下结果
```
--------Begin Magic--------
magic: 0xcafebabe
--------End Magic--------
```

### 次版本号与主版本号

版本号有两个项，分别是次版本号（minor_version，第2项）和主版本号（major_version，第3项）

根据VerySimpleClassFile.class来看，次版本号和主版本号分别对应 0000 和 0034，转成十进制数分别是 0 和 52，再转化是指JDK8

下面是JDK版本号与主次版本号的对应表格

|JDK版本|十六进制版本号|十进制版本号|
|--|--|--|
|JDK6|00000032|50.0|
|JDK7|00000033|51.0|
|JDK8|00000034|52.0|
|JDK9|00000035|53.0|
|JDK10|00000036|54.0|
|JDK11|00000037|55.0|
|JDK12|00000038|56.0|
|JDK13|00000039|57.0|

高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，虚拟机必须拒绝执行超过其版本号的Class文件

使用ParseClassFile项目解析VeryUsefulClassFile的版本号，得到如下结果
```
--------Begin Version--------
minor_version: 0(0x0000)
major_version: 52(0x0034)
--------End Version--------
```

### 常量池

好，到了第一个比较复杂的项目了，常量池中的类型比较多，JDK8种就有17种

#### 常量池的定义

常量池（constant_pool，第5项）是存放常量数据的主要仓库，两大类常量：字面量（Literal）和符号引用（Symbolic References）

字面量比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等

符号引用则属于编译原理方面的概念，包括下面三类常量
- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符

Java代码在进行Javac编译时，并不像C和C++那样有“连接”这一步，而是在虚拟机加载Class文件的进行动态链接

当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时（静态解析）或运行时（动态链接）解析、翻译到具体的内存地址中

#### 常量池容量计数器

常量池容量计数器（costant_pool_count，第4项）表示常量池的个数减1

> 这里指的特殊说明的一点是，常量池的索引范围是 [1, costant_pool_count)

> 举例子来说，假设costant_pool_count=20，那么索引1表示第一个常量池，索引19表示最后一个常量池。也就是说，实际的常量池个数要少1个，costant_pool_count=20，则有19个常量池。从索引1开始只有常量池是特殊的，其他的数组类型，包括接口集合、字段表集合、方法表集合等，索引都是从0开始。至于为什么是这样子，并不清楚，总之现在就是这么定义的了

索引在类文件的数组类型中，是非常重要的，因为时常会涉及到数组元素的指是一个索引，指向的是数组的另一个元素，下面的例子中会有具体体现

使用ParseClassFile项目解析VeryUsefulClassFile的常量池容量计数器，得到如下结果
```
--------Begin Constant Pool--------
constant_pool_count: 351(0x015f)
```

#### 常量池的结构轮廓

在JDK8中，常量池中一共有17种常量池项，分别如下

|类型|标志（tag）|描述|
|--|--|--|
|CONSTANT_Utf8_info|1|UTF-8编码的字符串|
|CONSTANT_Integer_info|3|整型字面量|
|CONSTANT_Float_info|4|浮点型字面量|
|CONSTANT_Long_info|5|长整型字面量|
|CONSTANT_Double_info|6|双精度浮点型字面量|
|CONSTANT_Class_info|7|类或接口的符号引用|
|CONSTANT_String_info|8|字符串类型字面量|
|CONSTANT_Fieldref_info|9|字段的符号引用|
|CONSTANT_Methodref_info|10|类中方法的符号引用|
|CONSTANT_InterfaceMethodref_info|11|接口中方法的符号引用|
|CONSTANT_NameAndType_info|12|字段或者方法的部分符号引用|
|CONSTANT_MethodHandle_info|15|表示方法句柄|
|CONSTANT_MethodType_info|16|表示方法类型|
|CONSTANT_Dynamic_info|17|表示一个动态计算常量|
|CONSTANT_InvokeDynamic_info|18|表示一个动态方法调用点|
|CONSTANT_Module_info|19|表示一个模块|
|CONSTANT_Package_info|20|表示一个模块中开放或者导出的包|

标志（tag）唯一标识了每个常量池项，在所有常量池项中，第一个字节就是标志

除了 CONSTANT_Dynamic_info、CONSTANT_Module_info、CONSTANT_Package_info 这三个常量池项外，其余14个常量池项，我都把它在VeryUsefulClassFile中体现出来了

现在，我们就按照顺序，简要的说一遍常量池项

> 就如文章最开头所说一样，解析类文件结构，实际上是对JAVA语法更深入的理解，接下来的过程是非常繁琐的，无法避免

> 为了不过分浪费篇幅，我决定用“点到为止”的办法来解释，只对于Constant_Utf8_info、CONSTANT_Integer_info、CONSTANT_Float_info、CONSTANT_Class_info这几个常见的常量池项，用几个简单例子来解释即可，而对于其他常量池项，用统一一个表格来描述，说明其结构即可，毕竟这部分对于理解JVM原理来说，它不算核心，而是属于细枝末节

#### CONSTANT_Utf8_info

结构如下
|项目|类型|描述|
|--|--|--|
|tag|U1|标志，值为1|
|length|U2|UTF-8编码的字符串占用的字节数|
|bytes|U1[]|长度为length的UTF-8编码的字符串|

例子1
```
[121] Constant_Utf8_Info(0x010008626f6f6c65616e31)
tag: [1(0x01)]
length_string: [8(0x0008)]
value_string: [boolean1(0x626f6f6c65616e31)]
```

例子2
```
[266] Constant_Utf8_Info(0x010009313233343536373839)
tag: [1(0x01)]
length_string: [9(0x0009)]
value_string: [123456789(0x313233343536373839)]
```

例子3
```
[297] Constant_Utf8_Info(0x01001d636c61737366696c652f5665727955736566756c436c61737346696c65)
tag: [1(0x01)]
length_string: [29(0x001d)]
value_string: [classfile/classfile.VeryUsefulClassFile(0x636c61737366696c652f5665727955736566756c436c61737346696c65)]
```

CONSTANT_Utf8_info存储字符串数据，它是许多其他常量池项的索引目标
- 例子1，boolean boolean1 = false; 字段名，从Constant_Fieldref_Info指来
- 例子2，double double3 = Double.valueOf("123456789"); 字符串，从Constant_String_Info指来
- 例子3，public class VeryUsefulClassFile... 类名，从Constant_Class_Info指来

#### CONSTANT_Integer_info

结构如下
|项目|类型|描述|
|--|--|--|
|tag|U1|标志，值为3|
|bytes|U4|按照高位在前存储的int值|

例子1
```
[20] Constant_Integer_Info(0x030000ffff)
tag: [3(0x03)]
value: [65535(0x0000ffff)]
```

例子2
```
[32] Constant_Integer_Info(0x03075bcd15)
tag: [3(0x03)]
value: [123456789(0x075bcd15)]
[35] Constant_Integer_Info(0x037fffffff)
tag: [3(0x03)]
value: [2147483647(0x7fffffff)]
[37] Constant_Integer_Info(0x0380000000)
tag: [3(0x03)]
value: [-2147483648(0x80000000)]
```

例子3
```
[148] Constant_Integer_Info(0x03000003db)
tag: [3(0x03)]
value: [987(0x000003db)]
```

CONSTANT_Integer_info存储整型数据
- 例子1，char char3 = Character.MAX_VALUE; 语句中的整型数值
- 例子2，以下语句中的整型数值
```java
int int2 = 123456789;
int int3 = Integer.MAX_VALUE;
int int4 = Integer.MIN_VALUE;
```
- 例子3，final int int5 = 987; 语句中的整型数值

到这里，我们会产生一些疑惑了，VeryUsefulClassFile中还有一些以下语句，为什么它们都没有对应的Constant_Integer_Info项呢？
```java
byte byte1 = 123;
byte byte3 = Byte.MAX_VALUE;
byte byte4 = Byte.MIN_VALUE;
char char1 = 'A';
char char2 = '\0';
char char3 = Character.MAX_VALUE;
char char4 = Character.MIN_VALUE;
short short1 = 12345;
short short3 = Short.MAX_VALUE;
short short4 = Short.MIN_VALUE;
int int1 = 123;
float float1 = 100;
```

为了解释这个问题，我们再来看一个例子

IntegerNumberDemo.java
```java
package classfile;

public class IntegerNumberDemo {

    int a1 = 123;
    final int a2 = 124;
    int a3 = 32767;
    int a4 = 32768;
    int a5 = 123456789;

    int a6 = -1;
    int a7 = -32767;
    int a8 = -32768;
    int a9 = -32769;

    boolean bol1 = true;
    byte by1 = 13;
    char ch1 = '1';
    short sh1 = 30000;

    public static void main(String[] args) {
    }
}
```

它的类文件及解析结果分别是：[IntegerNumberDemo.class](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/IntegerNumberDemo.class) 和 [ResultIntegerNumberDemo.txt](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/ResultIntegerNumberDemo.txt)

在这个例子中，解析出来的Constant_Integer_Info项一共只有4个，分别如下
```
[5] Constant_Integer_Info(0x0300008000)
tag: [3(0x03)]
value: [32768(0x00008000)]
[7] Constant_Integer_Info(0x03075bcd15)
tag: [3(0x03)]
value: [123456789(0x075bcd15)]
[11] Constant_Integer_Info(0x03ff439eb2)
tag: [3(0x03)]
value: [-12345678(0xff439eb2)]
[21] Constant_Integer_Info(0x030000007c)
tag: [3(0x03)]
value: [124(0x0000007c)]
```

也就是说，只有变量a4、a5、a9、a2产生了Constant_Integer_Info项，其他的变量都没有产生

然后我翻遍了常量池中的所有数据，都没有找到其他变量对应的值，这说不过去，因为如果都没有的话，JVM是不可能知道如何读取这些变量的值的，使用时就会出现问题

这时候我想到了字节码，查看init函数的字节码，如下
```
 0 aload_0
 1 invokespecial #1 <java/lang/Object.<init>>
 4 aload_0
 5 bipush 123
 7 putfield #2 <classfile/IntegerNumberDemo.a1>
10 aload_0
11 bipush 124
13 putfield #3 <classfile/IntegerNumberDemo.a2>
16 aload_0
17 sipush 32767
20 putfield #4 <classfile/IntegerNumberDemo.a3>
23 aload_0
24 ldc #5 <32768>
26 putfield #6 <classfile/IntegerNumberDemo.a4>
29 aload_0
30 ldc #7 <123456789>
32 putfield #8 <classfile/IntegerNumberDemo.a5>
35 aload_0
36 iconst_m1
37 putfield #9 <classfile/IntegerNumberDemo.a6>
40 aload_0
41 sipush 32769
44 putfield #10 <classfile/IntegerNumberDemo.a7>
47 aload_0
48 sipush 32768
51 putfield #11 <classfile/IntegerNumberDemo.a8>
54 aload_0
55 ldc #12 <-32769>
57 putfield #13 <classfile/IntegerNumberDemo.a9>
60 aload_0
61 iconst_1
62 putfield #14 <classfile/IntegerNumberDemo.bol1>
65 aload_0
66 bipush 13
68 putfield #15 <classfile/IntegerNumberDemo.by1>
71 aload_0
72 bipush 49
74 putfield #16 <classfile/IntegerNumberDemo.ch1>
77 aload_0
78 sipush 30000
81 putfield #17 <classfile/IntegerNumberDemo.sh1>
84 return
```

问题就可以确认了，其他不由Constant_Integer_Info项表达的变量，在字节码中表达

在仔细看，可以发现一些有趣的，比如 int a6 = -1; 是由 iconst_m1 来赋值；int a7 = -32767; 和 int a8 = -32768; 是分别由 sipush 32769 和 sipush 32768 来赋值

做一下总结
- Constant_Integer_Info可以表达的整型变量的类型有：byte、char、short、int；而boolean类型由于只有true和false两种值，直接在字节码中表达了
- 非final修饰的整型变量，若值在 [-32768, 32767] 范围之外，由Constant_Integer_Info表达，若值在 [-32768, 32767] 范围之内，在字节码中表达
- final修饰的整型变量，会由Constant_Integer_Info直接表达
- 被final修饰的变量赋值，相当于值赋值，比如char char3 = Character.MAX_VALUE，也会产生一个Constant_Integer_Info表达（65535），而Character.MAX_VALUE的源码是public static final char MAX_VALUE = '\uFFFF';

#### 8种基本数据类型及自动转换关系

来复习一下，Java中8种数据类型

|类型|长度|范围|
|--|--|--|
|boolean|1个字节|true或false|
|byte|1个字节|-128~127|
|char|2个字节|从字符型对应的整型数来划分，其表示范围是0~65535|
|short|2个字节|-32768~32767|
|int|4个字节|-2147483648~2147483647|
|long|8个字节|-9223372036854775808 ~ 9223372036854775807|
|float|4个字节|-3.4E38~3.4E38|
|double|8个字节|-1.7E308~1.7E308|

自动转换关系
- 低到高，(byte，short，char) -> int -> long -> float -> double
- 不符合上面关系链的，由高到低的，需要强制转换，比如 int a = 0; char c = (char) a;
- boolean不支持与其他基本类型转换，包括强制转换

#### CONSTANT_Float_info

结构如下
|项目|类型|描述|
|--|--|--|
|tag|U1|标志，值为4|
|bytes|U4|按照高位在前存储的float值|

例子1
```
[40] Constant_Float_Info(0x0442c80000)
tag: [4(0x04)]
value: [1120403456(0x42c80000)]
value_float: [100.0]
```

例子2
```
[47] Constant_Float_Info(0x047f7fffff)
tag: [4(0x04)]
value: [2139095039(0x7f7fffff)]
value_float: [3.4028235E38]
```

CONSTANT_Float_info存储float型数据
- 例子1，float float1 = 100; 语句中的数值
- 例子2，float float3 = Float.MAX_VALUE; 语句中的数值，Float.MAX_VALUE的源码是public static final float MAX_VALUE = 0x1.fffffeP+127f; // 3.4028235e+38f

#### IEEE754二进制浮点数算术标准

IEEE二进制浮点数算术标准（IEEE 754）是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用

下面我使用两个例子来解释IEEE 754

##### 例子-十进制浮点数转32位二进制浮点数

假设有一个十进制浮点数263.3，请转为32位二进制浮点数
- 为了方面讲解，我直接截图了
![image](https://user-images.githubusercontent.com/10209135/95718664-56c5be80-0ca1-11eb-9350-309846be4cec.png)
- 通过上面的方法，就可以将 263 转成100000111，.3转成010011001100110011...
- 这样 263.3 可以转成100000111.010011001100110011...
- 然后转成 1.00000111010011001100110011... * 2^8
- 公式1：X=(-1)^S*(1.M)*(2^e)
- 其中 X 是二进制表达，S是符号位（sign bit），M是指数偏移值（exponent bias），e是分数值（fraction）
- 公式2：e=E-127
- 公式3：二进制表达（32位） = S（1位）+ E（8位）+ M（31位）
- X=1.00000111010011001100110011... * 2^8（公式1）
- S=0，表示正数（公式1）
- e=8（公式1）
- E=e+127=136（公式2）
- E=10000111
- 1.M=1.00000111010011001100110011...（公式1）
- M=00000111010011001100110011...
- 二进制表达=S+E+M=01000011100000111010011001100110011...
- 32位二进制表达：0100 0011 1000 0011 1010 0110 0110 0110

Java中转换例子
```java
package math;

public class FloatToHexString{

    public static void main(String[] args) {
        float f = 263.3f;
        int i = Float.floatToIntBits(f);
        String hexS = Integer.toHexString(i);
        System.out.println(f);
        System.out.println(i);
        System.out.println(hexS);
    }
}
```
输出结果
```
263.3
1132701286
4383a666
```

##### 例子-32位二进制浮点数转十进制浮点数

假设有一个32位二进制浮点数，它的十六进制表达是：0x41360000，请转为十进制浮点数
- 转成二进制表达：0100 0001 0011 0110 0000 0000 0000 0000
- 公式1：X=(-1)^S*(1.M)*(2^e)，其中 X 是二进制表达，S是符号位（sign bit），M是指数偏移值（exponent bias），e是分数值（fraction）
- 公式2：e=E-127
- 公式3：二进制表达（32位） = S（1位）+ E（8位）+ M（31位）
- S=0，表示正数（公式3）
- E=10000010（公式3）
- E=130
- e=E-127=3（公式2）
- M=01101100000000000000000（公式3）
- 1.M=1.011011
- X=1011.011（公式1）
- 将1.M从二进制转成十进制
- 1011 => 11
- .011 => 0,375
- 则十进制表达是：11.375

这里重点说一下 .011 是怎么变成 0.375 的
- 要把011反过来看，也就是110
- 第一个数是1，则1/2=0.5
- 第二个数是1，则1+0.5=1.5，1.5/2=0.75
- 第三个数是0，则0+0.75=0.75，0.75/2=0.375

Java中转换例子
```java
package math;

public class HexStringToFloat {

    public static void main(String[] args) {
        String hexS = "41360000";
        int i = Integer.valueOf(hexS, 16);
        double f = Float.intBitsToFloat(i);
        System.out.println(hexS);
        System.out.println(i);
        System.out.println(f);
    }
}
```
输出结果
```
41360000
1094057984
11.375
```

#### CONSTANT_Class_info

结构如下
|项目|类型|描述|
|--|--|--|
|tag|U1|标志，值为7|
|index|U2|指向全限定名常量项的索引|

例子1
```
[14] Constant_Class_Info(0x0700e1)
tag: [7(0x07)]
name_index: [225(0x00e1)]
valueof_name_index: [Constant_Utf8_Info(0x01000e6a6176612f6c616e672f42797465), tag: [1(0x01)], length_string: [14(0x000e)], value_string: [java/lang/Byte(0x6a6176612f6c616e672f42797465)]]
```

例子2
```
[111] Constant_Class_Info(0x070129)
tag: [7(0x07)]
name_index: [297(0x0129)]
valueof_name_index: [Constant_Utf8_Info(0x01001d636c61737366696c652f5665727955736566756c436c61737346696c65), tag: [1(0x01)], length_string: [29(0x001d)], value_string: [classfile/VeryUsefulClassFile(0x636c61737366696c652f5665727955736566756c436c61737346696c65)]]
```

例子3
```
[119] Constant_Class_Info(0x07012f)
tag: [7(0x07)]
name_index: [303(0x012f)]
valueof_name_index: [Constant_Utf8_Info(0x010027636c61737366696c652f5665727955736566756c436c61737346696c6524537562436c61737331), tag: [1(0x01)], length_string: [39(0x0027)], value_string: [classfile/VeryUsefulClassFile$SubClass1(0x636c61737366696c652f5665727955736566756c436c61737346696c6524537562436c61737331)]]
```

CONSTANT_Class_info存储类和接口的全限定名（符号引用）
- 例子1，byte byte2 = Byte.valueOf("12345"); 语句中Byte类的全限定名
- 例子2，public class VeryUsefulClassFile 当前类的全限定名
- 例子3，子类SubClass1的全限定名
```java
static class SubClass1 {
    int a;
}
```

### 全部常量池项结构

|常量池项|项目|类型|描述|
|--|--|--|--|
|CONSTANT_Utf8_info|tag|U1|标志，值为1|
||length|U2|UTF-8编码的字符串占用的字节数|
||bytes|U1[]|长度为length的UTF-8编码的字符串|
|CONSTANT_Integer_info|tag|U1|标志，值为3|
||bytes|U4|按照高位在前存储的int值|
|CONSTANT_Float_info|tag|U1|标志，值为4|
||bytes|U4|按照高位在前存储的float值|
|CONSTANT_Long_info|tag|U1|标志，值为5|
||bytes|U8|按照高位在前存储的long值|
|CONSTANT_Double_info|tag|U1|标志，值为6|
||bytes|U8|按照高位在前存储的double值|
|CONSTANT_Class_info|tag|U1|标志，值为7|
||index|U2|指向全限定名常量项的索引，类型为CONSTANT_Utf8_info|
|CONSTANT_String_info|tag|U1|标志，值为8|
||index|U2|指向字符串字面量的索引，类型为CONSTANT_Utf8_info|
|CONSTANT_Fieldref_info|tag|U1|标志，值为9|
||index|U2|指向声明字段的类或者接口描述符的索引，类型为CONSTANT_Class_info|
||index|U2|指向字段描述符的索引，类型为CONSTANT_NameAndType_info|
|CONSTANT_Methodref_info|tag|U1|标志，值为10|
||index|U2|指向声明方法的类描述符的索引，类型为CONSTANT_Class_info|
||index|U2|指向方法描述符的索引，类型为CONSTANT_NameAndType_info|
|CONSTANT_InterfaceMethodref_info|tag|U1|标志，值为11|
||index|U2|指向声明方法的接口描述符的索引，类型为CONSTANT_Class_info|
||index|U2|指向方法描述符的索引，类型为CONSTANT_NameAndType_info|
|CONSTANT_NameAndType_info|tag|U1|标志，值为12|
||index|U2|指向该字段或方法名称常量项的索引，类型为CONSTANT_Utf8_info|
||index|U2|指向该字段或方法描述符常量项的索引，类型为CONSTANT_Utf8_info|
|CONSTANT_MethodHandle_info|tag|U1|标志，值为15|
||reference_kind|U2|值必须在1~9之间（包括1和9），它决定方法句柄的类型，方法句柄类型的值表示方法句柄的字节码行为|
||reference_index|U2|值必须是对常量池的有效索引|
|CONSTANT_MethodType_info|tag|U1|标志，值为16|
||reference_kind|U2|值必须是对常量池的有效索引，表示方法的描述符，类型为CONSTANT_Utf8_info|
|CONSTANT_Dynamic_info|tag|U1|标志，值为17|
||bootstrap_method_attr_index|U2|值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引|
||name_and_type_index|U2|值必须是对常量池的有效索引，表示方法名和方法的描述符，类型为CONSTANT_NameAndType_info|
|CONSTANT_InvokeDynamic_info|tag|U1|标志，值为18|
||bootstrap_method_attr_index|U2|值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引|
||name_and_type_index|U2|值必须是对常量池的有效索引，表示方法名和方法的描述符，类型为CONSTANT_NameAndType_info|
|CONSTANT_Module_info|tag|U1|标志，值为19|
||name_index|U2|值必须是对常量池的有效索引，表示模块名字，类型为CONSTANT_Utf8_info|
|CONSTANT_Package_info|tag|U1|标志，值为20|
||name_index|U2|值必须是对常量池的有效索引，表示包名字，类型为CONSTANT_Utf8_info|

### 类访问标志

在常量池结束后，紧接着两个字符代表方法标志（access_flags，第6项），它表示类或接口的许多状态集合（二进制或运算）

这个标志用于识别一些类或接口层次的访问信息，如下

|标志名称|标志值|含义|
|--|--|--|
|ACC_PUBLIC|0x0001|是否为public类型|
|ACC_FINAL|0x0010|是否被声明为final，只有类可设置|
|ACC_SUPER|0x0020|是否允许使用invokespecial字节码指令的新语意，invokespecial指令语意在JDK1.0.2发生过改变，JDK1.0.2之后编译出来的类的这个标志都必须为真|
|ACC_INTERFACE|0x0200|标识是一个接口|
|ACC_ABSTRACT|0x0400|是否为abstract类型，对于接口或抽象类来说，此标志为真，其他类值为假|
|ACC_SYNTHETIC|0x1000|标识这个类并非由用户代码产生|
|ACC_ANNOTATION|0x2000|标识是一个注解|
|ACC_ENUM|0x4000|标识是一个枚举|

使用ParseClassFile项目解析VeryUsefulClassFile的访问标志，得到如下结果
```
--------Begin Access Flag--------
[access_flag] Class_Access_Flag(0x0021)
value: [33(0x0021)]
FLAGs: [[ACC_PUBLIC], [ACC_SUPER]]
--------END Access Flag--------
```

由于VeryUsefulClassFile类是public的，且在JDK1.0.2之后编译，其他标志都不满足，因此它的状态为 0x0001 | 0x0020 = 0x0021

要注意，类文件中有4种访问标志，分别是类标志、字段访问标志、方法访问标志、内部类访问标志，剩余三种在下文会有提及

类访问标志中，有一个标志是ACC_ANNOTATION，这表示注解，关于注解，会在讲到属性 RuntimeVisibleAnnotations 等时提及

### 本类父类接口

#### 类索引
#### 父类索引

接下来有三个数据，分别是类索引（this_class，第7项）、父类索引（super_class，第8项）、接口索引集合（interfaces，第10项），用于描述类的继承关系（注意，这里所说的“类”也包括接口），这三者的索引都是指向常量池中的某一个类型为Constant_Utf8_Info的项

类索引是一个U2类型数据，用于确定这个类的全限定名，父类索引也是一个U2类型数据，用于确定这个类的父类的全限定名

使用ParseClassFile项目解析VeryUsefulClassFile的本类索引和父类索引，得到如下结果
```
--------Begin Class & Interfaces--------
[this_class] Class_Interface_Info(0x006f)
class_index: [111(0x006f)]
valueof_class_index: [Constant_Class_Info(0x070129), tag: [7(0x07)], name_index: [297(0x0129)], valueof_name_index: [Constant_Utf8_Info(0x01001d636c61737366696c652f5665727955736566756c436c61737346696c65), tag: [1(0x01)], length_string: [29(0x001d)], value_string: [classfile/VeryUsefulClassFile(0x636c61737366696c652f5665727955736566756c436c61737346696c65)]]]
valueof_name_index: [Constant_Utf8_Info(0x01001d636c61737366696c652f5665727955736566756c436c61737346696c65), tag: [1(0x01)], length_string: [29(0x001d)], value_string: [classfile/VeryUsefulClassFile(0x636c61737366696c652f5665727955736566756c436c61737346696c65)]]

[super_class] Class_Interface_Info(0x0070)
class_index: [112(0x0070)]
valueof_class_index: [Constant_Class_Info(0x07012a), tag: [7(0x07)], name_index: [298(0x012a)], valueof_name_index: [Constant_Utf8_Info(0x0100106a6176612f6c616e672f4f626a656374), tag: [1(0x01)], length_string: [16(0x0010)], value_string: [java/lang/Object(0x6a6176612f6c616e672f4f626a656374)]]]
valueof_name_index: [Constant_Utf8_Info(0x0100106a6176612f6c616e672f4f626a656374), tag: [1(0x01)], length_string: [16(0x0010)], value_string: [java/lang/Object(0x6a6176612f6c616e672f4f626a656374)]]
```

VeryUsefulClassFile类声明的原型是：public class VeryUsefulClassFile implements Interface1, Interface2, Interface3

因此本类指向的是值为classfile/VeryUsefulClassFile的Constant_Utf8_Info常量池项，父类指向的是值为java/lang/Object的Constant_Utf8_Info常量池项

使用ParseClassFile项目解析java.lang.Object的本类索引和父类索引，得到如下结果
```
--------Begin Class & Interfaces--------
[this_class] Class_Interface_Info(0x0033)
class_index: [51(0x0033)]
valueof_class_index: [Constant_Class_Info(0x070023), tag: [7(0x07)], name_index: [35(0x0023)], valueof_name_index: [Constant_Utf8_Info(0x0100106a6176612f6c616e672f4f626a656374), tag: [1(0x01)], length_string: [16(0x0010)], value_string: [java/lang/Object(0x6a6176612f6c616e672f4f626a656374)]]]
valueof_name_index: [Constant_Utf8_Info(0x0100106a6176612f6c616e672f4f626a656374), tag: [1(0x01)], length_string: [16(0x0010)], value_string: [java/lang/Object(0x6a6176612f6c616e672f4f626a656374)]]

[super_class] Class_Interface_Info(0x0000)
class_index: [0(0x0000)]
valueof_class_index: []
valueof_name_index: []
```

可以看出父类索引的值为0，即java.lang.Object没有父类了

#### 接口计数器
#### 接口索引集合

接下来是接口计数器（interfaces_count，第9项），用于描述实现的接口的个数，若没有实现接口，则计数器值为0，后面的索引集合也不占任何字节

接口索引集合（interfaces，第10项）是一组U2类型数据的集合，用来描述类实现了哪些接口，这些接口将按implements语句顺序排列，而如果这个类本身就是一个接口，按照extends语句的顺序排列

使用ParseClassFile项目解析VeryUsefulClassFile的接口计数器和接口索引集合，得到如下结果
```
interfaces_count: 3(0x0003)
[0] Class_Interface_Info(0x0071)
class_index: [113(0x0071)]
valueof_class_index: [Constant_Class_Info(0x07012b), tag: [7(0x07)], name_index: [299(0x012b)], valueof_name_index: [Constant_Utf8_Info(0x010014636c61737366696c652f496e7465726661636531), tag: [1(0x01)], length_string: [20(0x0014)], value_string: [classfile/Interface1(0x636c61737366696c652f496e7465726661636531)]]]
valueof_name_index: [Constant_Utf8_Info(0x010014636c61737366696c652f496e7465726661636531), tag: [1(0x01)], length_string: [20(0x0014)], value_string: [classfile/Interface1(0x636c61737366696c652f496e7465726661636531)]]
[1] Class_Interface_Info(0x0072)
class_index: [114(0x0072)]
valueof_class_index: [Constant_Class_Info(0x07012c), tag: [7(0x07)], name_index: [300(0x012c)], valueof_name_index: [Constant_Utf8_Info(0x010014636c61737366696c652f496e7465726661636532), tag: [1(0x01)], length_string: [20(0x0014)], value_string: [classfile/Interface2(0x636c61737366696c652f496e7465726661636532)]]]
valueof_name_index: [Constant_Utf8_Info(0x010014636c61737366696c652f496e7465726661636532), tag: [1(0x01)], length_string: [20(0x0014)], value_string: [classfile/Interface2(0x636c61737366696c652f496e7465726661636532)]]
[2] Class_Interface_Info(0x0073)
class_index: [115(0x0073)]
valueof_class_index: [Constant_Class_Info(0x07012d), tag: [7(0x07)], name_index: [301(0x012d)], valueof_name_index: [Constant_Utf8_Info(0x010014636c61737366696c652f496e7465726661636533), tag: [1(0x01)], length_string: [20(0x0014)], value_string: [classfile/Interface3(0x636c61737366696c652f496e7465726661636533)]]]
valueof_name_index: [Constant_Utf8_Info(0x010014636c61737366696c652f496e7465726661636533), tag: [1(0x01)], length_string: [20(0x0014)], value_string: [classfile/Interface3(0x636c61737366696c652f496e7465726661636533)]]
--------End Class & Interfaces--------
```

### 字段表

字段表（field_info，第12项）用于描述类或者接口中声明的变量，字段包括类级变量和实例级变量，但不包括在方法内部声明的局部变量

#### 字段表计数器

在字段表之前，有一个字段表计数器（fields_count，第11项），用于描述字段的个数，如果没有字段，则计数值为0，后面的字段表也不占任何字节

使用ParseClassFile项目解析VeryUsefulClassFile的字段表计数器，得到如下结果
```
--------Begin Fields--------
fields_count: 41(0x0029)
```

#### 字段表结构

结构如下
|类型|名称|数量|
|--|--|--|
|U2|access_flags|1|
|U2|name_index|1|
|U2|descriptor_index|1|
|U2|attributes_count|1|
|attribute_info|attributes|attributes_count|

可以看出字段表结构还是有些东西的，第一个是访问标志，字段表的访问标志与类的访问标志内容有所不同，下文会提及

第二个是name_index，它是指字段的简单名称，第三个是descriptor_index，它是字段的描述符

简单名称 以及前面所提的 全限定名 含义很好理解，以VeryUsefulClassFile类为例子，classfile/VeryUsefulClassFile就是全限定名，它仅仅是把类全名中的"."替换成了"/"，在使用时一般最后会加一个";"；而简单名称是指没有类型和参数修饰的方法或字段名称，比如public static String string1的简单名称为string1，public VeryUsefulClassFile() throws InterruptedException的简单名称为VeryUsefulClassFile；而描述符的含义，下文会提及

第四个是attributes_count，表示字段表的属性表个数，第五个是attributes，表示字段表的属性表

在类文件中，属性表一共有三种，分别是类属性表、字段表的属性表、方法表的属性表。其中字段表的属性值主要是ConstantValue

使用ParseClassFile项目解析VeryUsefulClassFile的字段表，得到如下结果

例子1
```
[0] Field_Info(0x00000079007a0000)
access_flag: [Field_Access_Flag(0x0000), value: [0(0x0000)], FLAGs: []]
name_index: [121(0x0079)]
valueof_name_index: [Constant_Utf8_Info(0x010008626f6f6c65616e31), tag: [1(0x01)], length_string: [8(0x0008)], value_string: [boolean1(0x626f6f6c65616e31)]]
descriptor_index: [122(0x007a)]
valueof_descriptor_index: [Constant_Utf8_Info(0x0100015a), tag: [1(0x01)], length_string: [1(0x0001)], value_string: [Z(0x5a)]]
attributes_count: [0(0x0000)]
attributes: []
```

例子2
```
[12] Field_Info(0x0000008800890000)
access_flag: [Field_Access_Flag(0x0000), value: [0(0x0000)], FLAGs: []]
name_index: [136(0x0088)]
valueof_name_index: [Constant_Utf8_Info(0x01000673686f727431), tag: [1(0x01)], length_string: [6(0x0006)], value_string: [short1(0x73686f727431)]]
descriptor_index: [137(0x0089)]
valueof_descriptor_index: [Constant_Utf8_Info(0x01000153), tag: [1(0x01)], length_string: [1(0x0001)], value_string: [S(0x53)]]
attributes_count: [0(0x0000)]
attributes: []
```

例子3
```
[20] Field_Info(0x00100092008e0001009300000002009403000003db)
access_flag: [Field_Access_Flag(0x0010), value: [16(0x0010)], FLAGs: [[ACC_FINAL]]]
name_index: [146(0x0092)]
valueof_name_index: [Constant_Utf8_Info(0x010004696e7435), tag: [1(0x01)], length_string: [4(0x0004)], value_string: [int5(0x696e7435)]]
descriptor_index: [142(0x008e)]
valueof_descriptor_index: [Constant_Utf8_Info(0x01000149), tag: [1(0x01)], length_string: [1(0x0001)], value_string: [I(0x49)]]
attributes_count: [1(0x0001)]
attributes: [[Attribute_ConstantValue(0x009300000002009403000003db), name_index: [147(0x0093)], valueof_name_index: [Constant_Utf8_Info(0x01000d436f6e7374616e7456616c7565), tag: [1(0x01)], length_string: [13(0x000d)], value_string: [ConstantValue(0x436f6e7374616e7456616c7565)]], length: [2(0x00000002)], constant_index: [148(0x0094)], valueof_constant_index: [Constant_Integer_Info(0x03000003db), tag: [3(0x03)], value: [987(0x000003db)]], constant_value_clazzs: [[class model.Constant_Long_Info], [class model.Constant_Float_Info], [class model.Constant_Double_Info], [class model.Constant_Integer_Info], [class model.Constant_String_Info]]]]
```

例子1，表示boolean boolean1 = false; 中字段boolean1

例子2，表示short short1 = 12345; 中字段short1

例子3，表示final int int5 = 987; 中字段int5，注意到这个字段是有一个属性值ConstantValue，它表示该字段是由final修饰的，下文会提及

#### 字段表访问标志

|标志名称|标志值|含义|
|--|--|--|
|ACC_PUBLIC|0x0001|字段是否声明为public|
|ACC_PRIVATE|0x0002|字段是否声明为private|
|ACC_PROTECTED|0x0004|字段是否声明为protected|
|ACC_STATIC|0x0008|字段是否声明为static|
|ACC_FINAL|0x0010|字段是否声明为final|
|ACC_VOLATILE|0x0040|字段是否声明为volatile|
|ACC_TRANSIENT|0x0080|字段是否声明为transient|
|ACC_SYNTHETIC|0x1000|字段是否由编译器自动产生的|
|ACC_ENUM|0x4000|字段是否是enum类型|

其中volatile和transient比较陌生，volatile将在第8章JAVA多线程高并发章节中讲解，而transient的一个例子是HashMap，HashMap中定义几个字段时，使用了transient来修饰，这一块将在容器集合章节集中讲解

> volatile修饰一个变量后，编译器产生汇编码中会多出一个lock指令，有两个作用：一是保证线程之间的可见性，二是禁止指令重排徐

> transient修饰一个变量后，当串行化它时，这个变量不会被串行化进去，也就是说，当通过ObjectOutputStream把这个类保存到磁盘上时，实际上这个变量的值是不会保存的，因为当从磁盘中读出这个对象的时候，对象的该变量会没有被赋值

> 后面我对volatile及transient更熟悉后，可能会在这里增加一个HEADER来专门讲解

#### 访问权限修饰符的作用域

来复习一下JAVA中4种访问修饰符的作用域

|修饰符|类内部|同包|子类|其他类|
|--|--|--|--|--|
|public|Y|Y|Y|Y|
|protected|Y|Y|Y|N|
|friendly(default)|Y|Y|N|N|
|private|Y|N|N|N|

Y表示可访问，N表示不可访问

记忆中比较容易混淆的是protected与default在同包和子类中的权限，可以这么记，protected可作用于子类，default可作用于同包，protected权限比default大（p比d大），protected也可以作用于同包

#### 描述符

描述符是用来描述字段的数据类型，方法的参数列表（包括数量、类型、顺序）和返回值

针对8种基本类型、引用类型和void类型，都分别用一个大写字母来表示，称为标识符
- B：byte
- Z：boolean
- C：char
- S：short
- I：int
- F：float
- L：long
- D：double
- L：引用类型
- V：void

对于普通类的字段，基本类型的描述符是 标识符，引用类型描述符是 标识符 + 全限定名，比如
- int int1 => I
- boolean boolean1 => Z
- java.lang.Object object => Ljava/lang/Object

对于数组类的字段，基本类型的描述符是 维度符 + 标识符，引用类型的描述符是 维度符 + 标识符 + 全限定名，比如
- int[] => [I
- java.lang.String[][] => [[Ljava/lang/Object

对于返回值，void类型的描述符是 标识符，即V，其他的描述符与普通类、数组类的字段一致

对于方法，描述符是 ( + 参数描述符拼接 + ) + 返回值描述符，比如
- void inc() => ()V
- String toString() => ()Ljava/lang/String
- int[] getArray(int length) => (I)[I
- int indexof(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) => ([CII[CIII)I

可以看出来，描述符是只记录类型的，不记录名称

### 方法表

方法表（method_info，第14项）用于描述类或者接口中声明的方法

#### 方法表计数器

在方法表之前，有一个方法表计数器（methods_count，第13项），用于描述方法的个数。没有方法的情况下，如果是普通类，方法个数至少为1（init方法），也可能为2（clinit方法）；如果是接口，方法个数为0

使用ParseClassFile项目解析VeryUsefulClassFile的方法表计数器，得到如下结果
```
--------Begin Methods--------
methods_count: 6(0x0006)
```

#### 方法表结构

结构如下
|类型|名称|数量|
|--|--|--|
|U2|access_flags|1|
|U2|name_index|1|
|U2|descriptor_index|1|
|U2|attributes_count|1|
|attribute_info|attributes|attributes_count|

可以看出来，方法表结构与字段表结构是一致的，都包含访问标志、方法的简单名称、方法的描述符、方法表的属性表个数、方法表的属性表。其中方法表的属性表种类繁多，在下文中会提及

使用ParseClassFile项目解析VeryUsefulClassFile的方法表，得到如下结果

例子1
```
[0] Method_Info(0x000100ae00af000200b00000027200040002000001682ab700012a03b500022a04b500032ab20004b60005b500062ab20007b60005b500082a107bb500092a120ab8000bb6000cb5000d2a107fb5000f2a1080b500102a1041b500112a03b500122a1214b500152a03b500162a113039b500172a1218b80019b6001ab5001b2a117fffb5001d2a118000b5001e2a107bb5001f2a1220b500212a1223b500242a1225b500262a1103dbb500272a1228b500292a122ab8002bb6002cb5002d2a122fb500302a1231b500322a140033b500352a140036b500382a1239b8003ab6003bb5003c2a14003eb500402a140041b500432a140044b500462a140047b500492a124ab8004bb6004cb5004d2a14004fb500512a140052b500542abb0055591256b70057b500582abb005959b7005ab2005bb6005c2ab40058b6005cb6005db5005e2abb005f592ab70060b500612a2ab4006104b900620200b500632a2ab40061b900640100b50065140066b80068140069b80068a700084c2bb6006cb100010159015f0162006b000300b1000000be002f000000420004000b0009000c000e000d0018000e002200100028001100340012003a00130040001500460016004b0017005100180056001a005d001b0069001c0070001d0077001f007d00200083002100890022008f002400960026009c002700a8002800ae002900b4002b00bb002c00c2002d00ce002e00d5002f00dc003100e3003200ea003300f6003400fd00350104003801110039012c003b0138003f014600400153004301590045015f004801620046016300470167004900b20000001600020163000400b300b400010000016800b500b6000000b7000000100002ff016200010700b800010700b90400ba00000004000100bb)
access_flag: [Method_Access_Flag(0x0001), value: [1(0x0001)], FLAGs: [[ACC_PUBLIC]]]
name_index: [174(0x00ae)]
valueof_name_index: [Constant_Utf8_Info(0x0100063c696e69743e), tag: [1(0x01)], length_string: [6(0x0006)], value_string: [<init>(0x3c696e69743e)]]
descriptor_index: [175(0x00af)]
valueof_descriptor_index: [Constant_Utf8_Info(0x010003282956), tag: [1(0x01)], length_string: [3(0x0003)], value_string: [()V(0x282956)]]
attributes_count: [2(0x0002)]
attributes: [[Attribute_Code(0x00b0...（太长省略）
```

例子2
```
[3] Method_Info(0x000900c400c5000100b00000003f0001000200000007ba006d00004cb10000000200b10000000a0002000000550006005700b20000001600020000000700c600c700000006000100c800c90001)
access_flag: [Method_Access_Flag(0x0009), value: [9(0x0009)], FLAGs: [[ACC_PUBLIC], [ACC_STATIC]]]
name_index: [196(0x00c4)]
valueof_name_index: [Constant_Utf8_Info(0x0100046d61696e), tag: [1(0x01)], length_string: [4(0x0004)], value_string: [main(0x6d61696e)]]
descriptor_index: [197(0x00c5)]
valueof_descriptor_index: [Constant_Utf8_Info(0x010016285b4c6a6176612f6c616e672f537472696e673b2956), tag: [1(0x01)], length_string: [22(0x0016)], value_string: [([Ljava/lang/String;)V(0x285b4c6a6176612f6c616e672f537472696e673b2956)]]
attributes_count: [1(0x0001)]
attributes: [[Attribute_Code(0x00b00000003f0001000200000007ba006d00004cb10000000200b10000000a0002000000550006005700b20000001600020000000700c600c700000006000100c800c90001), name_index: [176(0x00b0)], valueof_name_index: [Constant_Utf8_Info(0x010004436f6465), tag: [1(0x01)], length_string: [4(0x0004)], value_string: [Code(0x436f6465)]], length: [63(0x0000003f)], max_statck: [1(0x0001)], max_locals: [2(0x0002)], code_length: [7(0x00000007)], code: [ByteCode(0xba006d00004cb1), length: [7], value: []], exception_table_length: [0(0x0000)], exception_table: [], attributes_count: [2(0x0002)], attributes: [[Attribute_LineNumberTable(0x00b10000000a00020000005500060057), name_index: [177(0x00b1)], valueof_name_index: [Constant_Utf8_Info(0x01000f4c696e654e756d6265725461626c65), tag: [1(0x01)], length_string: [15(0x000f)], value_string: [LineNumberTable(0x4c696e654e756d6265725461626c65)]], length: [10(0x0000000a)], table_length: [2(0x0002)], table: [[Line_Number_Info(0x00000055), start_pc: [0(0x0000)], line_number: [85(0x0055)]], [Line_Number_Info(0x00060057), start_pc: [6(0x0006)], line_number: [87(0x0057)]]]], [Attribute_LocalVariableTable(0x00b20000001600020000000700c600c700000006000100c800c90001), name_index: [178(0x00b2)], valueof_name_index: [Constant_Utf8_Info(0x0100124c6f63616c5661726961626c655461626c65), tag: [1(0x01)], length_string: [18(0x0012)], value_string: [LocalVariableTable(0x4c6f63616c5661726961626c655461626c65)]], length: [22(0x00000016)], table_length: [2(0x0002)], table: [[Local_Variable_Info(0x0000000700c600c70000), start_pc: [0(0x0000)], length: [7(0x0007)], name_index: [198(0x00c6)], descriptor_index: [199(0x00c7)], index: [0(0x0000)]], [Local_Variable_Info(0x0006000100c800c90001), start_pc: [6(0x0006)], length: [1(0x0001)], name_index: [200(0x00c8)], descriptor_index: [201(0x00c9)], index: [1(0x0001)]]]]]]]
```

例子3
```
[4] Method_Info(0x100a00ca00af000100b0000000190000000000000001b10000000100b100000006000100000056)
access_flag: [Method_Access_Flag(0x100a), value: [4106(0x100a)], FLAGs: [[ACC_PRIVATE], [ACC_STATIC], [ACC_SYNTHETIC]]]
name_index: [202(0x00ca)]
valueof_name_index: [Constant_Utf8_Info(0x01000d6c616d626461246d61696e2430), tag: [1(0x01)], length_string: [13(0x000d)], value_string: [lambda$main$0(0x6c616d626461246d61696e2430)]]
descriptor_index: [175(0x00af)]
valueof_descriptor_index: [Constant_Utf8_Info(0x010003282956), tag: [1(0x01)], length_string: [3(0x0003)], value_string: [()V(0x282956)]]
attributes_count: [1(0x0001)]
attributes: [[Attribute_Code(0x00b0000000190000000000000001b10000000100b100000006000100000056), name_index: [176(0x00b0)], valueof_name_index: [Constant_Utf8_Info(0x010004436f6465), tag: [1(0x01)], length_string: [4(0x0004)], value_string: [Code(0x436f6465)]], length: [25(0x00000019)], max_statck: [0(0x0000)], max_locals: [0(0x0000)], code_length: [1(0x00000001)], code: [ByteCode(0xb1), length: [1], value: []], exception_table_length: [0(0x0000)], exception_table: [], attributes_count: [1(0x0001)], attributes: [[Attribute_LineNumberTable(0x00b100000006000100000056), name_index: [177(0x00b1)], valueof_name_index: [Constant_Utf8_Info(0x01000f4c696e654e756d6265725461626c65), tag: [1(0x01)], length_string: [15(0x000f)], value_string: [LineNumberTable(0x4c696e654e756d6265725461626c65)]], length: [6(0x00000006)], table_length: [1(0x0001)], table: [[Line_Number_Info(0x00000056), start_pc: [0(0x0000)], line_number: [86(0x0056)]]]]]]]
```

例子4
```
[5] Method_Info(0x000800cb00af000100b00000001e0001000000000006126eb3005bb10000000100b100000006000100000037)
access_flag: [Method_Access_Flag(0x0008), value: [8(0x0008)], FLAGs: [[ACC_STATIC]]]
name_index: [203(0x00cb)]
valueof_name_index: [Constant_Utf8_Info(0x0100083c636c696e69743e), tag: [1(0x01)], length_string: [8(0x0008)], value_string: [<clinit>(0x3c636c696e69743e)]]
descriptor_index: [175(0x00af)]
valueof_descriptor_index: [Constant_Utf8_Info(0x010003282956), tag: [1(0x01)], length_string: [3(0x0003)], value_string: [()V(0x282956)]]
attributes_count: [1(0x0001)]
attributes: [[Attribute_Code(0x00b00000001e0001000000000006126eb3005bb10000000100b100000006000100000037), name_index: [176(0x00b0)], valueof_name_index: [Constant_Utf8_Info(0x010004436f6465), tag: [1(0x01)], length_string: [4(0x0004)], value_string: [Code(0x436f6465)]], length: [30(0x0000001e)], max_statck: [1(0x0001)], max_locals: [0(0x0000)], code_length: [6(0x00000006)], code: [ByteCode(0x126eb3005bb1), length: [6], value: []], exception_table_length: [0(0x0000)], exception_table: [], attributes_count: [1(0x0001)], attributes: [[Attribute_LineNumberTable(0x00b100000006000100000037), name_index: [177(0x00b1)], valueof_name_index: [Constant_Utf8_Info(0x01000f4c696e654e756d6265725461626c65), tag: [1(0x01)], length_string: [15(0x000f)], value_string: [LineNumberTable(0x4c696e654e756d6265725461626c65)]], length: [6(0x00000006)], table_length: [1(0x0001)], table: [[Line_Number_Info(0x00000037), start_pc: [0(0x0000)], line_number: [55(0x0037)]]]]]]]
```

例子1，init方法，下面语句对应的方法，访问标志只有public
```java
    public VeryUsefulClassFile() throws InterruptedException {
        Thread.sleep(100);
        try {
            Thread.sleep(200);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

例子2，main方法，下面语句对应的方法，访问标志有ACC_PUBLIC、ACC_STATIC
```java
    public static void main(String[] args) {
        Runnable x = () -> {
        };
    }
```

例子3，main方法中的lambada表达式方法，访问标志有ACC_PRIVATE、ACC_STATIC、ACC_SYNTHETIC

例子4，clinit方法，类的构造方法，访问标志有ACC_STATIC，字节码如下
```
0 ldc #110 <string1>
2 putstatic #91 <classfile/VeryUsefulClassFile.string1>
5 return
```

#### 方法表访问标志

|标志名称|标志值|含义|
|--|--|--|
|ACC_PUBLIC|0x0001|方法是否声明为public|
|ACC_PRIVATE|0x0002|方法是否声明为private|
|ACC_PROTECTED|0x0004|方法是否声明为protected|
|ACC_STATIC|0x0008|方法是否声明为static|
|ACC_FINAL|0x0010|方法是否声明为final|
|ACC_SYNCHRONIZED|0x0020|方法是否声明为synchronzied|
|ACC_BRIDGE|0x0040|方法是否由编译器产生的桥接方法|
|ACC_VARARGS|0x0080|方法是否接受不定参数|
|ACC_NATIVE|0x0100|方法是否声明为native|
|ACC_ABSTRACT|0x0400|方法是否声明为abstract|
|ACC_STRICTFP|0x0800|方法是否声明为strictfp|
|ACC_SYNTHETIC|0x1000|方法是否由编译器自动产生的|

其中synchronzied和strictfp比较陌生，synchronzied将在第8章JAVA多线程高并发章节中讲解，strictfp与前面所讲的IEEE754有关系

> synchonzied修饰一个方法时，方法的字节码中会多出两个字节码指令：monitorenter和monitorexit，分别用于加锁和解锁，当一个线程在调用该方法时，其他线程必须等待

> strictfp 关键字可应用于类、接口或方法。使用 strictfp 关键字声明一个方法时，该方法中所有的 float 和 double 表达式都严格遵守 FP-strict 的限制，符合 IEEE-754 规范。当对一个类或接口使用 strictfp 关键字时，该类中的所有代码，包括嵌套类型中的初始设定值和代码，都将严格地进行计算。严格约束意味着所有表达式的结果都必须是 IEEE-754 算法对操作数预期的结果，以单精度和双精度格式表示

> 后面我对synchronzied及strictfp更熟悉后，可能会在这里增加一个HEADER来专门讲解

#### 重写与重载

> 对很多JAVA有基础的程序员来说，方法重载与重写似乎是一个“很熟悉”的概念，因为在写代码过程中会经常遇到，比如重写toString()方法，子类继承父类重写父类方法等

> 但我仔细查了资料后，觉得事情没那么简单，还是有不少概念细节规则需要整理的，因此借此机会复习下

> 其中的许多概念参考于 [Java重写(Override)与重载(Overload)](https://www.runoob.com/java/java-override-overload.html)

重写（Override）是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变，即外壳不变，内容重写

重写例子
```java
package com.peter.jvm.example;

class Animal{
    public void move(){
        System.out.println("动物可以移动");
    }
}

class Dog extends Animal{
    public void move(){
        System.out.println("狗可以跑和走");
    }
}

public class TestDog{
    public static void main(String args[]){
        Animal b = new Dog();
        b.move();
    }
}
```

其中Dog类move方法就重写了Animal类的move方法

重写的规则
- 构造方法不能被重写
- 父类的成员方法只能被它的子类重写
- 从访问修饰符来看，若子类和父类在同一个包中，子类可以重写父类声明为 public、protected、default 的方法，若子类和父类不在同一个包中，子类可以重写父类声明为 public、protected 的方法
- 声明为 final 的方法不能被重写
- 声明为 static 的方法不能被重写，但是能够被再次声明
- 重写方法的访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected
- 重写方法的参数列表与被重写方法的参数列表必须完全相同
- 重写方法的返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以

最后一个规则举个例子

下面是OK的
```java
class TEE1 extends TEE2 {
    void a()  {
    }
}

class TEE2 {
    void a() throws IOException {
    }
}
```

下面是编译不过的
```java
class TEE1 extends TEE2 {
    // 'a()' in 'com.peter.jvm.example.TEE1' clashes with 'a()' in 'com.peter.jvm.example.TEE2'; overridden method does not throw 'java.lang.Exception'
    void a() throws Exception {
    }
}

class TEE2 {
    void a() throws IOException {
    }
}
```

重载（Overload）是在一个类或父子类中，两个方法名字相同但参数不同，返回类型可以相同也可以不同

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表，最常用的地方就是构造器的重载

重载例子
```java
package com.peter.jvm.example;

class Animal{
    public void move(){
        System.out.println("动物可以移动");
    }
}

class Dog extends Animal{
    public void move() {
        System.out.println("狗可以跑和走");
    }
    public void move(int a) {
    }
}

public class TestDog{
    public static void main(String args[]){
        Animal b = new Dog();
        b.move();
    }
}
```

其中Dog类move(int a)方法就是重载了Dog类的move()方法和Animial类的move()方法，而两个类的move()方法之间只是重写，不是重载

重载规则
- 被重载的方法必须改变参数列表（参数个数或类型或顺序不一样）
- 被重载的方法可以改变返回类型
- 被重载的方法可以改变访问修饰符
- 被重载的方法可以声明新的或更广的检查异常
- 方法能够在同一个类中或者在一个子类中被重载
- 无法以返回值类型作为重载函数的区分标准

#### clinit与init

个人认为，理解clinit与init方法是JAVA程序员水平提升的一个标志，初学JAVA的程序员，可能最多只知道init方法，因为init方法会显示的出现在类中，程序员可以创建它，但clinit方法是隐式的

init方法是指类的初始化方法，clinit是指类的构造器方法，拿一个例子来说明即可

```java
package com.peter.jvm.example;

public class InitClinit {

    static int a = 1;

    static {
        System.out.println(a);
        a = 2;
    }

    {
        System.out.println(a);
        a = 3;
    }

    InitClinit(int x) {
        System.out.println(a);
        a = x;
    }

    InitClinit() {
        a = 6;
    }

    public static void main(String[] args) {
        InitClinit ic = new InitClinit(5);
        System.out.println(ic.a);
    }

    static {
        System.out.println(a);
    }
    
    {
        System.out.println(a);
        a = 4;
    }
}
```

输出结果
```
1
2
2
3
4
5
```

关于输出结果的详细讲解，在第1章类加载机制最后节中有专门总结，这边进行下简单讲解
- main方法所在的类InitClinit会先进行类加载
- 类加载会执行clinit方法，按照代码书写顺序，从上往下依次给static变量赋值、执行static代码块
- 先a=1，再执行第一块static代码块，输出1，a=2，再执行第二块代码块，输出2
- 然后执行main方法
- 执行new字节码，由于InitClinit已经加载，不再加载，实例化一个对象
- 实例化过程中，会先执行完全部构造代码块，再执行构造方法
- 执行第一块构造代码块，输出2，a=3，再执行第二块构造代码块，输出3，a=4
- 执行构造方法，此时形参x是5，输出4，a=5
- 执行main方法中的println函数，输出5

上面的例子可能略显复杂了，不过相信理解了之后，就能代表理解了init与clinit

现在我们来看一下字节码

clinit方法的字节码
```
 0 iconst_1
 1 putstatic #3 <com/peter/jvm/example/InitClinit.a>
 4 getstatic #2 <java/lang/System.out>
 7 getstatic #3 <com/peter/jvm/example/InitClinit.a>
10 invokevirtual #4 <java/io/PrintStream.println>
13 iconst_2
14 putstatic #3 <com/peter/jvm/example/InitClinit.a>
17 getstatic #2 <java/lang/System.out>
20 getstatic #3 <com/peter/jvm/example/InitClinit.a>
23 invokevirtual #4 <java/io/PrintStream.println>
26 return
```

可以看出，clinit方法是按照代码执行顺序，将对静态变量赋值、执行静态代码块语句合并起来的

init方法有两个，一个是InitClinit(int x)，一个是InitClinit()

第一init方法字节码
```
 0 aload_0
 1 invokespecial #1 <java/lang/Object.<init>>
 4 getstatic #2 <java/lang/System.out>
 7 getstatic #3 <com/peter/jvm/example/InitClinit.a>
10 invokevirtual #4 <java/io/PrintStream.println>
13 iconst_3
14 putstatic #3 <com/peter/jvm/example/InitClinit.a>
17 getstatic #2 <java/lang/System.out>
20 getstatic #3 <com/peter/jvm/example/InitClinit.a>
23 invokevirtual #4 <java/io/PrintStream.println>
26 iload_1
27 putstatic #3 <com/peter/jvm/example/InitClinit.a>
30 return
```

第二个init方法字节码
```
 0 aload_0
 1 invokespecial #1 <java/lang/Object.<init>>
 4 getstatic #2 <java/lang/System.out>
 7 getstatic #3 <com/peter/jvm/example/InitClinit.a>
10 invokevirtual #4 <java/io/PrintStream.println>
13 iconst_3
14 putstatic #3 <com/peter/jvm/example/InitClinit.a>
17 iconst_5
18 putstatic #3 <com/peter/jvm/example/InitClinit.a>
21 return
```

可以看出，每一个init方法，都会先执行父类的构造方法，然后按照代码书写顺序，将构造代码块合并起来，放在最上面执行，然后在执行方法内的语句

对于init方法，再多提几点
- 如果类（不算接口）没有实现构造方法，编译时也会默认有一个init方法出现，接口不会
- init方法中，会先执行父类的init方法
- java.lang.Object类，也有init方法，字节码就一行：0 return

### 属性表

好，又到了一个复杂的项目了，属性表种类比常量池还要多，JDK8中就至少有23个，JDK11中至少有28个

最令人头疼的是，属性表中每一种属性几乎结构都不一样，而且还有复合型的结构，有的属性表是类的，有的是字段表、方法表的，甚至有的是某个属性表的属性表

我依然打算采用写常量池的方法：点到为止。只列举重要的属性表项

#### 属性表计数器

在类属性表前，有一个属性表计数器（attributes_count，第15项），字段表的属性表、方法表的属性表、Code属性的属性表前也有，用于描述属性表的个数，若没有属性表项，则计数值为0，后面的属性表也不占任何字节

使用ParseClassFile项目解析VeryUsefulClassFile的类属性表计数器，得到如下结果
```
--------Begin Attributes--------
attributes_count: 4(0x0004)
```

#### 属性表通用结构

所有的属性表，都可以使用一个简单、通用的结构来表达

|类型|名称|数量|
|--|--|--|
|U2|attribute_name_index|1|
|U4|attribute_length|1|
|U1|info|attribute_length|

这个结构甚至太简单了，也就是说，每个属性表都有 attribute_name_index 和 attribute_length

attribute_name_index表示属性名，是一个指向常量池项的索引，它指向一个Constant_Utf8_info常量池项

attribute_length表示属性表占字节数，也就是说后面所定义的info，需要占attribute_length个字节数

#### 全部属性表项

我不防先将全部属性表项列出来，只列它们的名称、使用位置、含义，不列具体结构。这里可能列不全，参考《深入理解JAVA虚拟机》所列的

|属性名称|使用位置|含义|
|--|--|--|
|Code|方法表|Java代码编译成的字节码指令|
|ConstantValue|字段表|final关键字定义的常量值|
|Deprecated|类、方法表、字段表|被声明为deprecated的方法和字段|
|Exceptions|方法表|方法抛出的异常|
|EnclosingMethod|类|仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法|
|InnerClasses|类|内部类列表|
|LineNumberTable|Code属性|Java源码的行号与字节码指令的对应关系|
|LocalVariableTable|Code属性|方法的局部变量描述|
|StackMapTable|Code属性|JDK6中新增的属性，供新的类型检查验证器（Type Checker）检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配|
|Singature|类、方法表、字段表|JDK5中所新增的属性，这个属性用于支持泛型情况下的方法签名，在Java计中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息|
|SourceFile|类文件|记录源文件名称|
|SourceDebugExtension|类文件|JDK6中新增的属性，SouceDebugExtension属性用于存储额外的调试信息。譬如在进行JSP文件调试时，无法通过Java堆栈来定位到JSP文件的行号，JSR-45规范为这些非Java语言编写，却需要编译成字节码并运行在Java虚拟机中的程序提供了一个进行调试的机制标准，使用SourceDebugExtension属性就可以用于存储这个标准所新加入的调试信息|
|Synthetic|类、方法、字段表|标识方法或字段为编译器自动生成的|
|LocalVariableTypeTable|类|JDK5中新增的属性，它使用特征签名代表描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加|
|RuntimeVisibleAnnotions|类、方法表、字段表|JDK5中新增的属性，为动态注解提供支持。RuntimeVisibleAnnotions属性用于指明哪些注解是运行的（实际上运行时就是进行反射调用）可见的|
|RuntimeInvisibleAnnotions|类、方法表、字段表|JDK5中新增的属性，与RuntimeVisibleAnnotions属性作用刚好相反，用于指明哪些注解是运行时不可见的|
|RuntimeVisibleParameterAnnotations|方法表|JDK5中新增的属性，作用与RuntimeVisibleAnnotions属性类似，只不过作用对象为方法参数|
|RuntimeInvisibleParameterAnnotations|方法表|JDK5中新增的属性，作用与RuntimeInvisibleAnnotions属性类似，只不过作用对象为方法参数|
|AnnotationDefault|方法表|JDK5中新增的属性，用于记录注解类元素的默认值|
|BootstapMethods|类文件|JDK7中新增的属性，用于保存invokedynamic指令引用的引导方法限定符|
|RuntimeVisibleTypeAnnotions|类、字段表、方法表、Code属性|JDK8中新增的属性，为实现JSR308中新增的类型注解提供的支持，用于指明哪些类注解是运行时（实际上运行时就是进行反射调用）可见的|
|RuntimeInvisibleTypeAnnotions|类、字段表、方法表、Code属性|JDK8中新增的属性，为实现JSR308中新增的类型注解提供的支持，与RuntimeVisibleTypeAnnotations属性作用刚好相反，用于指明哪些注解是运行时不可见的|
|MethodParameters|方法表|JDK8中新增的属性，用于支持（编译时加上-parameters参数）将方法名称编译进Class文件中，并可运行时获取。此前要获取方法名称（典型的如IDE的代码提示）只能通过JavaDoc中得到|

#### Code

Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性方法出现在方法表的属性集合中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性

关于字节码指令，我专门开了一章，见：[字节码指令](字节码指令.md)

结构如下
|类型|名称|数量|
|--|--|--|
|U2|attribute_name_index|1|
|U4|attribute_length|1|
|U2|max_stack|1|
|U2|max_locals|1|
|U4|code_length|1|
|U1|code|code_length|
|U2|exception_table_length|1|
|exception_info|exception_table|exception_table_length|
|U2|attributes_count|1|
|attribute_info|attributes|attributes_count|

attribute_name_index是一项指向Constant_Utf8_info型常量的索引，常量值固定为“Code”，它代表了该属性的属性名称

attribute_length指示了属性值所占字节码数，不包括 attribute_name_index 和 attribute_length 所占的字节数

max_stack代表了操作数栈（Operand Stacks）深度的最大值，在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候，需要根据这个值来分配栈帧（Stack Frame）中操作栈的深度

max_locals代表了局部变量表所需的存储空间，在这里，max_locals的单位是Slot，Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放。方法参数（包括实例方法中的隐藏参数“this”）、显示异常处理器的参数（Exception Handler Parameter，就是try-catch语句种catch块所定义的异常）、方法体中定义的局部变量，都需要使用局部变量表来存放。另外，并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用的，Jaavac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小

code_length和code用来存储Java源程序编译后生成的字节码指令，code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那么每个指令就是一个U1类型的单字节，当虚拟机读到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。一个U1类型的数据表示范围是0x00 ~ 0xFF，即0 ~ 255，最多可以表达256个指令。另外，code_length是一个U4类型的参数，理论上最大值可以达到2^32-1，但虚拟机规范中明确规定了一个方法不允许超过65535条字节码指令，即它实际只使用了U2的长度，如果超过这个限制，Javac编译器会拒绝编译

code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，code属性用于描述代码，所有的其他数据项目都用于描述元数据

使用ParseClassFile项目解析VeryUsefulClassFile的Code属性，得到如下结果
```
[3] Method_Info(0x000900c400c5000100b00000003f0001000200000007ba006d00004cb10000000200b10000000a0002000000550006005700b20000001600020000000700c600c700000006000100c800c90001)
access_flag: [Method_Access_Flag(0x0009), value: [9(0x0009)], FLAGs: [[ACC_PUBLIC], [ACC_STATIC]]]
name_index: [196(0x00c4)]
valueof_name_index: [Constant_Utf8_Info(0x0100046d61696e), tag: [1(0x01)], length_string: [4(0x0004)], value_string: [main(0x6d61696e)]]
descriptor_index: [197(0x00c5)]
valueof_descriptor_index: [Constant_Utf8_Info(0x010016285b4c6a6176612f6c616e672f537472696e673b2956), tag: [1(0x01)], length_string: [22(0x0016)], value_string: [([Ljava/lang/String;)V(0x285b4c6a6176612f6c616e672f537472696e673b2956)]]
attributes_count: [1(0x0001)]
attributes: [[Attribute_Code(0x00b00000003f0001000200000007ba006d00004cb10000000200b10000000a0002000000550006005700b20000001600020000000700c600c700000006000100c800c90001), name_index: [176(0x00b0)], valueof_name_index: [Constant_Utf8_Info(0x010004436f6465), tag: [1(0x01)], length_string: [4(0x0004)], value_string: [Code(0x436f6465)]], length: [63(0x0000003f)], max_statck: [1(0x0001)], max_locals: [2(0x0002)], code_length: [7(0x00000007)], code: [ByteCode(0xba006d00004cb1), length: [7], value: []], exception_table_length: [0(0x0000)], exception_table: [], attributes_count: [2(0x0002)], attributes: [[...（太长省略）
```

这是main方法的code属性，main方法的字节码如下

```
0 invokedynamic #109 <run, BootstrapMethods #0>
5 astore_1
6 return
```

而code属性中code是0xba006d00004cb1，现在我们来解析下它
- 0xba是186，对应字节码指令是invokedynamic，它带两个参数
- 0x006d是109，是invokedynamic的第一个参数，对应的是第109个常量池项，Constant_InvokeDynamic_Info表示一个动态方法调用点
```
[109] Constant_InvokeDynamic_Info(0x1200000128)
tag: [18(0x12)]
index_bootstrap_methods: [0(0x0000)]
name_and_type_index: [296(0x0128)]
valueof_name_and_type_index: [Constant_NameAndType_Info(0x0c01520153), tag: [12(0x0c)], name_index: [338(0x0152)], valueof_name_index: [Constant_Utf8_Info(0x01000372756e), tag: [1(0x01)], length_string: [3(0x0003)], value_string: [run(0x72756e)]], descriptor_index: [339(0x0153)], valueof_descriptor_index: [Constant_Utf8_Info(0x01001628294c6a6176612f6c616e672f52756e6e61626c653b), tag: [1(0x01)], length_string: [22(0x0016)], value_string: [()Ljava/lang/Runnable;(0x28294c6a6176612f6c616e672f52756e6e61626c653b)]]]
```
- 0x000是0，是invokedynamic的第二个参数
- 0x4c是76，对应字节码指令是astore_1，没有参数
- 0xb1是177，对应字节码是return，没有参数

exception_table_length表示异常处理表的长度

exception_table表示异常处理表，它主要描述代码中try-catch-finally语句的逻辑，结构如下
|类型|名称|数量|
|--|--|--|
|U2|start_pc|1|
|U2|end_pc|1|
|U2|handler_pc|1|
|U2|catch_type|1|

code属性也有属性表，属性表中会可能存在LineNumberTable、LineVariableTable、StackMapTable、RuntimeVisibleTypeAnnotions、RuntimeInvisibleTypeAnnotions

attributes_count是code属性的属性表计数器，attributes是code属性表的属性表

#### Exceptions

结构如下
|类型|名称|数量|
|--|--|--|
|U2|attribute_name_index|1|
|U4|attribute_legnth|1|
|U2|number_of_exceptions|1|
|U2[]|exception_index_table|number_of_exceptions|

number_of_exceptions表示有多少个异常

exception_index_table是一个索引表，每个索引指向常量池中的一个Constant_Class_info项，表示异常的类

这里的Exceptions属性是在方法表中与Code属性平级的一项属性，这里容易与Code属性中的exception_table中混淆，这里进行下解释

Exceptions属性用于描述方法声明时的throws语句，Code属性中的exception_table用于描述代码中try-catch-finally语句的逻辑

来看下代码例子
```java
package com.peter.jvm.example;

public class ExceptionsAndExceptionTable {

    public static void main(String[] args) {
        try {
            sleep();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println("done");
        }
    }

    public static void sleep() throws InterruptedException {
        Thread.sleep(1000);
    }
}
```

main方法字节码
```
 0 invokestatic #2 <com/peter/jvm/example/ExceptionsAndExceptionTable.sleep>
 3 getstatic #3 <java/lang/System.out>
 6 ldc #4 <done>
 8 invokevirtual #5 <java/io/PrintStream.println>
11 goto 41 (+30)
14 astore_1
15 aload_1
16 invokevirtual #7 <java/lang/InterruptedException.printStackTrace>
19 getstatic #3 <java/lang/System.out>
22 ldc #4 <done>
24 invokevirtual #5 <java/io/PrintStream.println>
27 goto 41 (+14)
30 astore_2
31 getstatic #3 <java/lang/System.out>
34 ldc #4 <done>
36 invokevirtual #5 <java/io/PrintStream.println>
39 aload_2
40 athrow
41 return
```

main方法的code属性中，含有exception_table
![image](https://user-images.githubusercontent.com/10209135/95879148-9925f300-0da8-11eb-9fb3-6acc53af269d.png)

exception_table的含义是
- 0到2行（try语句块）若有jaga.lang.InterruptedException异常，跳到第14行处理，执行catch语句块
- 0到2行（try语句块）若有其他异常，跳到第30行处理，执行finally语句块，然后到40行throw异常
- 14到18行（catch语句块）若有任何异常，跳到第30行处理，执行finally语句块，然后到40行throw异常
- try语句块若无异常，会执行finally语句块，到11行，goto到41行，return
- catch语句块若无异常，会执行finally语句块，到27行，goto到41行，return

sleep方法字节码
```
0 ldc2_w #8 <1000>
3 invokestatic #10 <java/lang/Thread.sleep>
6 return
```

使用ParseClassFile项目解析sleep方法，得到如下结果
```
[2] Method_Info(0x0009001d000e0002000f000000230002000000000007140008b8000ab10000000100100000000a00020000001000060011001e0000000400010006)
access_flag: [Method_Access_Flag(0x0009), value: [9(0x0009)], FLAGs: [[ACC_PUBLIC], [ACC_STATIC]]]
name_index: [29(0x001d)]
valueof_name_index: [Constant_Utf8_Info(0x010005736c656570), tag: [1(0x01)], length_string: [5(0x0005)], value_string: [sleep(0x736c656570)]]
descriptor_index: [14(0x000e)]
valueof_descriptor_index: [Constant_Utf8_Info(0x010003282956), tag: [1(0x01)], length_string: [3(0x0003)], value_string: [()V(0x282956)]]
attributes_count: [2(0x0002)]
attributes: [[Attribute_Code(0x000f000000230002000000000007140008b8000ab10000000100100000000a00020000001000060011), name_index: [15(0x000f)], valueof_name_index: [Constant_Utf8_Info(0x010004436f6465), tag: [1(0x01)], length_string: [4(0x0004)], value_string: [Code(0x436f6465)]], length: [35(0x00000023)], max_statck: [2(0x0002)], max_locals: [0(0x0000)], code_length: [7(0x00000007)], code: [ByteCode(0x140008b8000ab1), length: [7], value: []], exception_table_length: [0(0x0000)], exception_table: [], attributes_count: [1(0x0001)], attributes: [[Attribute_LineNumberTable(0x00100000000a00020000001000060011), name_index: [16(0x0010)], valueof_name_index: [Constant_Utf8_Info(0x01000f4c696e654e756d6265725461626c65), tag: [1(0x01)], length_string: [15(0x000f)], value_string: [LineNumberTable(0x4c696e654e756d6265725461626c65)]], length: [10(0x0000000a)], table_length: [2(0x0002)], table: [[Line_Number_Info(0x00000010), start_pc: [0(0x0000)], line_number: [16(0x0010)]], [Line_Number_Info(0x00060011), start_pc: [6(0x0006)], line_number: [17(0x0011)]]]]]], [Attribute_Exceptions(0x001e0000000400010006), name_index: [30(0x001e)], valueof_name_index: [Constant_Utf8_Info(0x01000a457863657074696f6e73), tag: [1(0x01)], length_string: [10(0x000a)], value_string: [Exceptions(0x457863657074696f6e73)]], length: [4(0x00000004)], number_of_exceptions: [1(0x0001)], exception_index_table: [[6(0x0006)]]]]
```

number_of_exceptions是1，exception_index_table中有一个值，是6，它指向第6个常量池项，是一个Constant_Class_info，表示java.lang.InterruptedException类
```
[6] Constant_Class_Info(0x070028)
tag: [7(0x07)]
name_index: [40(0x0028)]
valueof_name_index: [Constant_Utf8_Info(0x01001e6a6176612f6c616e672f496e746572727570746564457863657074696f6e), tag: [1(0x01)], length_string: [30(0x001e)], value_string: [java/lang/InterruptedException(0x6a6176612f6c616e672f496e746572727570746564457863657074696f6e)]]
```

#### try-catch-finally语句逻辑

这一块，也是属于JAVA程序员可能以为“很清楚”的，但实际不太清楚的部分

来看一个例子
```java
package com.peter.jvm.example;

import java.util.ArrayList;
import java.util.List;

public class TryCatchExceptionDemo {

    static class T1 {
        int a;
        public T1(int a) {
            this.a = a;
        }
    }

    public T1 test1() {
        T1 t;
        try {
            t = new T1(1);
            return t;
        } catch (Exception e) {
            t = new T1(2);
            return t;
        } finally {
            t = new T1(3);
        }
    }

    public T1 test2() {
        T1 t;
        try {
            t = new T1(1);
            return t;
        } catch (Exception e) {
            t = new T1(2);
            return t;
        } finally {
            t = new T1(3);
            return t;
        }
    }

    public T1 test3() {
        T1 t;
        try {
            t = new T1(1);
            throw new Throwable();
        } catch (Exception e) {
            t = new T1(2);
            return t;
        } finally {
            t = new T1(3);
            return t;
        }
    }

    public List<Integer> test4() {
        List<Integer> x = new ArrayList<>();
        try {
            x.add(1);
            return x;
        } catch (Exception e) {
            x.add(2);
            return x;
        } finally {
            x.add(3);
        }
    }

    public static void main(String[] args) {
        TryCatchExceptionDemo demo = new TryCatchExceptionDemo();
        System.out.println(demo.test1().a);
        System.out.println(demo.test2().a);
        System.out.println(demo.test3().a);
        System.out.println(demo.test4());
    }
}
```

输出结果
```
1
3
3
[1, 3]
```

test1方法字节码
```
 0 new #2 <com/peter/jvm/example/TryCatchExceptionDemo$T1>
 3 dup
 4 iconst_1
 5 invokespecial #3 <com/peter/jvm/example/TryCatchExceptionDemo$T1.<init>>
 8 astore_1
 9 aload_1
10 astore_2
11 new #2 <com/peter/jvm/example/TryCatchExceptionDemo$T1>
14 dup
15 iconst_3
16 invokespecial #3 <com/peter/jvm/example/TryCatchExceptionDemo$T1.<init>>
19 astore_1
20 aload_2
21 areturn
22 astore_2
23 new #2 <com/peter/jvm/example/TryCatchExceptionDemo$T1>
26 dup
27 iconst_2
28 invokespecial #3 <com/peter/jvm/example/TryCatchExceptionDemo$T1.<init>>
31 astore_1
32 aload_1
33 astore_3
34 new #2 <com/peter/jvm/example/TryCatchExceptionDemo$T1>
37 dup
38 iconst_3
39 invokespecial #3 <com/peter/jvm/example/TryCatchExceptionDemo$T1.<init>>
42 astore_1
43 aload_3
44 areturn
45 astore 4
47 new #2 <com/peter/jvm/example/TryCatchExceptionDemo$T1>
50 dup
51 iconst_3
52 invokespecial #3 <com/peter/jvm/example/TryCatchExceptionDemo$T1.<init>>
55 astore_1
56 aload 4
58 athrow
```

test1方法的exception_table
![image](https://user-images.githubusercontent.com/10209135/95885028-5e738900-0daf-11eb-9c07-76edf642182d.png)


#### ConstantValue

#### InnerClasses


