- [类文件结构](#类文件结构)
  - [类文件的定义](#类文件的定义)
  - [类文件的数据紧凑性](#类文件的数据紧凑性)
  - [类文件的结构轮廓](#类文件的结构轮廓)
  - [无符号数与表](#无符号数与表)
  - [类文件例子](#类文件例子)
  - [魔数](#魔数)
  - [版本号](#版本号)
  - [常量池](#常量池)
    - [常量池的定义](#常量池的定义)
    - [常量池的结构轮廓](#常量池的结构轮廓)
    - [CONSTANT_Utf8_info](#CONSTANT_Utf8_info)
    - [CONSTANT_Integer_info](#CONSTANT_Integer_info)
    - [CONSTANT_Float_info](#CONSTANT_Float_info)
    - [CONSTANT_Long_info](#CONSTANT_Long_info)
    - [CONSTANT_Double_info](#CONSTANT_Double_info)
    - [CONSTANT_Class_info](#CONSTANT_Class_info)
    - [CONSTANT_String_info](#CONSTANT_String_info)
    - [CONSTANT_Fieldref_info](#CONSTANT_Fieldref_info)
    - [CONSTANT_Methodref_info](#CONSTANT_Methodref_info)
    - [CONSTANT_InterfaceMethodref_info](#CONSTANT_InterfaceMethodref_info)
    - [CONSTANT_NameAndType_info](#CONSTANT_NameAndType_info)
    - [CONSTANT_MethodHandle_info](#CONSTANT_MethodHandle_info)
    - [CONSTANT_MethodType_info](#CONSTANT_MethodType_info)
    - [CONSTANT_InvokeDynamic_info](#CONSTANT_InvokeDynamic_info)

# 类文件结构

> 终于开始类文件结构章节的书写了，为了写这一篇章节，我花了至少7天的时间完成了一个ParseClassFile项目，项目链接：https://github.com/peteryuanpan/ParseClassFile 。刚刚写完了这个项目的介绍文档，它的核心功能，是读入一份类文件，将每一个字节的含义按照特有的格式输出。对该项目感兴趣的朋友，可以进去看看文档和源码，我也非常建议结合两份文档一起来阅读，单独阅读本文章肯定是枯燥乏味的，解析类文件过程就是这样，无法避免

> 我将会在文章中以类文件为具体例子，介绍类文件的组成部分，还会穿插JavaSE中的基础问题、面试问题等

> 在准备的过程中，我发现一个点，解析类文件结构，实际上是对JAVA语法更深入的理解，比如try catch语句、throws Exception语句，它们对应类文件的哪一个部分，具体内容是什么，比如float和double分别是4个字节和8个字节，但表示的数字范围很大，浮点表示法的原理是什么，比如一个方法完整有哪些组成部分等等。所以，在书写文章的过程中，我不仅会逐一介绍类文件结构的组成部分，还会穿插着JavaSE中的基础问题、面试问题

> 多提一点，这里并不涉及到字节码指令（非指Java字节码），字节码指令只是方法表中的一个属性Attribute_Code而已，关于字节码我们会在 [字节码指令](字节码指令.md) 章节中讲解

> 需要说清楚一点，Java bytecode直译是Java字节码，但我认为不准确，更准确的翻译是二进制字节流。JAVA虚拟机定义是一种能够运行Java字节码程序的虚拟机器，这里的Java字节码是广义的指二进制字节流，而狭义的是指字节码指令。二进制字节流包括类文件，虚拟机加载的一般是类文件，不是只加载字节码指令。字节码指令是指描述Java语句的指令，主要存在于方法表中，它只是类文件的一部分，比如new、putstatic、getstatic这些指令

### 类文件的定义

类文件是一种可以被虚拟机执行的包含了字节码数据的文件；Java类文件通常被Javac编译器从JAVA源文件编译而来，同时，其他语言也可以编译成类文件，比如Jython，Scala，Kotlin

> A Java class file is a file (with the .class filename extension) containing Java bytecode that can be executed on the Java Virtual Machine (JVM). A Java class file is usually produced by a Java compiler from Java programming language source files (.java files) containing Java classes (alternatively, other JVM languages can also be used to create class files).

在类加载这一章节中，我们已经说的比较清楚了，类文件无关乎从哪个语言而来，无关乎在哪里存储，准确的说，它是一组二进制字节流

### 类文件的数据紧凑性

Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在

当遇到需要占用8位字节以上空间的数据项时，会按照高位在前（Big-Endian）的方式分割成若干个8位字节进行存储

> Big-Edian，也称为大端，具体是指最高位字节在地址最低位、最低位字节在地址最高位的顺序来存储数据，它是SPARC、PowerPC等处理器的默认多字节存储顺序，而x86等处理器则是使用了相反的“Little-Endian”顺序来存储数据，Little-Endian称为小端

> 其实我个人认为，不需要去纠结大端小端，你知道怎么读数据就好了，否则容易把自己弄晕，后面例子中若有超过8位字节的数据，会关联说明一下大端和小端

### 类文件的结构轮廓

类文件的结构轮廓（Layout）有16个元素，分别如下

|序号|类型|名称|数量|
|--|--|--|--|
|1|U4|magic|1|
|2|U2|minor_version|1|
|3|U2|major_version|1|
|4|U2|costant_pool_count|1|
|5|cp_info|costant_pool|costant_pool_count - 1|
|6|U2|access_flags|1|
|7|U2|this_class|1|
|8|U2|super_class|1|
|9|U2|interfaces_count|1|
|10|U2|interfaces|interfaces_count|
|11|U2|fields_count|1|
|12|field_info|field|fields_count|
|13|U2|methods_count|1|
|14|method_info|method|methods_count|
|15|U2|attributes_count|1|
|16|attribute_info|attributes|attributes_count|

其中类型中含有U1、U2、U4、U8四种，它们是无符号数，除了无符号数外，剩下都称之为表，表是一种复合型数据类型

可以看出，类文件结构轮廓中有4项属于表，分别是constant_pool、fields、methods、attributes，其他都是无符号数

### 无符号数与表

根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要以这两种数据类型为基础

无符号数属于基本的数据类型，以U1、U2、U4、U8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数

无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值

表是由多个无符号数或者其他表作为数据项构成的复合数据类型

表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表

### 类文件例子

我们举2个类文件例子，用于以后篇幅的说明解释

#### VerySimpleClassFile

第一份是非常简单的程序，这个Java程序够简单了吧，表面看上去它几乎什么都没有，就一个package和class信息

VerySimpleClassFile.java
```java
package classfile;

public class VerySimpleClassFile {
}
```

它class文件如下

VerySimpleClassFile.class
```
cafe babe 0000 0034 000d 0a00 0300 0a07
000b 0700 0c01 0006 3c69 6e69 743e 0100
0328 2956 0100 0443 6f64 6501 000f 4c69
6e65 4e75 6d62 6572 5461 626c 6501 000a
536f 7572 6365 4669 6c65 0100 1856 6572
7953 696d 706c 6543 6c61 7373 4669 6c65
2e6a 6176 610c 0004 0005 0100 1d63 6c61
7373 6669 6c65 2f56 6572 7953 696d 706c
6543 6c61 7373 4669 6c65 0100 106a 6176
612f 6c61 6e67 2f4f 626a 6563 7400 2100
0200 0300 0000 0000 0100 0100 0400 0500
0100 0600 0000 1d00 0100 0100 0000 052a
b700 01b1 0000 0001 0007 0000 0006 0001
0000 0003 0001 0008 0000 0002 0009 
```

#### VeryUsefulClassFile

这份文件会有一些长度，但非常有用，包括了

VeryUsefulClassFile.java
```java
package classfile;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Orange(getName = "3333",getValue = "4444")
public class VeryUsefulClassFile implements Interface1, Interface2, Interface3 {

    boolean boolean1 = false;
    boolean boolean2 = true;
    boolean boolean3 = Boolean.FALSE;
    boolean boolean4 = Boolean.TRUE;

    byte byte1 = 123;
    byte byte2 = Byte.valueOf("12345");
    byte byte3 = Byte.MAX_VALUE;
    byte byte4 = Byte.MIN_VALUE;

    char char1 = 'A';
    char char2 = '\0';
    char char3 = Character.MAX_VALUE;
    char char4 = Character.MIN_VALUE;

    short short1 = 12345;
    short short2 = Short.valueOf("123456");
    short short3 = Short.MAX_VALUE;
    short short4 = Short.MIN_VALUE;

    int int1 = 123;
    int int2 = 123456789;
    int int3 = Integer.MAX_VALUE;
    int int4 = Integer.MIN_VALUE;

    final int int5 = 987;

    float float1 = 100;
    float float2 = Float.valueOf("1234567");
    float float3 = Float.MAX_VALUE;
    float float4 = Float.MIN_VALUE;

    long long1 = 12345678987654321L;
    long long2 = -12345678987654321L;
    long long3 = Long.valueOf("12345678");
    long long4 = Long.MAX_VALUE;
    long long5 = Long.MIN_VALUE;

    double double1 = 1e3;
    double double2 = 1e100;
    double double3 = Double.valueOf("123456789");
    double double4 = Double.MAX_VALUE;
    double double5 = Double.MIN_VALUE;

    public static String string1 = "string1";
    String string2 = new String("string2");
    String string3 = string1 + string2;

    Interface1 interface1 = new Interface1() {
        public int aaa(int a) { return -1; }
        public double bbb() { return 0.0; }
    };
    int interface1_aaa1 = interface1.aaa(1);
    public double interface1_bbb1 = interface1.bbb();

    public VeryUsefulClassFile() throws InterruptedException {
        Thread.sleep(100);
        try {
            Thread.sleep(200);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Deprecated
    public int aaa(int aa) {
        return 0;
    }

    public double bbb() {
        return 0;
    }

    public static void main(String[] args) {
        Runnable x = () -> {
        };
    }

    static class SubClass1 {
        int a;
    }

    class SubClass2 {
        int b;
    }
}

interface Interface1 {
    int aaa(int a);
    double bbb();
}

interface Interface2 {
}

interface Interface3 {
}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Orange {
    String getName();
    String getValue();
}
```

由于内容过长，VeryUsefulClassFile的类文件和解析结果，我就不在篇幅里贴出了，需要查看可以参考：[VeryUsefulClassFile.class](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/VeryUsefulClassFile.class) 和 [ResultVeryUsefulClassFile.txt](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/ResultVeryUsefulClassFile.txt)

### 魔数

每个Class文件的头4个字节称为魔数（magic，第1项），它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件，很多文件存储标准中都使用魔数来进行身份识别，不如gif、jpeg文件头中都有魔数

Class文件的魔数很具有“浪漫气息”，值为：0xCAFEBABE，经常被戏称为“咖啡宝贝”，这个魔数值在Java还称作“Oak”语言时（大概1991年前后）就已经确定了，据说是为了象征著名咖啡品牌Peet's Coffee中深受欢迎的Baristas咖啡而起的

可以看到，VerySimpleClassFile.class开头8个字符是cafebabe，每一个字符表示1个十六进制数（0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f）

1个十六进制数可以由4位二进制数表示，8位是1字节，因此2个十六进制数是1个字节，那么8个十六进制数就是4个字节，魔数（magic）也是一个U4类型，表示4个字节的无符号数

使用ParseClassFile项目解析VeryUsefulClassFile的魔数，得到如下结果
```
--------Begin Magic--------
magic: 0xcafebabe
--------End Magic--------
```

### 版本号

版本号有两个项，分别是次版本号（minor_version，第2项）和主版本号（major_version，第3项）

根据VerySimpleClassFile.class来看，次版本号和主版本号分别对应 0000 和 0034，转成十进制数分别是 0 和 52，再转化是指JDK8

下面是JDK版本号与主次版本号的对应表格

|JDK版本|十六进制版本号|十进制版本号|
|--|--|--|
|JDK6|00000032|50.0|
|JDK7|00000033|51.0|
|JDK8|00000034|52.0|
|JDK9|00000035|53.0|
|JDK10|00000036|54.0|
|JDK11|00000037|55.0|
|JDK12|00000038|56.0|
|JDK13|00000039|57.0|

高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，虚拟机必须拒绝执行超过其版本号的Class文件

使用ParseClassFile项目解析VeryUsefulClassFile的版本号，得到如下结果
```
--------Begin Version--------
minor_version: 0(0x0000)
major_version: 52(0x0034)
--------End Version--------
```

### 常量池

好，到了第一个比较复杂的项目了，常量池中的类型比较多，JDK8种就有17种，我将会尽量把每一种常量池都举一个例子，来解释它

#### 常量池的定义

常量池是存放常量数据的主要仓库，两大类常量：字面量（Literal）和符号引用（Symbolic References）

字面量比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等

符号引用则属于编译原理方面的概念，包括下面三类常量
- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符

Java代码在进行Javac编译时，并不像C和C++那样有“连接”这一步，而是在虚拟机加载Class文件的进行动态链接

当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时（静态解析）或运行时（动态链接）解析、翻译到具体的内存地址中

#### 常量池容量计数器

常量池容量计数器（costant_pool_count，第4项）表示常量池的个数减1

> 这里指的特殊说明的一点是，常量池的索引范围是 [1, costant_pool_count)

> 举例子来说，假设costant_pool_count=20，那么索引1表示第一个常量池，索引19表示最后一个常量池。也就是说，实际的常量池个数要少1个，costant_pool_count=20，则有19个常量池。从索引1开始只有常量池是特殊的，其他的数组类型，包括接口集合、字段表集合、方法表集合等，索引都是从0开始。至于为什么是这样子，并不清楚，总之现在就是这么定义的了

索引在类文件的数组类型中，是非常重要的，因为时常会涉及到数组元素的指是一个索引，指向的是数组的另一个元素，下面的例子中会有具体体现

使用ParseClassFile项目解析VeryUsefulClassFile的常量池容量计数器，得到如下结果
```
--------Begin Constant Pool--------
constant_pool_count: 351(0x015f)
```

#### 常量池的结构轮廓

在JDK8中，常量池中一共有17种常量池项，分别如下

|类型|标志（tag）|描述|
|--|--|--|
|CONSTANT_Utf8_info|1|UTF-8编码的字符串|
|CONSTANT_Integer_info|3|整型字面量|
|CONSTANT_Float_info|4|浮点型字面量|
|CONSTANT_Long_info|5|长整型字面量|
|CONSTANT_Double_info|6|双精度浮点型字面量|
|CONSTANT_Class_info|7|类或接口的符号引用|
|CONSTANT_String_info|8|字符串类型字面量|
|CONSTANT_Fieldref_info|9|字段的符号引用|
|CONSTANT_Methodref_info|10|类中方法的符号引用|
|CONSTANT_InterfaceMethodref_info|11|接口中方法的符号引用|
|CONSTANT_NameAndType_info|12|字段或者方法的部分符号引用|
|CONSTANT_MethodHandle_info|15|表示方法句柄|
|CONSTANT_MethodType_info|16|表示方法类型|
|CONSTANT_Dynamic_info|17|表示一个动态计算常量|
|CONSTANT_InvokeDynamic_info|18|表示一个动态方法调用点|
|CONSTANT_Module_info|19|表示一个模块|
|CONSTANT_Package_info|20|表示一个模块中开放或者导出的包|

标志（tag）唯一标识了每个常量池项，在所有常量池项中，第一个字节就是标志

除了 CONSTANT_Dynamic_info、CONSTANT_Module_info、CONSTANT_Package_info 这三个常量池项外，其余14个常量池项，我都把它在VeryUsefulClassFile中体现出来了

现在，我们就按照顺序，从标志=1的常量池项开始，逐一解释一遍

> 就如文章最开头所说一样，解析类文件结构，实际上是对JAVA语法更深入的理解，接下来的过程是非常繁琐的，无法避免

> 为了不过分浪费篇幅，我决定用“点到为止”的办法来解释，比如对于Constant_Utf8_info、Constant_Class_Info这些常见的常量池项，就用几个简单例子来解释即可，而对于CONSTANT_InvokeDynamic_info这样罕见的常量池项，再说明它与泛型有关联即可了，实际上理解它需要很长的篇幅（《深入理解JAVA虚拟机》中完整解释用了4-6页），我不想弄那么麻烦，毕竟对于理解JVM原理来说，它不算核心，而是属于细枝末节

#### CONSTANT_Utf8_info

结构如下
|项目|类型|描述|
|--|--|--|
|tag|U1|标志，值为1|
|length|U2||UTF-8编码的字符串占用的字节数|
|bytes|U1[]|长度为length的UTF-8编码的字符串|

例子1
```
[121] Constant_Utf8_Info(0x010008626f6f6c65616e31)
tag: [1(0x01)]
length_string: [8(0x0008)]
value_string: [boolean1(0x626f6f6c65616e31)]
```

例子2
```
[266] Constant_Utf8_Info(0x010009313233343536373839)
tag: [1(0x01)]
length_string: [9(0x0009)]
value_string: [123456789(0x313233343536373839)]
```

例子3
```
[297] Constant_Utf8_Info(0x01001d636c61737366696c652f5665727955736566756c436c61737346696c65)
tag: [1(0x01)]
length_string: [29(0x001d)]
value_string: [classfile/classfile.VeryUsefulClassFile(0x636c61737366696c652f5665727955736566756c436c61737346696c65)]
```

CONSTANT_Utf8_info存储字符串数据，它是许多其他常量池项的索引目标，比如
- 例子1，boolean boolean1 = false; 字段名，从Constant_Fieldref_Info指来
- 例子2，double double3 = Double.valueOf("123456789"); 字符串，从Constant_String_Info指来
- 例子3，public class VeryUsefulClassFile... 类名，从Constant_Class_Info指来

#### CONSTANT_Integer_info

结构如下
|项目|类型|描述|
|--|--|--|
|tag|U1|标志，值为3|
|bytes|U4|按照高位在前存储的int值|

例子1
```
[20] Constant_Integer_Info(0x030000ffff)
tag: [3(0x03)]
value: [65535(0x0000ffff)]
```

例子2
```
[32] Constant_Integer_Info(0x03075bcd15)
tag: [3(0x03)]
value: [123456789(0x075bcd15)]
[35] Constant_Integer_Info(0x037fffffff)
tag: [3(0x03)]
value: [2147483647(0x7fffffff)]
[37] Constant_Integer_Info(0x0380000000)
tag: [3(0x03)]
value: [-2147483648(0x80000000)]
```

例子3
```
[148] Constant_Integer_Info(0x03000003db)
tag: [3(0x03)]
value: [987(0x000003db)]
```

CONSTANT_Integer_info存储整型数据，比如
- 例子1，char char3 = Character.MAX_VALUE; 语句中的整型数值
- 例子2，以下语句中的整型数值
```java
int int2 = 123456789;
int int3 = Integer.MAX_VALUE;
int int4 = Integer.MIN_VALUE;
```
- 例子3，final int int5 = 987; 语句中的整型数值

到这里，我们会产生一些疑惑了，VeryUsefulClassFile中还有一些以下语句，为什么它们都没有对应的Constant_Integer_Info项呢？
```java
byte byte1 = 123;
byte byte3 = Byte.MAX_VALUE;
byte byte4 = Byte.MIN_VALUE;
char char1 = 'A';
char char2 = '\0';
char char3 = Character.MAX_VALUE;
char char4 = Character.MIN_VALUE;
short short1 = 12345;
short short3 = Short.MAX_VALUE;
short short4 = Short.MIN_VALUE;
int int1 = 123;
float float1 = 100;
```

为了解释这个问题，我们再来看一个例子

IntegerNumberDemo.java
```java
package classfile;

public class IntegerNumberDemo {

    int a1 = 123;
    final int a2 = 124;
    int a3 = 32767;
    int a4 = 32768;
    int a5 = 123456789;

    int a6 = -1;
    int a7 = -32767;
    int a8 = -32768;
    int a9 = -32769;

    boolean bol1 = true;
    byte by1 = 13;
    char ch1 = '1';
    short sh1 = 30000;

    public static void main(String[] args) {
    }
}
```

它的类文件及解析结果分别是：[IntegerNumberDemo.class](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/IntegerNumberDemo.class) 和 [ResultIntegerNumberDemo.txt](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/ResultIntegerNumberDemo.txt)

在这个例子中，解析出来的Constant_Integer_Info项一共只有4个，分别如下
```
[5] Constant_Integer_Info(0x0300008000)
tag: [3(0x03)]
value: [32768(0x00008000)]
[7] Constant_Integer_Info(0x03075bcd15)
tag: [3(0x03)]
value: [123456789(0x075bcd15)]
[11] Constant_Integer_Info(0x03ff439eb2)
tag: [3(0x03)]
value: [-12345678(0xff439eb2)]
[21] Constant_Integer_Info(0x030000007c)
tag: [3(0x03)]
value: [124(0x0000007c)]
```

也就是说，只有变量a4、a5、a9、a2产生了Constant_Integer_Info项，其他的变量都没有产生

然后我翻遍了常量池中的所有数据，都没有找到其他变量对应的值，这说不过去，因为如果都没有的话，JVM是不可能知道如何读取这些变量的值的，使用时就会出现问题

这时候我想到了字节码，查看init函数的字节码，如下
```
 0 aload_0
 1 invokespecial #1 <java/lang/Object.<init>>
 4 aload_0
 5 bipush 123
 7 putfield #2 <classfile/IntegerNumberDemo.a1>
10 aload_0
11 bipush 124
13 putfield #3 <classfile/IntegerNumberDemo.a2>
16 aload_0
17 sipush 32767
20 putfield #4 <classfile/IntegerNumberDemo.a3>
23 aload_0
24 ldc #5 <32768>
26 putfield #6 <classfile/IntegerNumberDemo.a4>
29 aload_0
30 ldc #7 <123456789>
32 putfield #8 <classfile/IntegerNumberDemo.a5>
35 aload_0
36 iconst_m1
37 putfield #9 <classfile/IntegerNumberDemo.a6>
40 aload_0
41 sipush 32769
44 putfield #10 <classfile/IntegerNumberDemo.a7>
47 aload_0
48 sipush 32768
51 putfield #11 <classfile/IntegerNumberDemo.a8>
54 aload_0
55 ldc #12 <-32769>
57 putfield #13 <classfile/IntegerNumberDemo.a9>
60 aload_0
61 iconst_1
62 putfield #14 <classfile/IntegerNumberDemo.bol1>
65 aload_0
66 bipush 13
68 putfield #15 <classfile/IntegerNumberDemo.by1>
71 aload_0
72 bipush 49
74 putfield #16 <classfile/IntegerNumberDemo.ch1>
77 aload_0
78 sipush 30000
81 putfield #17 <classfile/IntegerNumberDemo.sh1>
84 return
```

问题就可以确认了，其他不由Constant_Integer_Info项表达的变量，在字节码中表达

在仔细看，可以发现一些有趣的，比如 int a6 = -1; 是由 iconst_m1 来赋值；int a7 = -32767; 和 int a8 = -32768; 是分别由 sipush 32769 和 sipush 32768 来赋值

做一下总结
- Constant_Integer_Info可以表达的整型变量有：byte、char、short、int
- 非final修饰的，且值在 [-32768, 32767] 范围的整型变量，不会由Constant_Integer_Info表达，而是在字节码中表达
- final修饰的整型变量，会由Constant_Integer_Info直接表达
- 被final修饰的变量赋值，相当于值赋值，比如char char3 = Character.MAX_VALUE，也会产生一个Constant_Integer_Info表达（65535），而Character.MAX_VALUE的源码是public static final char MAX_VALUE = '\uFFFF';

#### 8种基本数据类型及自动转换关系

来复习一下，JAVA中8种数据类型

|类型|长度|范围|
|--|--|--|
|boolean|1个字节|true或false|
|byte|1个字节|-128~127|
|char|2个字节|从字符型对应的整型数来划分，其表示范围是0~65535|
|short|2个字节|-32768~32767|
|int|4个字节|-2147483648~2147483647|
|long|8个字节|-9223372036854775808 ~ 9223372036854775807|
|float|4个字节|-3.4E38~3.4E38|
|double|8个字节|-1.7E308~1.7E308|

自动转换关系
- 低 ---------------------------------------------> 高
(byte，short，char) -> int -> long -> float -> double
- 不符合上面关系链的，由高到低的，需要强制转换，比如 int a = 0; char c = (char) a;
- boolean不支持与其他基本类型转换，包括强制转换

#### CONSTANT_Float_info
#### CONSTANT_Long_info
#### CONSTANT_Double_info
#### CONSTANT_Class_info
#### CONSTANT_String_info
#### CONSTANT_Fieldref_info
#### CONSTANT_Methodref_info
#### CONSTANT_InterfaceMethodref_info
#### CONSTANT_NameAndType_info
#### CONSTANT_MethodHandle_info
#### CONSTANT_MethodType_info
#### CONSTANT_InvokeDynamic_info

### 访问标志

### 本类父类接口

### 字段表

### 方法表

### 属性表
