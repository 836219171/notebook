- [类文件结构](#类文件结构)
  - [类文件的定义](#类文件的定义)
  - [类文件的数据紧凑性](#类文件的数据紧凑性)
  - [类文件的结构轮廓](#类文件的结构轮廓)
  - [无符号数与表](#无符号数与表)
  - [类文件例子](#类文件例子)
  - [魔数](#魔数)
  - [次版本号与主版本号](#次版本号与主版本号)
  - [常量池](#常量池)
    - [常量池的定义](#常量池的定义)
    - [常量池容量计数器](#常量池容量计数器)
    - [常量池的结构轮廓](#常量池的结构轮廓)
    - [CONSTANT_Utf8_info](#CONSTANT_Utf8_info)
    - [CONSTANT_Integer_info](#CONSTANT_Integer_info)
    - [8种基本数据类型及自动转换关系](#8种基本数据类型及自动转换关系)
    - [CONSTANT_Float_info](#CONSTANT_Float_info)
    - [IEEE754二进制浮点数算术标准](#IEEE754二进制浮点数算术标准)
      - [例子-十进制浮点数转32位二进制浮点数](#例子-十进制浮点数转32位二进制浮点数)
      - [例子-32位二进制浮点数转十进制浮点数](#例子-32位二进制浮点数转十进制浮点数)
    - [CONSTANT_Class_info](#CONSTANT_Class_info)
    - [全部常量池项结构](#全部常量池项结构)
  - [类访问标志](#类访问标志)
  - [本类父类接口](#本类父类接口)
    - [类索引](#类索引)
    - [父类索引](#父类索引)
    - [接口计数器](#接口计数器)
    - [接口索引集合](#接口索引集合)
  - [字段表](#字段表)
    - [字段表计数器](#字段表计数器)
    - [字段表结构](#字段表结构)
    - [字段访问标志](#字段访问标志)
    - [访问权限修饰符的作用域](#访问权限修饰符的作用域)
    - [描述符](#描述符)

# 类文件结构

> 终于开始类文件结构章节的书写了，为了写这一篇章节，我花了至少7天的时间完成了一个ParseClassFile项目，项目链接：https://github.com/peteryuanpan/ParseClassFile 。刚刚写完了这个项目的介绍文档，它的核心功能，是读入一份类文件，将每一个字节的含义按照特有的格式输出。对该项目感兴趣的朋友，可以进去看看文档和源码，我也非常建议结合两份文档一起来阅读，单独阅读本文章肯定是枯燥乏味的，解析类文件过程就是这样，无法避免

> 我将会在文章中以类文件为具体例子，介绍类文件的组成部分，还会穿插JavaSE中的基础问题、面试问题等

> 在准备的过程中，我发现一个点，解析类文件结构，实际上是对JAVA语法更深入的理解，比如try catch语句、throws Exception语句，它们对应类文件的哪一个部分，具体内容是什么，比如float和double分别是4个字节和8个字节，但表示的数字范围很大，浮点表示法的原理是什么，比如一个方法完整有哪些组成部分等等。所以，在书写文章的过程中，我不仅会逐一介绍类文件结构的组成部分，还会穿插着JavaSE中的基础问题、面试问题

> 多提一点，这里并不涉及到字节码指令（非指Java字节码），字节码指令只是方法表中的一个属性（Code）而已，关于字节码我们会在 [字节码指令](字节码指令.md) 章节中讲解

> 需要说清楚一点，Java bytecode直译是Java字节码，但我认为不准确，更准确的翻译是二进制字节流。JAVA虚拟机定义是一种能够运行Java字节码程序的虚拟机器，这里的Java字节码是广义的指二进制字节流，而狭义的是指字节码指令。二进制字节流包括类文件，虚拟机加载的一般是类文件，不是只加载字节码指令。字节码指令是指描述Java语句的指令，主要存在于方法表中，它只是类文件的一部分，比如new、putstatic、getstatic这些指令

### 类文件的定义

类文件是一种可以被虚拟机执行的包含了字节码数据的文件；Java类文件通常被Javac编译器从JAVA源文件编译而来，同时，其他语言也可以编译成类文件，比如Jython，Scala，Kotlin

> A Java class file is a file (with the .class filename extension) containing Java bytecode that can be executed on the Java Virtual Machine (JVM). A Java class file is usually produced by a Java compiler from Java programming language source files (.java files) containing Java classes (alternatively, other JVM languages can also be used to create class files).

在类加载这一章节中，我们已经说的比较清楚了，类文件无关乎从哪个语言而来，无关乎在哪里存储，准确的说，它是一组二进制字节流

### 类文件的数据紧凑性

Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在

当遇到需要占用8位字节以上空间的数据项时，会按照高位在前（Big-Endian）的方式分割成若干个8位字节进行存储

> Big-Edian，也称为大端，具体是指最高位字节在地址最低位、最低位字节在地址最高位的顺序来存储数据，它是SPARC、PowerPC等处理器的默认多字节存储顺序，而x86等处理器则是使用了相反的“Little-Endian”顺序来存储数据，Little-Endian称为小端

> 其实我个人认为，不需要去纠结大端小端，你知道怎么读数据就好了，否则容易把自己弄晕，后面例子中若有超过8位字节的数据，会关联说明一下大端和小端

### 类文件的结构轮廓

类文件的结构轮廓（Layout）有16个元素，分别如下

|序号|类型|名称|数量|
|--|--|--|--|
|1|U4|magic|1|
|2|U2|minor_version|1|
|3|U2|major_version|1|
|4|U2|costant_pool_count|1|
|5|cp_info|costant_pool|costant_pool_count - 1|
|6|U2|access_flags|1|
|7|U2|this_class|1|
|8|U2|super_class|1|
|9|U2|interfaces_count|1|
|10|U2|interfaces|interfaces_count|
|11|U2|fields_count|1|
|12|field_info|field|fields_count|
|13|U2|methods_count|1|
|14|method_info|method|methods_count|
|15|U2|attributes_count|1|
|16|attribute_info|attributes|attributes_count|

其中类型中含有U1、U2、U4、U8四种，它们是无符号数，除了无符号数外，剩下都称之为表，表是一种复合型数据类型

可以看出，类文件结构轮廓中有4项属于表，分别是constant_pool、fields、methods、attributes，其他都是无符号数

### 无符号数与表

根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要以这两种数据类型为基础

无符号数属于基本的数据类型，以U1、U2、U4、U8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数

无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值

表是由多个无符号数或者其他表作为数据项构成的复合数据类型

表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表

### 类文件例子

我们举2个类文件例子，用于以后篇幅的说明解释

#### VerySimpleClassFile

第一份是非常简单的程序，这个Java程序够简单了吧，表面看上去它几乎什么都没有，就一个package和class信息

VerySimpleClassFile.java
[VerySimpleClassFile.java](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/VerySimpleClassFile.java)
```java
package classfile;

public class VerySimpleClassFile {
}
```

它class文件如下

[VerySimpleClassFile.class](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/VerySimpleClassFile.class)
```
cafe babe 0000 0034 000d 0a00 0300 0a07
000b 0700 0c01 0006 3c69 6e69 743e 0100
0328 2956 0100 0443 6f64 6501 000f 4c69
6e65 4e75 6d62 6572 5461 626c 6501 000a
536f 7572 6365 4669 6c65 0100 1856 6572
7953 696d 706c 6543 6c61 7373 4669 6c65
2e6a 6176 610c 0004 0005 0100 1d63 6c61
7373 6669 6c65 2f56 6572 7953 696d 706c
6543 6c61 7373 4669 6c65 0100 106a 6176
612f 6c61 6e67 2f4f 626a 6563 7400 2100
0200 0300 0000 0000 0100 0100 0400 0500
0100 0600 0000 1d00 0100 0100 0000 052a
b700 01b1 0000 0001 0007 0000 0006 0001
0000 0003 0001 0008 0000 0002 0009 
```

#### VeryUsefulClassFile

这份文件会有一些长度，但非常有用

[VeryUsefulClassFile.java](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/VeryUsefulClassFile.java)
```java
package classfile;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Orange(getName = "3333",getValue = "4444")
public class VeryUsefulClassFile implements Interface1, Interface2, Interface3 {

    boolean boolean1 = false;
    boolean boolean2 = true;
    boolean boolean3 = Boolean.FALSE;
    boolean boolean4 = Boolean.TRUE;

    byte byte1 = 123;
    byte byte2 = Byte.valueOf("12345");
    byte byte3 = Byte.MAX_VALUE;
    byte byte4 = Byte.MIN_VALUE;

    char char1 = 'A';
    char char2 = '\0';
    char char3 = Character.MAX_VALUE;
    char char4 = Character.MIN_VALUE;

    short short1 = 12345;
    short short2 = Short.valueOf("123456");
    short short3 = Short.MAX_VALUE;
    short short4 = Short.MIN_VALUE;

    int int1 = 123;
    int int2 = 123456789;
    int int3 = Integer.MAX_VALUE;
    int int4 = Integer.MIN_VALUE;

    final int int5 = 987;

    float float1 = 100;
    float float2 = Float.valueOf("1234567");
    float float3 = Float.MAX_VALUE;
    float float4 = Float.MIN_VALUE;

    long long1 = 12345678987654321L;
    long long2 = -12345678987654321L;
    long long3 = Long.valueOf("12345678");
    long long4 = Long.MAX_VALUE;
    long long5 = Long.MIN_VALUE;

    double double1 = 1e3;
    double double2 = 1e100;
    double double3 = Double.valueOf("123456789");
    double double4 = Double.MAX_VALUE;
    double double5 = Double.MIN_VALUE;

    public static String string1 = "string1";
    String string2 = new String("string2");
    String string3 = string1 + string2;

    Interface1 interface1 = new Interface1() {
        public int aaa(int a) { return -1; }
        public double bbb() { return 0.0; }
    };
    int interface1_aaa1 = interface1.aaa(1);
    public double interface1_bbb1 = interface1.bbb();

    public VeryUsefulClassFile() throws InterruptedException {
        Thread.sleep(100);
        try {
            Thread.sleep(200);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Deprecated
    public int aaa(int aa) {
        return 0;
    }

    public double bbb() {
        return 0;
    }

    public static void main(String[] args) {
        Runnable x = () -> {
        };
    }

    static class SubClass1 {
        int a;
    }

    class SubClass2 {
        int b;
    }
}

interface Interface1 {
    int aaa(int a);
    double bbb();
}

interface Interface2 {
}

interface Interface3 {
}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Orange {
    String getName();
    String getValue();
}
```

由于内容过长，VeryUsefulClassFile的类文件和解析结果，我就不在篇幅里贴出了，需要查看可以参考：[VeryUsefulClassFile.class](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/VeryUsefulClassFile.class) 和 [ResultVeryUsefulClassFile.txt](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/ResultVeryUsefulClassFile.txt)

### 魔数

每个Class文件的头4个字节称为魔数（magic，第1项），它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件，很多文件存储标准中都使用魔数来进行身份识别，不如gif、jpeg文件头中都有魔数

Class文件的魔数很具有“浪漫气息”，值为：0xCAFEBABE，经常被戏称为“咖啡宝贝”，这个魔数值在Java还称作“Oak”语言时（大概1991年前后）就已经确定了，据说是为了象征著名咖啡品牌Peet's Coffee中深受欢迎的Baristas咖啡而起的

可以看到，VerySimpleClassFile.class开头8个字符是cafebabe，每一个字符表示1个十六进制数（0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f）

1个十六进制数可以由4位二进制数表示，8位是1字节，因此2个十六进制数是1个字节，那么8个十六进制数就是4个字节，魔数（magic）也是一个U4类型，表示4个字节的无符号数

使用ParseClassFile项目解析VeryUsefulClassFile的魔数，得到如下结果
```
--------Begin Magic--------
magic: 0xcafebabe
--------End Magic--------
```

### 次版本号与主版本号

版本号有两个项，分别是次版本号（minor_version，第2项）和主版本号（major_version，第3项）

根据VerySimpleClassFile.class来看，次版本号和主版本号分别对应 0000 和 0034，转成十进制数分别是 0 和 52，再转化是指JDK8

下面是JDK版本号与主次版本号的对应表格

|JDK版本|十六进制版本号|十进制版本号|
|--|--|--|
|JDK6|00000032|50.0|
|JDK7|00000033|51.0|
|JDK8|00000034|52.0|
|JDK9|00000035|53.0|
|JDK10|00000036|54.0|
|JDK11|00000037|55.0|
|JDK12|00000038|56.0|
|JDK13|00000039|57.0|

高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，虚拟机必须拒绝执行超过其版本号的Class文件

使用ParseClassFile项目解析VeryUsefulClassFile的版本号，得到如下结果
```
--------Begin Version--------
minor_version: 0(0x0000)
major_version: 52(0x0034)
--------End Version--------
```

### 常量池

好，到了第一个比较复杂的项目了，常量池中的类型比较多，JDK8种就有17种，我将会尽量把每一种常量池都举一个例子，来解释它

#### 常量池的定义

常量池（constant_pool，第5项）是存放常量数据的主要仓库，两大类常量：字面量（Literal）和符号引用（Symbolic References）

字面量比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等

符号引用则属于编译原理方面的概念，包括下面三类常量
- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符

Java代码在进行Javac编译时，并不像C和C++那样有“连接”这一步，而是在虚拟机加载Class文件的进行动态链接

当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时（静态解析）或运行时（动态链接）解析、翻译到具体的内存地址中

#### 常量池容量计数器

常量池容量计数器（costant_pool_count，第4项）表示常量池的个数减1

> 这里指的特殊说明的一点是，常量池的索引范围是 [1, costant_pool_count)

> 举例子来说，假设costant_pool_count=20，那么索引1表示第一个常量池，索引19表示最后一个常量池。也就是说，实际的常量池个数要少1个，costant_pool_count=20，则有19个常量池。从索引1开始只有常量池是特殊的，其他的数组类型，包括接口集合、字段表集合、方法表集合等，索引都是从0开始。至于为什么是这样子，并不清楚，总之现在就是这么定义的了

索引在类文件的数组类型中，是非常重要的，因为时常会涉及到数组元素的指是一个索引，指向的是数组的另一个元素，下面的例子中会有具体体现

使用ParseClassFile项目解析VeryUsefulClassFile的常量池容量计数器，得到如下结果
```
--------Begin Constant Pool--------
constant_pool_count: 351(0x015f)
```

#### 常量池的结构轮廓

在JDK8中，常量池中一共有17种常量池项，分别如下

|类型|标志（tag）|描述|
|--|--|--|
|CONSTANT_Utf8_info|1|UTF-8编码的字符串|
|CONSTANT_Integer_info|3|整型字面量|
|CONSTANT_Float_info|4|浮点型字面量|
|CONSTANT_Long_info|5|长整型字面量|
|CONSTANT_Double_info|6|双精度浮点型字面量|
|CONSTANT_Class_info|7|类或接口的符号引用|
|CONSTANT_String_info|8|字符串类型字面量|
|CONSTANT_Fieldref_info|9|字段的符号引用|
|CONSTANT_Methodref_info|10|类中方法的符号引用|
|CONSTANT_InterfaceMethodref_info|11|接口中方法的符号引用|
|CONSTANT_NameAndType_info|12|字段或者方法的部分符号引用|
|CONSTANT_MethodHandle_info|15|表示方法句柄|
|CONSTANT_MethodType_info|16|表示方法类型|
|CONSTANT_Dynamic_info|17|表示一个动态计算常量|
|CONSTANT_InvokeDynamic_info|18|表示一个动态方法调用点|
|CONSTANT_Module_info|19|表示一个模块|
|CONSTANT_Package_info|20|表示一个模块中开放或者导出的包|

标志（tag）唯一标识了每个常量池项，在所有常量池项中，第一个字节就是标志

除了 CONSTANT_Dynamic_info、CONSTANT_Module_info、CONSTANT_Package_info 这三个常量池项外，其余14个常量池项，我都把它在VeryUsefulClassFile中体现出来了

现在，我们就按照顺序，简要的说一遍常量池项

> 就如文章最开头所说一样，解析类文件结构，实际上是对JAVA语法更深入的理解，接下来的过程是非常繁琐的，无法避免

> 为了不过分浪费篇幅，我决定用“点到为止”的办法来解释，只对于Constant_Utf8_info、CONSTANT_Integer_info、CONSTANT_Float_info、CONSTANT_Class_info这几个常见的常量池项，用几个简单例子来解释即可，而对于其他常量池项，用统一一个表格来描述，说明其结构即可，毕竟这部分对于理解JVM原理来说，它不算核心，而是属于细枝末节

#### CONSTANT_Utf8_info

结构如下
|项目|类型|描述|
|--|--|--|
|tag|U1|标志，值为1|
|length|U2|UTF-8编码的字符串占用的字节数|
|bytes|U1[]|长度为length的UTF-8编码的字符串|

例子1
```
[121] Constant_Utf8_Info(0x010008626f6f6c65616e31)
tag: [1(0x01)]
length_string: [8(0x0008)]
value_string: [boolean1(0x626f6f6c65616e31)]
```

例子2
```
[266] Constant_Utf8_Info(0x010009313233343536373839)
tag: [1(0x01)]
length_string: [9(0x0009)]
value_string: [123456789(0x313233343536373839)]
```

例子3
```
[297] Constant_Utf8_Info(0x01001d636c61737366696c652f5665727955736566756c436c61737346696c65)
tag: [1(0x01)]
length_string: [29(0x001d)]
value_string: [classfile/classfile.VeryUsefulClassFile(0x636c61737366696c652f5665727955736566756c436c61737346696c65)]
```

CONSTANT_Utf8_info存储字符串数据，它是许多其他常量池项的索引目标
- 例子1，boolean boolean1 = false; 字段名，从Constant_Fieldref_Info指来
- 例子2，double double3 = Double.valueOf("123456789"); 字符串，从Constant_String_Info指来
- 例子3，public class VeryUsefulClassFile... 类名，从Constant_Class_Info指来

#### CONSTANT_Integer_info

结构如下
|项目|类型|描述|
|--|--|--|
|tag|U1|标志，值为3|
|bytes|U4|按照高位在前存储的int值|

例子1
```
[20] Constant_Integer_Info(0x030000ffff)
tag: [3(0x03)]
value: [65535(0x0000ffff)]
```

例子2
```
[32] Constant_Integer_Info(0x03075bcd15)
tag: [3(0x03)]
value: [123456789(0x075bcd15)]
[35] Constant_Integer_Info(0x037fffffff)
tag: [3(0x03)]
value: [2147483647(0x7fffffff)]
[37] Constant_Integer_Info(0x0380000000)
tag: [3(0x03)]
value: [-2147483648(0x80000000)]
```

例子3
```
[148] Constant_Integer_Info(0x03000003db)
tag: [3(0x03)]
value: [987(0x000003db)]
```

CONSTANT_Integer_info存储整型数据
- 例子1，char char3 = Character.MAX_VALUE; 语句中的整型数值
- 例子2，以下语句中的整型数值
```java
int int2 = 123456789;
int int3 = Integer.MAX_VALUE;
int int4 = Integer.MIN_VALUE;
```
- 例子3，final int int5 = 987; 语句中的整型数值

到这里，我们会产生一些疑惑了，VeryUsefulClassFile中还有一些以下语句，为什么它们都没有对应的Constant_Integer_Info项呢？
```java
byte byte1 = 123;
byte byte3 = Byte.MAX_VALUE;
byte byte4 = Byte.MIN_VALUE;
char char1 = 'A';
char char2 = '\0';
char char3 = Character.MAX_VALUE;
char char4 = Character.MIN_VALUE;
short short1 = 12345;
short short3 = Short.MAX_VALUE;
short short4 = Short.MIN_VALUE;
int int1 = 123;
float float1 = 100;
```

为了解释这个问题，我们再来看一个例子

IntegerNumberDemo.java
```java
package classfile;

public class IntegerNumberDemo {

    int a1 = 123;
    final int a2 = 124;
    int a3 = 32767;
    int a4 = 32768;
    int a5 = 123456789;

    int a6 = -1;
    int a7 = -32767;
    int a8 = -32768;
    int a9 = -32769;

    boolean bol1 = true;
    byte by1 = 13;
    char ch1 = '1';
    short sh1 = 30000;

    public static void main(String[] args) {
    }
}
```

它的类文件及解析结果分别是：[IntegerNumberDemo.class](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/IntegerNumberDemo.class) 和 [ResultIntegerNumberDemo.txt](https://github.com/peteryuanpan/ParseClassFile/blob/master/src/main/resources/classfile/ResultIntegerNumberDemo.txt)

在这个例子中，解析出来的Constant_Integer_Info项一共只有4个，分别如下
```
[5] Constant_Integer_Info(0x0300008000)
tag: [3(0x03)]
value: [32768(0x00008000)]
[7] Constant_Integer_Info(0x03075bcd15)
tag: [3(0x03)]
value: [123456789(0x075bcd15)]
[11] Constant_Integer_Info(0x03ff439eb2)
tag: [3(0x03)]
value: [-12345678(0xff439eb2)]
[21] Constant_Integer_Info(0x030000007c)
tag: [3(0x03)]
value: [124(0x0000007c)]
```

也就是说，只有变量a4、a5、a9、a2产生了Constant_Integer_Info项，其他的变量都没有产生

然后我翻遍了常量池中的所有数据，都没有找到其他变量对应的值，这说不过去，因为如果都没有的话，JVM是不可能知道如何读取这些变量的值的，使用时就会出现问题

这时候我想到了字节码，查看init函数的字节码，如下
```
 0 aload_0
 1 invokespecial #1 <java/lang/Object.<init>>
 4 aload_0
 5 bipush 123
 7 putfield #2 <classfile/IntegerNumberDemo.a1>
10 aload_0
11 bipush 124
13 putfield #3 <classfile/IntegerNumberDemo.a2>
16 aload_0
17 sipush 32767
20 putfield #4 <classfile/IntegerNumberDemo.a3>
23 aload_0
24 ldc #5 <32768>
26 putfield #6 <classfile/IntegerNumberDemo.a4>
29 aload_0
30 ldc #7 <123456789>
32 putfield #8 <classfile/IntegerNumberDemo.a5>
35 aload_0
36 iconst_m1
37 putfield #9 <classfile/IntegerNumberDemo.a6>
40 aload_0
41 sipush 32769
44 putfield #10 <classfile/IntegerNumberDemo.a7>
47 aload_0
48 sipush 32768
51 putfield #11 <classfile/IntegerNumberDemo.a8>
54 aload_0
55 ldc #12 <-32769>
57 putfield #13 <classfile/IntegerNumberDemo.a9>
60 aload_0
61 iconst_1
62 putfield #14 <classfile/IntegerNumberDemo.bol1>
65 aload_0
66 bipush 13
68 putfield #15 <classfile/IntegerNumberDemo.by1>
71 aload_0
72 bipush 49
74 putfield #16 <classfile/IntegerNumberDemo.ch1>
77 aload_0
78 sipush 30000
81 putfield #17 <classfile/IntegerNumberDemo.sh1>
84 return
```

问题就可以确认了，其他不由Constant_Integer_Info项表达的变量，在字节码中表达

在仔细看，可以发现一些有趣的，比如 int a6 = -1; 是由 iconst_m1 来赋值；int a7 = -32767; 和 int a8 = -32768; 是分别由 sipush 32769 和 sipush 32768 来赋值

做一下总结
- Constant_Integer_Info可以表达的整型变量的类型有：byte、char、short、int；而boolean类型由于只有true和false两种值，直接在字节码中表达了
- 非final修饰的整型变量，若值在 [-32768, 32767] 范围之外，由Constant_Integer_Info表达，若值在 [-32768, 32767] 范围之内，在字节码中表达
- final修饰的整型变量，会由Constant_Integer_Info直接表达
- 被final修饰的变量赋值，相当于值赋值，比如char char3 = Character.MAX_VALUE，也会产生一个Constant_Integer_Info表达（65535），而Character.MAX_VALUE的源码是public static final char MAX_VALUE = '\uFFFF';

#### 8种基本数据类型及自动转换关系

来复习一下，Java中8种数据类型

|类型|长度|范围|
|--|--|--|
|boolean|1个字节|true或false|
|byte|1个字节|-128~127|
|char|2个字节|从字符型对应的整型数来划分，其表示范围是0~65535|
|short|2个字节|-32768~32767|
|int|4个字节|-2147483648~2147483647|
|long|8个字节|-9223372036854775808 ~ 9223372036854775807|
|float|4个字节|-3.4E38~3.4E38|
|double|8个字节|-1.7E308~1.7E308|

自动转换关系
- 低到高，(byte，short，char) -> int -> long -> float -> double
- 不符合上面关系链的，由高到低的，需要强制转换，比如 int a = 0; char c = (char) a;
- boolean不支持与其他基本类型转换，包括强制转换

#### CONSTANT_Float_info

结构如下
|项目|类型|描述|
|--|--|--|
|tag|U1|标志，值为4|
|bytes|U4|按照高位在前存储的float值|

例子1
```
[40] Constant_Float_Info(0x0442c80000)
tag: [4(0x04)]
value: [1120403456(0x42c80000)]
value_float: [100.0]
```

例子2
```
[47] Constant_Float_Info(0x047f7fffff)
tag: [4(0x04)]
value: [2139095039(0x7f7fffff)]
value_float: [3.4028235E38]
```

CONSTANT_Float_info存储float型数据
- 例子1，float float1 = 100; 语句中的数值
- 例子2，float float3 = Float.MAX_VALUE; 语句中的数值，Float.MAX_VALUE的源码是public static final float MAX_VALUE = 0x1.fffffeP+127f; // 3.4028235e+38f

#### IEEE754二进制浮点数算术标准

IEEE二进制浮点数算术标准（IEEE 754）是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用

下面我使用两个例子来解释IEEE 754

##### 例子-十进制浮点数转32位二进制浮点数

假设有一个十进制浮点数263.3，请转为32位二进制浮点数
- 为了方面讲解，我直接截图了
![image](https://user-images.githubusercontent.com/10209135/95718664-56c5be80-0ca1-11eb-9350-309846be4cec.png)
- 通过上面的方法，就可以将 263 转成100000111，.3转成010011001100110011...
- 这样 263.3 可以转成100000111.010011001100110011...
- 然后转成 1.00000111010011001100110011... * 2^8
- 公式1：X=(-1)^S*(1.M)*(2^e)
- 其中 X 是二进制表达，S是符号位（sign bit），M是指数偏移值（exponent bias），e是分数值（fraction）
- 公式2：e=E-127
- 公式3：二进制表达（32位） = S（1位）+ E（8位）+ M（31位）
- X=1.00000111010011001100110011... * 2^8（公式1）
- S=0，表示正数（公式1）
- e=8（公式1）
- E=e+127=136（公式2）
- E=10000111
- 1.M=1.00000111010011001100110011...（公式1）
- M=00000111010011001100110011...
- 二进制表达=S+E+M=01000011100000111010011001100110011...
- 32位二进制表达：0100 0011 1000 0011 1010 0110 0110 0110

Java中转换例子
```java
package math;

public class FloatToHexString{

    public static void main(String[] args) {
        float f = 263.3f;
        int i = Float.floatToIntBits(f);
        String hexS = Integer.toHexString(i);
        System.out.println(f);
        System.out.println(i);
        System.out.println(hexS);
    }
}
```
输出结果
```
263.3
1132701286
4383a666
```

##### 例子-32位二进制浮点数转十进制浮点数

假设有一个32位二进制浮点数，它的十六进制表达是：0x41360000，请转为十进制浮点数
- 转成二进制表达：0100 0001 0011 0110 0000 0000 0000 0000
- 公式1：X=(-1)^S*(1.M)*(2^e)，其中 X 是二进制表达，S是符号位（sign bit），M是指数偏移值（exponent bias），e是分数值（fraction）
- 公式2：e=E-127
- 公式3：二进制表达（32位） = S（1位）+ E（8位）+ M（31位）
- S=0，表示正数（公式3）
- E=10000010（公式3）
- E=130
- e=E-127=3（公式2）
- M=01101100000000000000000（公式3）
- 1.M=1.011011
- X=1011.011（公式1）
- 将1.M从二进制转成十进制
- 1011 => 11
- .011 => 0,375
- 则十进制表达是：11.375

这里重点说一下 .011 是怎么变成 0.375 的
- 要把011反过来看，也就是110
- 第一个数是1，则1/2=0.5
- 第二个数是1，则1+0.5=1.5，1.5/2=0.75
- 第三个数是0，则0+0.75=0.75，0.75/2=0.375

Java中转换例子
```java
package math;

public class HexStringToFloat {

    public static void main(String[] args) {
        String hexS = "41360000";
        int i = Integer.valueOf(hexS, 16);
        double f = Float.intBitsToFloat(i);
        System.out.println(hexS);
        System.out.println(i);
        System.out.println(f);
    }
}
```
输出结果
```
41360000
1094057984
11.375
```

#### CONSTANT_Class_info

结构如下
|项目|类型|描述|
|--|--|--|
|tag|U1|标志，值为7|
|index|U2|指向全限定名常量项的索引|

例子1
```
[14] Constant_Class_Info(0x0700e1)
tag: [7(0x07)]
name_index: [225(0x00e1)]
valueof_name_index: [Constant_Utf8_Info(0x01000e6a6176612f6c616e672f42797465), tag: [1(0x01)], length_string: [14(0x000e)], value_string: [java/lang/Byte(0x6a6176612f6c616e672f42797465)]]
```

例子2
```
[111] Constant_Class_Info(0x070129)
tag: [7(0x07)]
name_index: [297(0x0129)]
valueof_name_index: [Constant_Utf8_Info(0x01001d636c61737366696c652f5665727955736566756c436c61737346696c65), tag: [1(0x01)], length_string: [29(0x001d)], value_string: [classfile/VeryUsefulClassFile(0x636c61737366696c652f5665727955736566756c436c61737346696c65)]]
```

例子3
```
[119] Constant_Class_Info(0x07012f)
tag: [7(0x07)]
name_index: [303(0x012f)]
valueof_name_index: [Constant_Utf8_Info(0x010027636c61737366696c652f5665727955736566756c436c61737346696c6524537562436c61737331), tag: [1(0x01)], length_string: [39(0x0027)], value_string: [classfile/VeryUsefulClassFile$SubClass1(0x636c61737366696c652f5665727955736566756c436c61737346696c6524537562436c61737331)]]
```

CONSTANT_Class_info存储类和接口的全限定名（符号引用）
- 例子1，byte byte2 = Byte.valueOf("12345"); 语句中Byte类的全限定名
- 例子2，public class VeryUsefulClassFile 当前类的全限定名
- 例子3，子类SubClass1的全限定名
```java
static class SubClass1 {
    int a;
}
```

### 全部常量池项结构

|常量池项|项目|类型|描述|
|--|--|--|--|
|CONSTANT_Utf8_info|tag|U1|标志，值为1|
||length|U2|UTF-8编码的字符串占用的字节数|
||bytes|U1[]|长度为length的UTF-8编码的字符串|
|CONSTANT_Integer_info|tag|U1|标志，值为3|
||bytes|U4|按照高位在前存储的int值|
|CONSTANT_Float_info|tag|U1|标志，值为4|
||bytes|U4|按照高位在前存储的float值|
|CONSTANT_Long_info|tag|U1|标志，值为5|
||bytes|U8|按照高位在前存储的long值|
|CONSTANT_Double_info|tag|U1|标志，值为6|
||bytes|U8|按照高位在前存储的double值|
|CONSTANT_Class_info|tag|U1|标志，值为7|
||index|U2|指向全限定名常量项的索引，类型为CONSTANT_Utf8_info|
|CONSTANT_String_info|tag|U1|标志，值为8|
||index|U2|指向字符串字面量的索引，类型为CONSTANT_Utf8_info|
|CONSTANT_Fieldref_info|tag|U1|标志，值为9|
||index|U2|指向声明字段的类或者接口描述符的索引，类型为CONSTANT_Class_info|
||index|U2|指向字段描述符的索引，类型为CONSTANT_NameAndType_info|
|CONSTANT_Methodref_info|tag|U1|标志，值为10|
||index|U2|指向声明方法的类描述符的索引，类型为CONSTANT_Class_info|
||index|U2|指向方法描述符的索引，类型为CONSTANT_NameAndType_info|
|CONSTANT_InterfaceMethodref_info|tag|U1|标志，值为11|
||index|U2|指向声明方法的接口描述符的索引，类型为CONSTANT_Class_info|
||index|U2|指向方法描述符的索引，类型为CONSTANT_NameAndType_info|
|CONSTANT_NameAndType_info|tag|U1|标志，值为12|
||index|U2|指向该字段或方法名称常量项的索引，类型为CONSTANT_Utf8_info|
||index|U2|指向该字段或方法描述符常量项的索引，类型为CONSTANT_Utf8_info|
|CONSTANT_MethodHandle_info|tag|U1|标志，值为15|
||reference_kind|U2|值必须在1~9之间（包括1和9），它决定方法句柄的类型，方法句柄类型的值表示方法句柄的字节码行为|
||reference_index|U2|值必须是对常量池的有效索引|
|CONSTANT_MethodType_info|tag|U1|标志，值为16|
||reference_kind|U2|值必须是对常量池的有效索引，表示方法的描述符，类型为CONSTANT_Utf8_info|
|CONSTANT_Dynamic_info|tag|U1|标志，值为17|
||bootstrap_method_attr_index|U2|值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引|
||name_and_type_index|U2|值必须是对常量池的有效索引，表示方法名和方法的描述符，类型为CONSTANT_NameAndType_info|
|CONSTANT_InvokeDynamic_info|tag|U1|标志，值为18|
||bootstrap_method_attr_index|U2|值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引|
||name_and_type_index|U2|值必须是对常量池的有效索引，表示方法名和方法的描述符，类型为CONSTANT_NameAndType_info|
|CONSTANT_Module_info|tag|U1|标志，值为19|
||name_index|U2|值必须是对常量池的有效索引，表示模块名字，类型为CONSTANT_Utf8_info|
|CONSTANT_Package_info|tag|U1|标志，值为20|
||name_index|U2|值必须是对常量池的有效索引，表示包名字，类型为CONSTANT_Utf8_info|

### 类访问标志

在常量池结束后，紧接着两个字符代表方法标志（access_flags，第6项），它表示类或接口的许多状态集合（二进制或运算）

这个标志用于识别一些类或接口层次的访问信息，如下

|标志名称|标志值|含义|
|--|--|--|
|ACC_PUBLIC|0x0001|是否为public类型|
|ACC_FINAL|0x0010|是否被声明为final，只有类可设置|
|ACC_SUPER|0x0020|是否允许使用invokespecial字节码指令的新语意，invokespecial指令语意在JDK1.0.2发生过改变，JDK1.0.2之后编译出来的类的这个标志都必须为真|
|ACC_INTERFACE|0x0200|标识是一个接口|
|ACC_ABSTRACT|0x0400|是否为abstract类型，对于接口或抽象类来说，此标志为真，其他类值为假|
|ACC_SYNTHETIC|0x1000|标识这个类并非由用户代码产生|
|ACC_ANNOTATION|0x2000|标识是一个注解|
|ACC_ENUM|0x4000|标识是一个枚举|

使用ParseClassFile项目解析VeryUsefulClassFile的访问标志，得到如下结果
```
--------Begin Access Flag--------
[access_flag] Class_Access_Flag(0x0021)
value: [33(0x0021)]
FLAGs: [[ACC_PUBLIC], [ACC_SUPER]]
--------END Access Flag--------
```

由于VeryUsefulClassFile类是public的，且在JDK1.0.2之后编译，其他标志都不满足，因此它的状态为 0x0001 | 0x0020 = 0x0021

要注意，类文件中有4种访问标志，分别是类标志、字段访问标志、方法访问标志、内部类访问标志，剩余三种在下文会有提及

类访问标志中，有一个标志是ACC_ANNOTATION，这表示注解，关于注解，会在讲到属性 RuntimeVisibleAnnotations 等时提及

### 本类父类接口

#### 类索引
#### 父类索引

接下来有三个数据，分别是类索引（this_class，第7项）、父类索引（super_class，第8项）、接口索引集合（interfaces，第10项），用于描述类的继承关系（注意，这里所说的“类”也包括接口），这三者的索引都是指向常量池中的某一个类型为Constant_Utf8_Info的项

类索引是一个U2类型数据，用于确定这个类的全限定名，父类索引也是一个U2类型数据，用于确定这个类的父类的全限定名

使用ParseClassFile项目解析VeryUsefulClassFile的本类索引和父类索引，得到如下结果
```
--------Begin Class & Interfaces--------
[this_class] Class_Interface_Info(0x006f)
class_index: [111(0x006f)]
valueof_class_index: [Constant_Class_Info(0x070129), tag: [7(0x07)], name_index: [297(0x0129)], valueof_name_index: [Constant_Utf8_Info(0x01001d636c61737366696c652f5665727955736566756c436c61737346696c65), tag: [1(0x01)], length_string: [29(0x001d)], value_string: [classfile/VeryUsefulClassFile(0x636c61737366696c652f5665727955736566756c436c61737346696c65)]]]
valueof_name_index: [Constant_Utf8_Info(0x01001d636c61737366696c652f5665727955736566756c436c61737346696c65), tag: [1(0x01)], length_string: [29(0x001d)], value_string: [classfile/VeryUsefulClassFile(0x636c61737366696c652f5665727955736566756c436c61737346696c65)]]

[super_class] Class_Interface_Info(0x0070)
class_index: [112(0x0070)]
valueof_class_index: [Constant_Class_Info(0x07012a), tag: [7(0x07)], name_index: [298(0x012a)], valueof_name_index: [Constant_Utf8_Info(0x0100106a6176612f6c616e672f4f626a656374), tag: [1(0x01)], length_string: [16(0x0010)], value_string: [java/lang/Object(0x6a6176612f6c616e672f4f626a656374)]]]
valueof_name_index: [Constant_Utf8_Info(0x0100106a6176612f6c616e672f4f626a656374), tag: [1(0x01)], length_string: [16(0x0010)], value_string: [java/lang/Object(0x6a6176612f6c616e672f4f626a656374)]]
```

VeryUsefulClassFile类声明的原型是：public class VeryUsefulClassFile implements Interface1, Interface2, Interface3

因此本类指向的是值为classfile/VeryUsefulClassFile的Constant_Utf8_Info常量池项，父类指向的是值为java/lang/Object的Constant_Utf8_Info常量池项

使用ParseClassFile项目解析java.lang.Object的本类索引和父类索引，得到如下结果
```
--------Begin Class & Interfaces--------
[this_class] Class_Interface_Info(0x0033)
class_index: [51(0x0033)]
valueof_class_index: [Constant_Class_Info(0x070023), tag: [7(0x07)], name_index: [35(0x0023)], valueof_name_index: [Constant_Utf8_Info(0x0100106a6176612f6c616e672f4f626a656374), tag: [1(0x01)], length_string: [16(0x0010)], value_string: [java/lang/Object(0x6a6176612f6c616e672f4f626a656374)]]]
valueof_name_index: [Constant_Utf8_Info(0x0100106a6176612f6c616e672f4f626a656374), tag: [1(0x01)], length_string: [16(0x0010)], value_string: [java/lang/Object(0x6a6176612f6c616e672f4f626a656374)]]

[super_class] Class_Interface_Info(0x0000)
class_index: [0(0x0000)]
valueof_class_index: []
valueof_name_index: []
```

可以看出父类索引的值为0，即java.lang.Object没有父类了

#### 接口计数器
#### 接口索引集合

接下来是接口计数器（interfaces_count，第9项），用于描述实现的接口的个数，若没有实现接口，则计数器值为0，后面的索引集合也不占任何字节

接口索引集合（interfaces，第10项）是一组U2类型数据的集合，用来描述类实现了哪些接口，这些接口将按implements语句顺序排列，而如果这个类本身就是一个接口，按照extends语句的顺序排列

使用ParseClassFile项目解析VeryUsefulClassFile的接口计数器和接口索引集合，得到如下结果
```
interfaces_count: 3(0x0003)
[0] Class_Interface_Info(0x0071)
class_index: [113(0x0071)]
valueof_class_index: [Constant_Class_Info(0x07012b), tag: [7(0x07)], name_index: [299(0x012b)], valueof_name_index: [Constant_Utf8_Info(0x010014636c61737366696c652f496e7465726661636531), tag: [1(0x01)], length_string: [20(0x0014)], value_string: [classfile/Interface1(0x636c61737366696c652f496e7465726661636531)]]]
valueof_name_index: [Constant_Utf8_Info(0x010014636c61737366696c652f496e7465726661636531), tag: [1(0x01)], length_string: [20(0x0014)], value_string: [classfile/Interface1(0x636c61737366696c652f496e7465726661636531)]]
[1] Class_Interface_Info(0x0072)
class_index: [114(0x0072)]
valueof_class_index: [Constant_Class_Info(0x07012c), tag: [7(0x07)], name_index: [300(0x012c)], valueof_name_index: [Constant_Utf8_Info(0x010014636c61737366696c652f496e7465726661636532), tag: [1(0x01)], length_string: [20(0x0014)], value_string: [classfile/Interface2(0x636c61737366696c652f496e7465726661636532)]]]
valueof_name_index: [Constant_Utf8_Info(0x010014636c61737366696c652f496e7465726661636532), tag: [1(0x01)], length_string: [20(0x0014)], value_string: [classfile/Interface2(0x636c61737366696c652f496e7465726661636532)]]
[2] Class_Interface_Info(0x0073)
class_index: [115(0x0073)]
valueof_class_index: [Constant_Class_Info(0x07012d), tag: [7(0x07)], name_index: [301(0x012d)], valueof_name_index: [Constant_Utf8_Info(0x010014636c61737366696c652f496e7465726661636533), tag: [1(0x01)], length_string: [20(0x0014)], value_string: [classfile/Interface3(0x636c61737366696c652f496e7465726661636533)]]]
valueof_name_index: [Constant_Utf8_Info(0x010014636c61737366696c652f496e7465726661636533), tag: [1(0x01)], length_string: [20(0x0014)], value_string: [classfile/Interface3(0x636c61737366696c652f496e7465726661636533)]]
--------End Class & Interfaces--------
```

### 字段表

字段表（field_info，第12项）用于描述类或者接口中声明的变量，字段包括类级变量和实例及变量，但不包括在方法内部声明的局部变量

#### 字段表计数器

在字段表之前，有一个字段表计数器（fields_count，第11项），用于描述字段的个数，如果没有字段，则计数值为0，后面的字段表也不占任何字节

使用ParseClassFile项目解析VeryUsefulClassFile的字段计数器，得到如下结果
```
--------Begin Fields--------
fields_count: 41(0x0029)
```

#### 字段表结构

结构如下
|类型|名称|数量|
|--|--|--|
|U2|access_flags|1|
|U2|name_index|1|
|U2|descriptor_index|1|
|U2|attributes_count|1|
|attribute_info|attributes|attributes_count|

可以看出字段表结构还是有些东西的，第一个是访问标志，字段表的访问标志与类的访问标志内容有所不同，下文会提到

第二个是name_index，它是指字段的简单名称，第三个是descriptor_index，它是字段的描述符

简单名称 以及前面所提的 全限定名 含义很好理解，以VeryUsefulClassFile类为例子，classfile/VeryUsefulClassFile就是全限定名，它仅仅是把类全名中的"."替换成了"/"，在使用时一般最后会加一个";"；而简单名称是指没有类型和参数修饰的方法或字段名称，比如public static String string1的简单名称为string1，public VeryUsefulClassFile() throws InterruptedException的简单名称为VeryUsefulClassFile；而描述符的含义，下文会提到

第四个是attributes_count，表示字段表的属性表个数，第五个是attributes，表示字段表的属性表

在类文件中，属性表一共有三种，分别是类属性表、字段表的属性表、方法表的属性表。其中字段表的属性值主要是ConstantValue

使用ParseClassFile项目解析VeryUsefulClassFile的字段表，得到如下结果
```
[0] Field_Info(0x00000079007a0000)
access_flag: [Field_Access_Flag(0x0000), value: [0(0x0000)], FLAGs: []]
name_index: [121(0x0079)]
valueof_name_index: [Constant_Utf8_Info(0x010008626f6f6c65616e31), tag: [1(0x01)], length_string: [8(0x0008)], value_string: [boolean1(0x626f6f6c65616e31)]]
descriptor_index: [122(0x007a)]
valueof_descriptor_index: [Constant_Utf8_Info(0x0100015a), tag: [1(0x01)], length_string: [1(0x0001)], value_string: [Z(0x5a)]]
attributes_count: [0(0x0000)]
attributes: []
...
[12] Field_Info(0x0000008800890000)
access_flag: [Field_Access_Flag(0x0000), value: [0(0x0000)], FLAGs: []]
name_index: [136(0x0088)]
valueof_name_index: [Constant_Utf8_Info(0x01000673686f727431), tag: [1(0x01)], length_string: [6(0x0006)], value_string: [short1(0x73686f727431)]]
descriptor_index: [137(0x0089)]
valueof_descriptor_index: [Constant_Utf8_Info(0x01000153), tag: [1(0x01)], length_string: [1(0x0001)], value_string: [S(0x53)]]
attributes_count: [0(0x0000)]
attributes: []
...
[20] Field_Info(0x00100092008e0001009300000002009403000003db)
access_flag: [Field_Access_Flag(0x0010), value: [16(0x0010)], FLAGs: [[ACC_FINAL]]]
name_index: [146(0x0092)]
valueof_name_index: [Constant_Utf8_Info(0x010004696e7435), tag: [1(0x01)], length_string: [4(0x0004)], value_string: [int5(0x696e7435)]]
descriptor_index: [142(0x008e)]
valueof_descriptor_index: [Constant_Utf8_Info(0x01000149), tag: [1(0x01)], length_string: [1(0x0001)], value_string: [I(0x49)]]
attributes_count: [1(0x0001)]
attributes: [[Attribute_ConstantValue(0x009300000002009403000003db), name_index: [147(0x0093)], valueof_name_index: [Constant_Utf8_Info(0x01000d436f6e7374616e7456616c7565), tag: [1(0x01)], length_string: [13(0x000d)], value_string: [ConstantValue(0x436f6e7374616e7456616c7565)]], length: [2(0x00000002)], constant_index: [148(0x0094)], valueof_constant_index: [Constant_Integer_Info(0x03000003db), tag: [3(0x03)], value: [987(0x000003db)]], constant_value_clazzs: [[class model.Constant_Long_Info], [class model.Constant_Float_Info], [class model.Constant_Double_Info], [class model.Constant_Integer_Info], [class model.Constant_String_Info]]]]
...
```

例子1，表示boolean boolean1 = false; 中字段boolean1

例子2，表示short short1 = 12345; 中字段short1

例子3，表示final int int5 = 987; 中字段int5，注意到这个字段是有一个属性值ConstantValue，它表示该字段是由final修饰的，下文会提到

#### 字段访问标志

|标志名称|标志值|含义|
|--|--|--|
|ACC_PUBLIC|0x0001|字段是否声明为public|
|ACC_PRIVATE|0x0002|字段是否声明为private|
|ACC_PROTECTED|0x0004|字段是否声明为protected|
|ACC_STATIC|0x0008|字段是否声明为static|
|ACC_FINAL|0x0010|字段是否声明为final|
|ACC_VOLATILE|0x0040|字段是否声明为volatile|
|ACC_TRANSIENT|0x0080|字段是否声明为transient|
|ACC_SYNTHETIC|0x1000|字段是否由编译器自动产生的|
|ACC_ENUM|0x4000|字段是否是enum类型|

#### 访问权限修饰符的作用域

来复习一下JAVA中4种访问修饰符的作用域

|修饰符|类内部|同包|子类|其他类|
|--|--|--|--|--|
|public|Y|Y|Y|Y|
|protected|Y|Y|Y|N|
|friendly(default)|Y|Y|N|N|
|private|Y|N|N|N|

Y表示可访问，N表示不可访问

记忆中比较容易混淆的是protected与default在同包和子类中的权限，可以这么记，protected可作用于子类，default可作用于同包，protected权限比default大（p比d大），protected也可以作用于同包

#### 描述符

描述符是用来描述字段的数据类型和名称，方法的参数列表（包括数量、类型、名称、顺序）、返回值和名称

针对8种基本类型、引用类型和void类型，都分别用一个大写字母来表示，称为标识符
- B：byte
- Z：boolean
- C：char
- S：short
- I：int
- F：float
- L：long
- D：double
- L：引用类型
- V：void

对于普通类的字段，表示方法是 标识符 + 全限定名，比如 java.lang.Object => Ljava/lang/Object、int int1 => Iint1、bool boolean1 => Zboolean1

对于数组类的字段，表示方法是 维度符 + 标识符 + 全限定名，比如 java.lang.String[][] => [[Ljava/lang/Object

### 方法表

### 类属性表
