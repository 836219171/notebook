# 类加载机制

### 类加载的定义

> The Java ClassLoader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine. The Java run time system does not need to know about files and file systems because of classloaders. Java classes aren't loaded into memory all at once, but when required by an application. From https://www.geeksforgeeks.org/classloader-in-java/

**类加载（包括类加载器）是Java虚拟机运行时环境的一部分，它能够动态地将Java类文件加载进入JVM中。**

由于类加载等过程实现了多平台的支持，因此Java是跨平台的

类加载是懒加载模式，并非一次性将所有.class文件都加载，而是需要时加载

### 类加载的输入和输出结果

类加载是JVM启动后靠前的几步之一

输入是.class文件

输出是许多数据写入内存区域，比如InstanceKlass到方法区，InstanceMirrorKlass到堆区

#### TODO
- 除了InstanceKlass和InstanceMirrorKlass，还有InstanceRefKlass、ArrayKlass、TypeArrayKlass、ObjArrayKlass，它们分别是写到内存区域中哪一块？
- 写入方法区和堆区有代码例子证明吗？

参考：[jvm运行时环境全景图](https://github.com/peteryuanpan/notebook/blob/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%E4%B8%80%E8%87%B3%E5%9B%9B%E5%B1%82/README.md#jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%A8%E6%99%AF%E5%9B%BE)

![image](http://tswork.peterpy.cn/java_runtime.png)

### InstanceKlass和InstanceMirrorKlass是什么

Klass是Java类在JVM中的存在形式（补充：OOP是JAVA对象在JVM中的存在形式）

InstanceKlass是类的元信息数据

InstanceMirrorKlass是类的Class对象

参考：[鲁班学院 第三期第一节 带你探索JVM底层之类加载](https://github.com/peteryuanpan/notebook/issues/43)

![image](https://user-images.githubusercontent.com/10209135/89729486-ced8f380-da68-11ea-81d4-e4b19825a4a0.png)

来看一下openjdk8源码

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/hotspot/src/share/vm/oops/instanceKlass.hpp#L138

```cpp
// An InstanceKlass is the VM level representation of a Java class.
// It contains all information needed for at class at execution runtime.

//  InstanceKlass layout:
//    [C++ vtbl pointer           ] Klass
//    [subtype cache              ] Klass
//    [instance size              ] Klass
//    [java mirror                ] Klass
//    [super                      ] Klass
//    [access_flags               ] Klass
//    [name                       ] Klass
//    [first subklass             ] Klass
//    [next sibling               ] Klass
//    [array klasses              ]
//    [methods                    ]
//    [local interfaces           ]
//    [transitive interfaces      ]
//    [fields                     ]
//    [constants                  ]
//    [class loader               ]
//    [source file name           ]
//    [inner classes              ]
//    [static field size          ]
//    [nonstatic field size       ]
//    [static oop fields size     ]
//    [nonstatic oop maps size    ]
//    [has finalize method        ]
//    [deoptimization mark bit    ]
//    [initialization state       ]
//    [initializing thread        ]
//    [Java vtable length         ]
//    [oop map cache (stack maps) ]
//    [EMBEDDED Java vtable             ] size in words = vtable_len
//    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
//      The embedded nonstatic oop-map blocks are short pairs (offset, length)
//      indicating where oops are located in instances of this klass.
//    [EMBEDDED implementor of the interface] only exist for interface
//    [EMBEDDED host klass        ] only exist for an anonymous class (JSR 292 enabled)

class InstanceKlass: public Klass {
  friend class VMStructs;
  friend class ClassFileParser;
  friend class CompileReplay;

 protected:
  // Constructor
  InstanceKlass(int vtable_len,
                int itable_len,
                int static_field_size,
                int nonstatic_oop_map_size,
                ReferenceType rt,
                AccessFlags access_flags,
                bool is_anonymous);
```

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/hotspot/src/share/vm/oops/instanceMirrorKlass.hpp#L41

```cpp
// An InstanceMirrorKlass is a specialized InstanceKlass for
// java.lang.Class instances.  These instances are special because
// they contain the static fields of the class in addition to the
// normal fields of Class.  This means they are variable sized
// instances and need special logic for computing their size and for
// iteration of their oops.

class InstanceMirrorKlass: public InstanceKlass {
  friend class VMStructs;
  friend class InstanceKlass;

 private:
  static int _offset_of_static_fields;

  // Constructor
  InstanceMirrorKlass(int vtable_len, int itable_len, int static_field_size, int nonstatic_oop_map_size, ReferenceType rt, AccessFlags access_flags,  bool is_anonymous)
    : InstanceKlass(vtable_len, itable_len, static_field_size, nonstatic_oop_map_size, rt, access_flags, is_anonymous) {}

 public:
  InstanceMirrorKlass() { assert(DumpSharedSpaces || UseSharedSpaces, "only for CDS"); }
  // Type testing
  bool oop_is_instanceMirror() const             { return true; }
```

可以看出来
- InstanceKlass中定义了Java运行时环境类所需的所有数据信息，比如 constants 常量池、static field size 静态成员变量大小、methods 方法 等（An InstanceKlass is the VM level representation of a Java class. It contains all information needed for at class at execution runtime.）
- InstanceMirrorKlass是InstanceKlass的一个子类
- InstanceMirrorKlass是java.lang.Class类专用的InstanceKlass（An InstanceMirrorKlass is a specialized InstanceKlass for java.lang.Class instances.）

简单总结一下，InstanceKlass包含了Java运行时环境中类所需的所有数据信息，在类加载这一步，类加载器会将.class文件读入类加载器的class content，然后以InstanceKlass的形式写入JVM内存区域的方法区中，而InstanceMirrorKlass是类所对应的Class对象（java.lang.Class）的InstanceKlass

> 辗转反侧了很久，终于理解了InstanceKlass和InstanceMirrorKlass。（2020-09-03）

> 对于InstanceKlass，在Java中，对于所有类，类的内部属性轮廓是不是可以认为是一样的？类都有父类、实现接口、变量、方法、代码块等，而变量和方法也有属性，即可访问性（public、private、protected、default）、静态与非静态，还有数组形式的。无论如何，类的内部属性以及属性的属性，是有限的、可列举的，那么在JVM中以C++代码就可以用一个类来表示，它就是IntanceKlass，这一层是比较好理解的。

> 对于InstanceMirrorKlass的理解，首先需要理解什么是java.lang.Class，我们来看一下这个类的注释吧：Instances of the class Class represent classes and interfaces in a running Java application. 翻译过来说，就是类或接口在Java运行时环境中的一个表达方式，再看看java.lang.Class的方法就知道，getConstructors()、getMethods()、getFields()、getDeclaredFields()，这些都是类的内部属性，且对于任何类来说，都可以用形如A.class的方法来获取java.lang.Class，即每个Java类都有一个java.lang.Class，那么在JVM中以C++代码表示，每个类的java.lang.Class就是InstanceMirrorKlass。java.lang.Class也是一个类，InstanceMirrorKlass是InstanceKlass的子类。

小补充下，关于InstanceRefKlass、ArrayKlass、TypeArrayKlass、ObjArrayKlass，可以参考：[关于JVM中InstanceKlass及ArrayKlass的理解](https://github.com/peteryuanpan/notebook/issues/49)

### 类加载什么时候会进行

参考
- [Java类加载及其关键过程原理：加载](https://github.com/peteryuanpan/notebook/issues/54#issuecomment-674741086)
- 《深入理解Java虚拟机》第二版 7.2节

四种情况
- 虚拟机启动后，会加载main函数所在的类
- 执行到 new、getstatic、putstatic、invokestatic 这4条字节码指令时，会进行类加载
- 初始化一个类时，会去加载其父类
- 对类进行反射调用时，会加载该类

这四种情况可以分别举一下例子吗？

#### 虚拟机启动后，会加载main函数所在的类

TODO

#### 执行到 new、getstatic、putstatic、invokestatic 这4条字节码指令时，会进行类加载

new：[JAVA字节码手册/new](https://github.com/peteryuanpan/notebook/blob/master/JAVA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%8B%E5%86%8C/new.md)

putsatic：[JAVA字节码手册/putstatic](https://github.com/peteryuanpan/notebook/blob/master/JAVA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%8B%E5%86%8C/putstatic.md)

getstatic：[JAVA字节码手册/getstatic](https://github.com/peteryuanpan/notebook/blob/master/JAVA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%8B%E5%86%8C/getstatic.md)

invokestatic：[JAVA字节码手册/invokestatic](https://github.com/peteryuanpan/notebook/blob/master/JAVA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%8B%E5%86%8C/invokestatic.md)

注意：newarray，anewarray不会触发类加载

#### 初始化一个类时，会去加载其父类

加载一个类时，会先去加载它的父类，参考：[JAVA字节码手册/invokestatic#code2](https://github.com/peteryuanpan/notebook/blob/master/JAVA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%8B%E5%86%8C/invokestatic.md#code2)

加载一个父类时，不会去加载它的子类，参考：[JAVA字节码手册/invokestatic#code3](https://github.com/peteryuanpan/notebook/blob/master/JAVA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%8B%E5%86%8C/invokestatic.md#code3)

#### 对类进行反射调用时，会加载该类

TODO
