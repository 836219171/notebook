# 类加载机制

### 类加载的定义

> The Java ClassLoader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine. The Java run time system does not need to know about files and file systems because of classloaders. Java classes aren't loaded into memory all at once, but when required by an application. From https://www.geeksforgeeks.org/classloader-in-java/

**类加载（包括类加载器）是Java虚拟机运行时环境的一部分，它能够动态地将Java类文件加载进入JVM中。**

由于类加载等过程实现了多平台的支持，因此Java是跨平台的

类加载是懒加载模式，并非一次性将所有类文件都加载，而是需要时加载

### 类加载的输入和输出结果

类加载是JVM启动后靠前的几步，输入是.class文件，输出是许多数据写入内存区域，比如InstanceKlass到方法区，InstanceMirrorKlass到堆区。参考[jvm运行时环境全景图](https://github.com/peteryuanpan/notebook/blob/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%E4%B8%80%E8%87%B3%E5%9B%9B%E5%B1%82/README.md#jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%A8%E6%99%AF%E5%9B%BE)

TODO：除了InstanceKlass和InstanceMirrorKlass，还有哪些关键数据指的一提？

TODO：写入方法区和堆区有代码例子证明吗？

### InstanceKlass和InstanceMirrorKlass是什么

Klass是Java类在JVM中的存在形式（补充：OOP是JAVA对象在JVM中的存在形式）

InstanceKlass是类的元信息数据

InstanceMirrorKlass是类的Class对象

参考：[鲁班学院 第三期第一节 带你探索JVM底层之类加载](https://github.com/peteryuanpan/notebook/issues/43)

![image](https://user-images.githubusercontent.com/10209135/89729486-ced8f380-da68-11ea-81d4-e4b19825a4a0.png)

来看一下openjdk8源码

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/hotspot/src/share/vm/oops/instanceKlass.hpp#L138

```cpp
class InstanceKlass: public Klass {
  friend class VMStructs;
  friend class ClassFileParser;
  friend class CompileReplay;

 protected:
  // Constructor
  InstanceKlass(int vtable_len,
                int itable_len,
                int static_field_size,
                int nonstatic_oop_map_size,
                ReferenceType rt,
                AccessFlags access_flags,
                bool is_anonymous);
                
 public:
  static InstanceKlass* allocate_instance_klass(
                                          ClassLoaderData* loader_data,
                                          int vtable_len,
                                          int itable_len,
                                          int static_field_size,
                                          int nonstatic_oop_map_size,
                                          ReferenceType rt,
                                          AccessFlags access_flags,
                                          Symbol* name,
                                          Klass* super_klass,
                                          bool is_anonymous,
                                          TRAPS);

  InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, "only for CDS"); }
```

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/hotspot/src/share/vm/oops/instanceMirrorKlass.hpp#L41

```cpp
class InstanceMirrorKlass: public InstanceKlass {
  friend class VMStructs;
  friend class InstanceKlass;

 private:
  static int _offset_of_static_fields;

  // Constructor
  InstanceMirrorKlass(int vtable_len, int itable_len, int static_field_size, int nonstatic_oop_map_size, ReferenceType rt, AccessFlags access_flags,  bool is_anonymous)
    : InstanceKlass(vtable_len, itable_len, static_field_size, nonstatic_oop_map_size, rt, access_flags, is_anonymous) {}

 public:
  InstanceMirrorKlass() { assert(DumpSharedSpaces || UseSharedSpaces, "only for CDS"); }
  // Type testing
  bool oop_is_instanceMirror() const             { return true; }

  // Casting from Klass*
  static InstanceMirrorKlass* cast(Klass* k) {
    assert(k->oop_is_instanceMirror(), "cast to InstanceMirrorKlass");
    return (InstanceMirrorKlass*) k;
  }
```
