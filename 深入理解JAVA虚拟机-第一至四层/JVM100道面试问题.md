- [JVM100道面试问题](#JVM100道面试问题)
  - [JVM面试之类加载](#JVM面试之类加载)
    - [类加载机制](#类加载机制)
  - [JVM面试之运行时数据区域](#JVM面试之运行时数据区域)
    - [运行时数据区域](#运行时数据区域)
    - [程序计数器](#程序计数器)
    - [虚拟机栈及本地方法栈](#虚拟机栈及本地方法栈)
    - [方法区](#方法区)
    - [永久代与元空间](#永久代与元空间)
    - [堆区](#堆区)

# JVM100道面试问题

## JVM面试之类加载

### 类加载机制

- 类加载的定义
- 类加载的时机
- 类加载的目的

1、类加载是Java虚拟机将class数据二进制字节流读入类加载器，解析出类的元信息（InstanceKlass）并写入方法区，解析出类的Class对象（InstanceMirrorKlass）并写入堆区等过程

[补充]class数据二进制字节流无关乎来源，可以是操作系统文件（单个文件 或 jar包中），可以是网络流数据，可以是数据库数据等

[补充]javac编译器会将.java文件编译成.class文件，用于java虚拟机类加载

3、类加载会在4种情况下执行
- java虚拟机启动时，加载mainClass（main方法所在的类）
- 字节码引擎执行遇到new、putstatic、getstatic、invokestatic时，若对应类未被加载，会进行类加载
- 加载一个类时，若父类未被加载，会优先加载父类，再加载子类
- 利用反射机制（Class.forname(packageName.ClassName)）加载一个类时，会进行类加载

4、类加载的目的是将class数据解析成类的元信息、类的Class对象等数据存入运行时数据区域，为后续的对象实例化、静态变量的取值及赋值、静态方法的调用等过程提供数据准备

## JVM面试之运行时数据区域

### 运行时数据区域

- 定义
- 五大部分

1、Java虚拟机在操作系统中申请了一块内存区域，用于运行Java程序

2、这块内存区域中有5个部分，分别是程序计数器、虚拟机栈、本地方法栈、方法区、堆区

### 程序计数器

- 定义：字节码行号指示器
- 线程私有
- 与字节码解释器的关系

1、程序计数器是线程所执行的字节码的行号指示器

2、线程私有的，每个线程都有一个程序计数器

3、字节码解释器工作时就是改变程序计数器的计数值来选取下一行需要执行的字节码指令

### 虚拟机栈及本地方法栈

- 定义，方法调用与执行的内存模型
- 线程私有
- 与本地方法栈的关系
- 与栈帧的关系
- 栈溢出例子

1、虚拟机栈描述的是Java方法调用与执行的内存模型

2、线程私有的，每个线程都有一个虚拟机栈及本地方法栈

3、本地方法栈为native方法服务，虚拟机栈为非native方法服务

4、栈帧是虚拟机栈的基本元素，每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程，即一个栈帧对应着一次方法调用执行

5、栈帧中含有局部变量表、操作数栈、动态链接、方法返回地址、附加信息

6、栈溢出例子
- 单线程调用方法过深导致栈深度溢出，报错java.lang.StackOverflowError
- 过多线程调用方法导致OutOfMemory，报错java.lang.OutOfMemoryError: unable to create new native thread

### 方法区

- 定义，主要存放类的元信息
- 线程共享
- 永久代与元空间
- 运行时常量池
- 方法区溢出例子

1、方法区用于存放类的元信息，如类名、父类名、运行时常量池、字段描述、方法描述、访问修饰符等

2、方法区是线程共享的内存区域

3、方法区是规范，永久代（PermGen）和元空间（Metaspace）是具体实现。在JDK6及以前，方法区的实现就只有永久代；JDK7时部分数据移出了永久代；JDK8彻底放弃永久代，改用元空间

4、运行时常量池是方法区的一部分。类加载过程中，会读取Class文件的常量池（用于存放编译器生成的各种字面量和符号引用），存放于方法区的运行时常量池

[补充]容易混淆的是运行时常量池与字符串常量池，前者是在方法区，后者是在堆区，前者是存储各种字面量、符号引用（包括字符串常量的），后者存储的是指向堆区中字符串对象的引用（只有java.lang.String实例的引用）

5、方法区溢出例子
- 基于JDK6的字符串常量池溢出，不断String.valueOf(i++).intern()
- 使用CGLib让方法区内存溢出，不断创建动态类

### 永久代与元空间

- JDK6到8的变化
  - 类的元信息
  - 运行时常量池
  - 符号引用
  - 静态变量
  - 字符串常量池
  - 内存的连续性
- 元空间取代永久代的理由
  - OOM问题
  - 垃圾回收
  - 计算机内存的发展
  - HotSpot与JRockit代码合并

JDK6到8的变化

|模块|JDK6中|JDK7中|JDK8中|
|--|--|--|--|
|类的元信息|永久代|永久代|元空间|
|运行时常量池|永久代|永久代|元空间|
|符号引用|永久代|本地内存（Native Memory）|本地内存|
|静态变量|永久代|堆区（Java Heap）|堆区|
|字符串常量池|永久代|堆区|堆区|
|内存的连续性|永久代与堆区内存连续|永久代与堆区内存连续|元空间与堆区内存不连续|

元空间取代永久代的理由

这是一个开放性的问题，从几个方面来回答：OOM问题、垃圾回收、计算机内存的发展、HotSpot与JRockit代码合并

1、永久代到元空间，不再受堆区的内存限制，而受本地内存限制，限制方法了，OOM问题解决能力得到了一定提升

2、永久代的垃圾收集是与堆区的老年代捆绑在一起的，无论谁满了，都会触发永久代和老年代的垃圾收集，这给垃圾回收造成了一定的麻烦，而元空间用本地内存（Native Memory）实现，不会触发垃圾回收

3、还有一个深层的原因，计算机内存的发展，起初是计算机内存是很小的，慢慢的开始有32位，但依然需要限制，因此永久代与堆区绑在一起，要限制一起限制，而后来有64位，内存允许越来越宽松，敢把方法区用本地内存来实现了

4、更深层的原因还是要合并HotSpot和JRockit的代码，JRockit从来没有所谓的永久代，也不需要开发运维人员设置永久代的大小，但是运行良好。同时也不用担心运行性能问题了，在覆盖到的测试中，程序启动和运行速度降低不超过1%，但是这点性能损失换来了更大的安全保障

### 堆区
