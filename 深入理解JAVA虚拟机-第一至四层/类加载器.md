- [类加载器](#类加载器)
  - [类加载器的定义](#类加载器的定义)
  - [类加载的唯一性](#类加载的唯一性)
  - [双亲委派模型的定义](#双亲委派模型的定义)
  - [启动类加载器](#启动类加载器)
    - [启动类加载器的定义](#启动类加载器的定义)
    - [启动类加载器的管辖范围](#启动类加载器的管辖范围)
  - [拓展类加载器](#拓展类加载器)
    - [拓展类加载器的定义](#拓展类加载器的定义)
    - [拓展类加载器的管辖范围](#拓展类加载器的管辖范围)
  - [应用类加载器](#应用类加载器)
    - [应用类加载器的定义](#应用类加载器的定义)
    - [应用类加载器的管辖范围](#应用类加载器的管辖范围)
  - [双亲委派模型在JVM源码中的实现](#双亲委派模型在JVM源码中的实现)
  - [破坏双亲委派模型](#破坏双亲委派模型)
    - [破坏双亲委派模型的意义](#破坏双亲委派模型的意义)
    - [线程上下文类加载器与SPI机制](#线程上下文类加载器与SPI机制)
    - [自定义类加载器](#自定义类加载器)
  - [深入理解ClassLoader类](#深入理解ClassLoader类)
    
# 类加载器

### 类加载器的定义

类加载阶段中，“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作称为加载，实现这个动作的代码模块称为“类加载器”

类加载器一共可分为几种：启动类加载器（Bootstrap ClassLoader）、拓展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）、线程上下文类加载器（Thread Context ClassLoader）、自定义类加载器

### 类加载的唯一性

两个类相等，当且仅当，这两个类来源于同一个Class文件 且 被同一个类加载器加载

下面的代码示例演示了关于instanceof判定不同类加载器加载同一个类的字节流的结果

```java
package com.peter.jvm.example;

import java.io.InputStream;

public class ClassLoaderDefineClassTest1 {

    public static void main(String[] arg) throws Exception {
        ClassLoader myLoader = new ClassLoader() {
            @Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                try {
                    String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class";
                    InputStream is = getClass().getResourceAsStream(fileName);
                    System.out.println(name + (is == null ? " is null" : " is NOT null"));
                    if (is == null) {
                        return super.loadClass(name);
                    }
                    byte[] b = new byte[is.available()];
                    is.read(b);
                    return defineClass(name, b, 0, b.length);
                } catch (Exception e) {
                    throw new ClassNotFoundException(name);
                }
            }
        };
        Object obj = myLoader.loadClass("com.peter.jvm.example.ClassLoaderDefineClassTest1").newInstance();
        System.out.println(obj.getClass());
        System.out.println(obj instanceof com.peter.jvm.example.ClassLoaderDefineClassTest1);
    }
}
```

输出结果
```
com.peter.jvm.example.ClassLoaderDefineClassTest1 is NOT null
java.lang.Object is null
java.lang.ClassLoader is null
com.peter.jvm.example.ClassLoaderDefineClassTest1$1 is NOT null
class com.peter.jvm.example.ClassLoaderDefineClassTest1
false
```

解释

myLoader.loadClass("com.peter.jvm.example.ClassLoaderDefineClassTest1").newInstance();

调用自定义类加载器 读取类（com.peter.jvm.example.ClassLoaderDefineClassTest1）的字节流，并实例化

defineClass用于读取字节流，最终是一个native方法

Object obj是通过myLoader实例化的对象，它的class确实是com.peter.jvm.example.ClassLoaderDefineClassTest1

但是，由于类加载器不一致，因此myLoader与启动类加载器加载的类不相等，instance结果也为false

### 双亲委派模型的定义

双亲委派模型是类加载器之间的逻辑父子层级关系

双亲委派模型的工作过程是
- 如果一个类加载收到了来加载请求，先检查是否已经被加载过，加载过则返回
- 若没有加载则调用父类加载器的locadClass()方法
- 若父类加载为空则默认使用启动类加载器作为父加载器
- 若父类加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载

使用ClassLoader中的loadClass方法可以更直观的看明白这个过程

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/classes/java/lang/ClassLoader.java#L401
```java
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

#### 双亲委派模型的时序图

![image](https://camo.githubusercontent.com/66b56028009831b2d3c4b87bf7530fadf8277606/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f323137393831352f313539363138303137353132392d31303161373435312d363462382d346436612d386165392d3439663931356636646633342e706e67)

### 启动类加载器

#### 启动类加载器的定义

启动类加载器（Bootstrap ClassLoader）是JVM最根层的类加载器，由C++代码实现。它是所有类加载器的祖宗，在双亲委派模型下，所有类都会优先交给启动类加载器去加载

在【双亲委派模型的定义】中，有一行代码，c = findBootstrapClassOrNull(name); 含义是从启动类加载器加载名字为name的Class

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/classes/java/lang/ClassLoader.java#L1008

```java
    /**
     * Returns a class loaded by the bootstrap class loader;
     * or return null if not found.
     */
    private Class<?> findBootstrapClassOrNull(String name)
    {
        if (!checkName(name)) return null;

        return findBootstrapClass(name);
    }

    // return null if not found
    private native Class<?> findBootstrapClass(String name);
```

findBootstrapClass是一个native方法，来查看虚拟机源码

unix实现

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/solaris/bin/java_md_common.c#L491

```cpp
/*
 * The implementation for finding classes from the bootstrap
 * class loader, refer to java.h
 */
static FindClassFromBootLoader_t *findBootClass = NULL;

jclass
FindBootStrapClass(JNIEnv *env, const char* classname)
{
   if (findBootClass == NULL) {
       findBootClass = (FindClassFromBootLoader_t *)dlsym(RTLD_DEFAULT,
          "JVM_FindClassFromBootLoader");
       if (findBootClass == NULL) {
           JLI_ReportErrorMessage(DLL_ERROR4,
               "JVM_FindClassFromBootLoader");
           return NULL;
       }
   }
   return findBootClass(env, classname);
}
```

它调用了unix系统的dlsym函数，去加载JVM_FindClassFromBootLoader

> The function dlsym() takes a "handle" of a dynamic loaded shared object returned by dlopen(3) along with a null-terminated symbol name, and returns the address where that symbol is loaded into memory. From https://man7.org/linux/man-pages/man3/dlsym.3.html

windows实现

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/windows/bin/java_md.c#L1238

```cpp
/*
 * The implementation for finding classes from the bootstrap
 * class loader, refer to java.h
 */
static FindClassFromBootLoader_t *findBootClass = NULL;

jclass FindBootStrapClass(JNIEnv *env, const char *classname)
{
   HMODULE hJvm;

   if (findBootClass == NULL) {
       hJvm = GetModuleHandle(JVM_DLL);
       if (hJvm == NULL) return NULL;
       /* need to use the demangled entry point */
       findBootClass = (FindClassFromBootLoader_t *)GetProcAddress(hJvm,
            "JVM_FindClassFromBootLoader");
       if (findBootClass == NULL) {
          JLI_ReportErrorMessage(DLL_ERROR4, "JVM_FindClassFromBootLoader");
          return NULL;
       }
   }
   return findBootClass(env, classname);
}
```

它调用了windows系统的GetProcAddress函数，去加载JVM_FindClassFromBootLoader

> Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL). From https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress

#### 启动类加载器的管辖范围

启动类加载器负责将存放在<JAVA_HOME>/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，且是虚拟机识别（仅按照文件名识别）的类库加载到虚拟机内存中

##### 查看JAVA_HOME目录

> On Linux you can run $(dirname $(dirname $(readlink -f $(which javac))))<br>
> On Mac you can run $(dirname $(readlink $(which javac)))/java_home<br>
> I'm not sure about windows but I imagine where javac would get you pretty close<br>
> From https://stackoverflow.com/questions/1117398/java-home-directory-in-linux

在我的MACOS下执行，结果是
```
$(dirname $(readlink $(which javac)))/java_home
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home
```

在我的WINDOWS10下执行，结果是

TODO

##### 查看JAVA_HOME/lib目录

在我的MACOS下执行，结果是
```
➜  ~ ll /Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib
total 78848
-rw-r--r--   1 root  wheel   1.1M  3 29  2018 ant-javafx.jar
-rw-r--r--   1 root  wheel    17M  3 29  2018 ct.sym
-rw-r--r--   1 root  wheel   159K  3 29  2018 dt.jar
-rw-r--r--   1 root  wheel    18K  3 29  2018 ir.idl
-rw-r--r--   1 root  wheel    35K  3 29  2018 javafx-mx.jar
-rw-r--r--   1 root  wheel   398K  3 29  2018 jconsole.jar
drwxr-xr-x  13 root  wheel   416B  3 29  2018 missioncontrol
-rw-r--r--   1 root  wheel   640B  3 29  2018 orb.idl
-rw-r--r--   1 root  wheel   4.5K  3 29  2018 packager.jar
-rw-r--r--   1 root  wheel   2.3M  3 29  2018 sa-jdi.jar
-rw-r--r--   1 root  wheel    17M  3 29  2018 tools.jar
drwxr-xr-x   6 root  wheel   192B  1 15  2017 visualvm
```

在我的WINDOWS10下执行，结果是

TODO

### 拓展类加载器

#### 拓展类加载器的定义

#### 拓展类加载器的管辖范围

### 应用类加载器

#### 应用类加载器的定义

#### 应用类加载器的管辖范围
