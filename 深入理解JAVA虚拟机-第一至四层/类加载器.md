- [类加载器](#类加载器)
  - [类加载器的定义](#类加载器的定义)
  - [类加载的唯一性](#类加载的唯一性)
  - [双亲委派模型的定义](#双亲委派模型的定义)
  - [启动类加载器](#启动类加载器)
    - [启动类加载器的定义](#启动类加载器的定义)
    - [启动类加载器的管辖范围](#启动类加载器的管辖范围)
  - [拓展类加载器](#拓展类加载器)
    - [拓展类加载器的定义](#拓展类加载器的定义)
    - [拓展类加载器的管辖范围](#拓展类加载器的管辖范围)
  - [应用类程序加载器](#应用类程序加载器)
    - [应用类程序加载器的定义](#应用类程序加载器的定义)
    - [应用类程序加载器的管辖范围](#应用类程序加载器的管辖范围)
  - [深入理解双亲委派模型源码](#深入理解双亲委派模型源码)
  - [破坏双亲委派模型的定义](#破坏双亲委派模型的定义)
  - [自定义类加载器](#自定义类加载器)
    - [自定义类加载器打破双亲委派的关键](#自定义类加载器打破双亲委派的关键)
    - [自定义类加载器例子1](#自定义类加载器例子1)
    - [自定义类加载器例子2](#自定义类加载器例子2)
  - [SPI机制与线程上下文类加载器](#SPI机制与线程上下文类加载器)
    - [SPI机制的定义](#SPI机制的定义)
    - [SPI机制例子之ServiceLoader](#SPI机制例子之ServiceLoader)
    - [ServiceLoader类加载源码](#ServiceLoader类加载源码)
    - [SPI机制例子之JDBCMysql](#SPI机制例子之JDBCMysql)
    - [DriverManager类加载源码](#DriverManager类加载源码)
  
# 类加载器

### 类加载器的定义

类加载阶段中，“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作称为加载，实现这个动作的代码模块称为“类加载器”

类加载器一共可分为几种：启动类加载器（Bootstrap ClassLoader）、拓展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）、线程上下文类加载器（Thread Context ClassLoader）、自定义类加载器

### 类加载的唯一性

两个类相等，当且仅当，这两个类来源于同一个Class文件 且 被同一个类加载器加载

下面的代码示例演示了关于instanceof判定不同类加载器加载同一个类的字节流的结果

```java
package com.peter.jvm.example;

import java.io.InputStream;

public class ClassLoaderDefineClassTest1 {

    public static void main(String[] arg) throws Exception {
        ClassLoader myLoader = new ClassLoader() {
            @Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                try {
                    String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class";
                    InputStream is = getClass().getResourceAsStream(fileName);
                    System.out.println(name + (is == null ? " is null" : " is NOT null"));
                    if (is == null) {
                        return super.loadClass(name);
                    }
                    byte[] b = new byte[is.available()];
                    is.read(b);
                    return defineClass(name, b, 0, b.length);
                } catch (Exception e) {
                    throw new ClassNotFoundException(name);
                }
            }
        };
        Object obj = myLoader.loadClass("com.peter.jvm.example.ClassLoaderDefineClassTest1").newInstance();
        System.out.println(obj.getClass());
        System.out.println(obj instanceof com.peter.jvm.example.ClassLoaderDefineClassTest1);
    }
}
```

输出结果
```
com.peter.jvm.example.ClassLoaderDefineClassTest1 is NOT null
java.lang.Object is null
java.lang.ClassLoader is null
com.peter.jvm.example.ClassLoaderDefineClassTest1$1 is NOT null
class com.peter.jvm.example.ClassLoaderDefineClassTest1
false
```

解释

myLoader.loadClass("com.peter.jvm.example.ClassLoaderDefineClassTest1").newInstance();

调用自定义类加载器 读取类（com.peter.jvm.example.ClassLoaderDefineClassTest1）的字节流，并实例化

defineClass用于读取字节流，最终是一个native方法

Object obj是通过myLoader实例化的对象，它的class确实是com.peter.jvm.example.ClassLoaderDefineClassTest1

但是，由于类加载器不一致，因此myLoader与启动类加载器加载的类不相等，instance结果也为false

### 双亲委派模型的定义

双亲委派模型是类加载器之间的逻辑父子层级关系，目的是保护父或根类加载器加载类的纯净性

双亲委派模型的工作过程是
- 如果一个类加载收到了来加载请求，先检查是否已经被加载过，加载过则返回
- 若没有加载则调用父类加载器的locadClass()方法
- 若父类加载为空则默认使用启动类加载器作为父加载器
- 若父类加载器加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载

使用ClassLoader中的loadClass方法可以更直观的看明白这个过程

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/classes/java/lang/ClassLoader.java#L401

```java
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

#### 双亲委派模型的时序图

![image](https://camo.githubusercontent.com/66b56028009831b2d3c4b87bf7530fadf8277606/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f323137393831352f313539363138303137353132392d31303161373435312d363462382d346436612d386165392d3439663931356636646633342e706e67)

### 启动类加载器

#### 启动类加载器的定义

启动类加载器（Bootstrap ClassLoader）是JVM最根层的类加载器，由C++代码实现。它是所有类加载器的祖宗，在双亲委派模型下，所有类都会优先交给启动类加载器去加载

在【双亲委派模型的定义】中，有一行代码，c = findBootstrapClassOrNull(name); 含义是从启动类加载器加载名字为name的Class

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/classes/java/lang/ClassLoader.java#L1008

```java
    /**
     * Returns a class loaded by the bootstrap class loader;
     * or return null if not found.
     */
    private Class<?> findBootstrapClassOrNull(String name)
    {
        if (!checkName(name)) return null;

        return findBootstrapClass(name);
    }

    // return null if not found
    private native Class<?> findBootstrapClass(String name);
```

findBootstrapClass是一个native方法，来查看虚拟机源码

unix实现

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/solaris/bin/java_md_common.c#L491

```cpp
/*
 * The implementation for finding classes from the bootstrap
 * class loader, refer to java.h
 */
static FindClassFromBootLoader_t *findBootClass = NULL;

jclass
FindBootStrapClass(JNIEnv *env, const char* classname)
{
   if (findBootClass == NULL) {
       findBootClass = (FindClassFromBootLoader_t *)dlsym(RTLD_DEFAULT,
          "JVM_FindClassFromBootLoader");
       if (findBootClass == NULL) {
           JLI_ReportErrorMessage(DLL_ERROR4,
               "JVM_FindClassFromBootLoader");
           return NULL;
       }
   }
   return findBootClass(env, classname);
}
```

它调用了unix系统的dlsym函数，去加载JVM_FindClassFromBootLoader

> The function dlsym() takes a "handle" of a dynamic loaded shared object returned by dlopen(3) along with a null-terminated symbol name, and returns the address where that symbol is loaded into memory. From https://man7.org/linux/man-pages/man3/dlsym.3.html

windows实现

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/windows/bin/java_md.c#L1238

```cpp
/*
 * The implementation for finding classes from the bootstrap
 * class loader, refer to java.h
 */
static FindClassFromBootLoader_t *findBootClass = NULL;

jclass FindBootStrapClass(JNIEnv *env, const char *classname)
{
   HMODULE hJvm;

   if (findBootClass == NULL) {
       hJvm = GetModuleHandle(JVM_DLL);
       if (hJvm == NULL) return NULL;
       /* need to use the demangled entry point */
       findBootClass = (FindClassFromBootLoader_t *)GetProcAddress(hJvm,
            "JVM_FindClassFromBootLoader");
       if (findBootClass == NULL) {
          JLI_ReportErrorMessage(DLL_ERROR4, "JVM_FindClassFromBootLoader");
          return NULL;
       }
   }
   return findBootClass(env, classname);
}
```

它调用了windows系统的GetProcAddress函数，去加载JVM_FindClassFromBootLoader

> Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL). From https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress

#### 启动类加载器的管辖范围

启动类加载器，负责将存放在<JAVA_HOME>/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，且是虚拟机识别（仅按照文件名识别）的类库加载到虚拟机内存中

##### 查看JAVA_HOME

> On Linux you can run $(dirname $(dirname $(readlink -f $(which javac))))<br>
> On Mac you can run $(dirname $(readlink $(which javac)))/java_home<br>
> I'm not sure about windows but I imagine where javac would get you pretty close<br>
> From https://stackoverflow.com/questions/1117398/java-home-directory-in-linux

在我的MACOS下执行，结果是
```
$(dirname $(readlink $(which javac)))/java_home
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home
```
因此JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home

在我的WINDOWS10下执行，结果是
```
where javac
C:\Program Files\Java\jdk1.8.0_231\bin\javac.exe
```
因此JAVA_HOME=C:\Program Files\Java\jdk1.8.0_231

##### 查看JAVA_HOME/lib目录

在我的MACOS下执行，结果是
```
➜  ~ ll /Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib
total 78848
-rw-r--r--   1 root  wheel   1.1M  3 29  2018 ant-javafx.jar
-rw-r--r--   1 root  wheel    17M  3 29  2018 ct.sym
-rw-r--r--   1 root  wheel   159K  3 29  2018 dt.jar
-rw-r--r--   1 root  wheel    18K  3 29  2018 ir.idl
-rw-r--r--   1 root  wheel    35K  3 29  2018 javafx-mx.jar
-rw-r--r--   1 root  wheel   398K  3 29  2018 jconsole.jar
drwxr-xr-x  13 root  wheel   416B  3 29  2018 missioncontrol
-rw-r--r--   1 root  wheel   640B  3 29  2018 orb.idl
-rw-r--r--   1 root  wheel   4.5K  3 29  2018 packager.jar
-rw-r--r--   1 root  wheel   2.3M  3 29  2018 sa-jdi.jar
-rw-r--r--   1 root  wheel    17M  3 29  2018 tools.jar
drwxr-xr-x   6 root  wheel   192B  1 15  2017 visualvm
```

在我的WINDOWS10下执行，结果是
```
C:\Program Files\Java\jdk1.8.0_231\lib>dir

 C:\Program Files\Java\jdk1.8.0_231\lib 的目录

2020/01/12  16:35    <DIR>          .
2020/01/12  16:35    <DIR>          ..
2020/01/12  16:35         1,495,343 ant-javafx.jar
2020/01/12  16:35        17,474,912 ct.sym
2020/01/12  16:35           163,047 dt.jar
2020/01/12  16:35            18,432 ir.idl
2020/01/12  16:35            36,044 javafx-mx.jar
2020/01/12  16:35             1,682 jawt.lib
2020/01/12  16:35           407,728 jconsole.jar
2020/01/12  16:35           747,726 jvm.lib
2020/01/12  16:35    <DIR>          missioncontrol
2020/01/12  16:35               640 orb.idl
2020/01/12  16:35             4,646 packager.jar
2020/01/12  16:35         2,415,574 sa-jdi.jar
2020/01/12  16:35        18,265,035 tools.jar
2020/01/12  16:35    <DIR>          visualvm
              12 个文件     41,030,809 字节
               4 个目录 16,218,456,064 可用字节
```

#### -Xbootclasspath使用例子

执行java -X -help，结果是
```
...
    -Xbootclasspath:<用 ; 分隔的目录和 zip/jar 文件>
                      设置搜索路径以引导类和资源
    -Xbootclasspath/a:<用 ; 分隔的目录和 zip/jar 文件>
                      附加在引导类路径末尾
    -Xbootclasspath/p:<用 ; 分隔的目录和 zip/jar 文件>
                      置于引导类路径之前
...
```

> 具体如何使用命令，还没有了解清楚，TODO

#### 文件名识别规则

> 根据 https://blog.csdn.net/javazejian/article/details/73413292 ，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类<br>
> 但是我实在没找到JVM源码中的例子，TODO

### 拓展类加载器

#### 拓展类加载器的定义

拓展类加载器（Extension ClassLoader）由sun.misc.Launcher$ExtClassLoader实现（JAVA代码），它是启动类加载器的子加载器

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/classes/sun/misc/Launcher.java#L122

```java
    /*
     * The class loader used for loading installed extensions.
     */
    static class ExtClassLoader extends URLClassLoader {

        static {
            ClassLoader.registerAsParallelCapable();
        }

        /**
         * create an ExtClassLoader. The ExtClassLoader is created
         * within a context that limits which files it can read
         */
        public static ExtClassLoader getExtClassLoader() throws IOException
        {
            final File[] dirs = getExtDirs();

            try {
                // Prior implementations of this doPrivileged() block supplied
                // aa synthesized ACC via a call to the private method
                // ExtClassLoader.getContext().

                return AccessController.doPrivileged(
                    new PrivilegedExceptionAction<ExtClassLoader>() {
                        public ExtClassLoader run() throws IOException {
                            int len = dirs.length;
                            for (int i = 0; i < len; i++) {
                                MetaIndex.registerDirectory(dirs[i]);
                            }
                            return new ExtClassLoader(dirs);
                        }
                    });
            } catch (java.security.PrivilegedActionException e) {
                throw (IOException) e.getException();
            }
        }
```

#### 拓展类加载器的管辖范围

拓展类加载器，负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中所有类库

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/classes/sun/misc/Launcher.java#L169

```java
        private static File[] getExtDirs() {
            String s = System.getProperty("java.ext.dirs");
            File[] dirs;
            if (s != null) {
                StringTokenizer st =
                    new StringTokenizer(s, File.pathSeparator);
                int count = st.countTokens();
                dirs = new File[count];
                for (int i = 0; i < count; i++) {
                    dirs[i] = new File(st.nextToken());
                }
            } else {
                dirs = new File[0];
            }
            return dirs;
        }
```

##### 打印拓展类加载器的URLs

```java
package com.peter.jvm.example;

import java.net.URL;
import java.net.URLClassLoader;

public class ExtClassLoaderPath {

    public static void main(String[] args) {
        String property = "java.ext.dirs";
        System.out.println("====================" + property + "'s Urls====================");
        String os_name = System.getProperty("os.name");
        String[] urls;
        if (os_name.toLowerCase().contains("win")) {
            urls = System.getProperty(property).split(";");
        } else {
            urls = System.getProperty(property).split(":");
        }
        for (String url : urls) {
            System.out.println(url);
        }
        System.out.println("====================ExtClassLoaderPath's Urls====================");
        URLClassLoader classLoader = (URLClassLoader) ClassLoader.getSystemClassLoader().getParent();
        URL[] urls1 = classLoader.getURLs();
        for (URL url : urls1) {
            System.out.println(url);
        }
    }
}
```

输出结果（WINDOWS）
```
====================java.ext.dirs's Urls====================
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext
C:\Windows\Sun\Java\lib\ext
====================ExtClassLoaderPath's Urls====================
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/access-bridge-64.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/cldrdata.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/dnsns.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/jaccess.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/jfxrt.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/localedata.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/nashorn.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunec.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunjce_provider.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunmscapi.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunpkcs11.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/zipfs.jar
```

输出结果（MACOS）
```
====================java.ext.dirs's Urls====================
/Users/peteryuanpan/Library/Java/Extensions
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext
/Library/Java/Extensions
/Network/Library/Java/Extensions
/System/Library/Java/Extensions
/usr/lib/java
====================ExtClassLoaderPath's Urls====================
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/sunec.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/nashorn.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/cldrdata.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/jfxrt.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/dnsns.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/localedata.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/jaccess.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/zipfs.jar
file:/System/Library/Java/Extensions/MRJToolkit.jar
```

### 应用类程序加载器

#### 应用类程序加载器的定义

应用程序类加载器（Appliation ClassLoader）由sun.misc.Launcher$AppClassLoader实现（JAVA代码），它是拓展类加载器的子加载器。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为**系统类加载器**。一般情况下应用程序类加载器就是程序中的默认类加载器

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/classes/sun/misc/Launcher.java#L261

```java
    /**
     * The class loader used for loading from java.class.path.
     * runs in a restricted security context.
     */
    static class AppClassLoader extends URLClassLoader {

        static {
            ClassLoader.registerAsParallelCapable();
        }

        public static ClassLoader getAppClassLoader(final ClassLoader extcl)
            throws IOException
        {
            final String s = System.getProperty("java.class.path");
            final File[] path = (s == null) ? new File[0] : getClassPath(s);

            // Note: on bugid 4256530
            // Prior implementations of this doPrivileged() block supplied
            // a rather restrictive ACC via a call to the private method
            // AppClassLoader.getContext(). This proved overly restrictive
            // when loading  classes. Specifically it prevent
            // accessClassInPackage.sun.* grants from being honored.
            //
            return AccessController.doPrivileged(
                new PrivilegedAction<AppClassLoader>() {
                    public AppClassLoader run() {
                    URL[] urls =
                        (s == null) ? new URL[0] : pathToURLs(path);
                    return new AppClassLoader(urls, extcl);
                }
            });
        }
```

#### 应用类程序加载器的管辖范围

应用类程序加载器，负责加载用户类路径（classpath）上所指定的类库

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/classes/sun/misc/Launcher.java#L267

```java
        public static ClassLoader getAppClassLoader(final ClassLoader extcl)
            throws IOException
        {
            final String s = System.getProperty("java.class.path");
            final File[] path = (s == null) ? new File[0] : getClassPath(s);

            // Note: on bugid 4256530
            // Prior implementations of this doPrivileged() block supplied
            // a rather restrictive ACC via a call to the private method
            // AppClassLoader.getContext(). This proved overly restrictive
            // when loading  classes. Specifically it prevent
            // accessClassInPackage.sun.* grants from being honored.
            //
            return AccessController.doPrivileged(
                new PrivilegedAction<AppClassLoader>() {
                    public AppClassLoader run() {
                    URL[] urls =
                        (s == null) ? new URL[0] : pathToURLs(path);
                    return new AppClassLoader(urls, extcl);
                }
            });
        }
```

##### 打印应用程序类加载器的URLs

```java
package com.peter.jvm.example;

import java.net.URL;
import java.net.URLClassLoader;

public class AppClassLoaderPath {

    public static void main(String[] args) {
        String property = "java.class.path";
        System.out.println("====================" + property + "'s Urls====================");
        String os_name = System.getProperty("os.name");
        String[] urls;
        if (os_name.toLowerCase().contains("win")) {
            urls = System.getProperty(property).split(";");
        } else {
            urls = System.getProperty(property).split(":");
        }
        for (String url : urls) {
            System.out.println(url);
        }
        System.out.println("====================AppClassLoader's Urls====================");
        URLClassLoader classLoader = (URLClassLoader) ClassLoader.getSystemClassLoader();
        URL[] urls1 = classLoader.getURLs();
        for (URL url : urls1) {
            System.out.println(url);
        }
    }
}
```

输出结果（WINDOWS）
```
====================java.class.path's Urls====================
C:\Program Files\Java\jdk1.8.0_231\jre\lib\charsets.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\deploy.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\access-bridge-64.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\cldrdata.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\dnsns.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\jaccess.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\jfxrt.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\localedata.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\nashorn.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunec.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunjce_provider.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunmscapi.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunpkcs11.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\zipfs.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\javaws.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\jce.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\jfr.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\jfxswt.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\jsse.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\management-agent.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\plugin.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\resources.jar
C:\Program Files\Java\jdk1.8.0_231\jre\lib\rt.jar
C:\Users\Admin\Desktop\plan\2020\luban-jvm-research\target\classes
C:\Users\Admin\.m2\repository\org\openjdk\jol\jol-core\0.10\jol-core-0.10.jar
D:\IntelliJ IDEA Community Edition 2019.3.3\lib\idea_rt.jar
====================AppClassLoader's Urls====================
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/charsets.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/deploy.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/access-bridge-64.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/cldrdata.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/dnsns.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/jaccess.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/jfxrt.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/localedata.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/nashorn.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunec.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunjce_provider.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunmscapi.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunpkcs11.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/zipfs.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/javaws.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jce.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jfr.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jfxswt.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jsse.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/management-agent.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/plugin.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/resources.jar
file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/rt.jar
file:/C:/Users/Admin/Desktop/plan/2020/luban-jvm-research/target/classes/
file:/C:/Users/Admin/.m2/repository/org/openjdk/jol/jol-core/0.10/jol-core-0.10.jar
file:/D:/IntelliJ%20IDEA%20Community%20Edition%202019.3.3/lib/idea_rt.jar
```

输出结果（MACOS）
```
====================java.class.path's Urls====================
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/charsets.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/deploy.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/cldrdata.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/dnsns.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/jaccess.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/jfxrt.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/localedata.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/nashorn.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/sunec.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/zipfs.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/javaws.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jce.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jfr.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jfxswt.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jsse.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/management-agent.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/plugin.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/resources.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/rt.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/ant-javafx.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/dt.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/javafx-mx.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/jconsole.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/packager.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/sa-jdi.jar
/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/tools.jar
/Users/peteryuanpan/github/luban-jvm-research/target/classes
/Users/peteryuanpan/.m2/repository/org/openjdk/jol/jol-core/0.9/jol-core-0.9.jar
/Applications/ide/IntelliJ IDEA CE.app/Contents/lib/idea_rt.jar
====================AppClassLoader's Urls====================
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/charsets.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/deploy.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/cldrdata.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/dnsns.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/jaccess.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/jfxrt.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/localedata.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/nashorn.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/sunec.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/ext/zipfs.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/javaws.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jce.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jfr.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jfxswt.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/jsse.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/management-agent.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/plugin.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/resources.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/rt.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/ant-javafx.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/dt.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/javafx-mx.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/jconsole.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/packager.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/sa-jdi.jar
file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/lib/tools.jar
file:/Users/peteryuanpan/github/luban-jvm-research/target/classes/
file:/Users/peteryuanpan/.m2/repository/org/openjdk/jol/jol-core/0.9/jol-core-0.9.jar
file:/Applications/ide/IntelliJ%20IDEA%20CE.app/Contents/lib/idea_rt.jar
```

从输出结果可以看出来，java.class.path指定的URLs 与 AppClassLoader的URLs 是一致的

### 深入理解双亲委派模型源码

先来看 ClassLoader 的 getSystemClassLoader() 方法

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/classes/java/lang/ClassLoader.java#L1432

```java
public abstract class ClassLoader {
...
    @CallerSensitive
    public static ClassLoader getSystemClassLoader() {
        initSystemClassLoader();
        if (scl == null) {
            return null;
        }
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkClassLoaderPermission(scl, Reflection.getCallerClass());
        }
        return scl;
    }

    private static synchronized void initSystemClassLoader() {
        if (!sclSet) {
            if (scl != null)
                throw new IllegalStateException("recursive invocation");
            sun.misc.Launcher l = sun.misc.Launcher.getLauncher();
            if (l != null) {
                Throwable oops = null;
                scl = l.getClassLoader();
                try {
                    scl = AccessController.doPrivileged(
                        new SystemClassLoaderAction(scl));
                } catch (PrivilegedActionException pae) {
                    oops = pae.getCause();
                    if (oops instanceof InvocationTargetException) {
                        oops = oops.getCause();
                    }
                }
                if (oops != null) {
                    if (oops instanceof Error) {
                        throw (Error) oops;
                    } else {
                        // wrap the exception
                        throw new Error(oops);
                    }
                }
            }
            sclSet = true;
        }
    }
...
```

这里有一行 sun.misc.Launcher l = sun.misc.Launcher.getLauncher();

还有一行 scl = l.getClassLoader();

再来看下 sun.misc.Launcher 类，有 extcl = ExtClassLoader.getExtClassLoader(); 及 AppClassLoader.getAppClassLoader(extcl);

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/classes/sun/misc/Launcher.java#L55

```java
/**
 * This class is used by the system to launch the main application.
Launcher */
public class Launcher {
    private static URLStreamHandlerFactory factory = new Factory();
    private static Launcher launcher = new Launcher();
    private static String bootClassPath =
        System.getProperty("sun.boot.class.path");

    public static Launcher getLauncher() {
        return launcher;
    }

    private ClassLoader loader;

    public Launcher() {
        // Create the extension class loader
        ClassLoader extcl;
        try {
            extcl = ExtClassLoader.getExtClassLoader();
        } catch (IOException e) {
            throw new InternalError(
                "Could not create extension class loader", e);
        }

        // Now create the class loader to use to launch the application
        try {
            loader = AppClassLoader.getAppClassLoader(extcl);
        } catch (IOException e) {
            throw new InternalError(
                "Could not create application class loader", e);
        }

        // Also set the context class loader for the primordial thread.
        Thread.currentThread().setContextClassLoader(loader);

        // Finally, install a security manager if requested
        String s = System.getProperty("java.security.manager");
        if (s != null) {
            SecurityManager sm = null;
            if ("".equals(s) || "default".equals(s)) {
                sm = new java.lang.SecurityManager();
            } else {
                try {
                    sm = (SecurityManager)loader.loadClass(s).newInstance();
                } catch (IllegalAccessException e) {
                } catch (InstantiationException e) {
                } catch (ClassNotFoundException e) {
                } catch (ClassCastException e) {
                }
            }
            if (sm != null) {
                System.setSecurityManager(sm);
            } else {
                throw new InternalError(
                    "Could not create SecurityManager: " + s);
            }
        }
    }

    /*
     * Returns the class loader used to launch the main application.
     */
    public ClassLoader getClassLoader() {
        return loader;
    }
...
```

看下 AppClassLoader 的构造函数，有 AppClassLoader(URL[] urls, ClassLoader parent)

从上面可看出来，ExtClassLoader 和 AppClassLoader 是逻辑上的父子关系

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/classes/sun/misc/Launcher.java#L295

```java
    static class AppClassLoader extends URLClassLoader {
...
        /*
         * Creates a new AppClassLoader
         */
        AppClassLoader(URL[] urls, ClassLoader parent) {
            super(urls, parent, factory);
            ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(this);
            ucp.initLookupCache(this);
        }
...
```

也看下ClassLoader的构造函数，parent = getSystemClassLoader()

https://github.com/peteryuanpan/openjdk-8u40-source-code-mirror/blob/master/jdk/src/share/classes/java/lang/ClassLoader.java#L279

```java
public abstract class ClassLoader {

    private static native void registerNatives();
    static {
        registerNatives();
    }

    // The parent class loader for delegation
    // Note: VM hardcoded the offset of this field, thus all new fields
    // must be added *after* it.
    private final ClassLoader parent;
...
    private ClassLoader(Void unused, ClassLoader parent) {
        this.parent = parent;
        if (ParallelLoaders.isRegistered(this.getClass())) {
            parallelLockMap = new ConcurrentHashMap<>();
            package2certs = new ConcurrentHashMap<>();
            assertionLock = new Object();
        } else {
            // no finer-grained lock; lock on the classloader instance
            parallelLockMap = null;
            package2certs = new Hashtable<>();
            assertionLock = this;
        }
    }
...
    protected ClassLoader() {
        this(checkCreateClassLoader(), getSystemClassLoader());
    }
```

总结一下，从源码中可以看出几点
- ExtClassLoader是拓展类加载器
- AppClassLoader是应用程序类加载器
- extcl = ExtClassLoader.getExtClassLoader(); 及 loader = AppClassLoader.getAppClassLoader(extcl); 及 AppClassLoader(URL[] urls, ClassLoader parent) 说明 **ExtClassLoader 和 AppClassLoader 是逻辑上的父子关系**，注意：**并非继承关系上的**，ExtClassLoader 和 AppClassLoader 都是继承 URLClassLoader 的
- sun.misc.Launcher l = sun.misc.Launcher.getLauncher(); 及 scl = l.getClassLoader(); 实际获取的是 loader = AppClassLoader.getAppClassLoader(extcl); 最终 getSystemClassLoader() 返回的是 scl，因此 AppClassLoader 是 ClassLoader 中的 getSystemClassLoader() 方法的返回值
- 通过 new ClassLoader() 实例化的类加载器，默认的 parent 是 getSystemClassLoader()，也就是应用程序类加载器
- 一般的类加载器的实例化过程，都需要经过 new ClassLoader() 实例化，因此 **AppClassLoader是系统默认的类加载器**

### 破坏双亲委派模型的定义

破坏双亲委派模型，即不符合双亲委派模型的类加载模型

> 说通俗一点，双亲委派模型引入的目的是保护父或根类加载器（启动类加载器、拓展类加载器等）的纯净性，否则你想，应用程序默认类加载器是应用程序类加载器，但java.lang.* 包下的类是由启动类加载器加载的，如果没有双亲委派，可能交给了应用程序类加载器或拓展类加载器加载了，根据类加载器的唯一性，应用程序类加载器 和 启动类加载器 加载的 java.lang.Integer，不属于同一个类，这给JAVA程序运行造成了不必要的麻烦，这样就不纯净了

> 那么，双亲委派模型不是万全的，总会有场景例子不符合它，这个时候就需要破坏双亲委派了

破坏双亲委派模型有两种实现方式：自定义类加载器、线程上下文类加载器与SPI机制

### 自定义类加载器

#### 自定义类加载器打破双亲委派的关键

关键是继承ClassLoader，重写loadClass方法。如果只是重写findClass方法，没有打破双亲委派

来看下这两个方法的源码（其实在“类加载的唯一性”中已经展示过一次）

可以看出来
- 先通过findLoadedClass判断类是否已经加载
- 若没加载，优先交给父类加载 parent.loadClass(name, false);
- 若不存在父类，交给启动类加载器加载 findBootstrapClassOrNull(name);
- 若仍然加载失败，交给findClass方法加载，c = findClass(name);

因此，若只是重写了findClass方法，是没有打破双亲委派的，必须重写loadClass方法。在下面的“自定义类加载器例子1”中，会进一步给出例子说明

```java
public abstract class ClassLoader {
...
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
    
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }
    
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
...
```

#### 自定义类加载器例子1

##### 背景

以下场景不是真实项目中遇到的，只是个例子

双亲委派下类加载的流程是，默认先交给应用程序类加载器，若已加载则返回，否则优先交给拓展类加载器，若已加载则返回，否则优先交给启动类加载器，启动器类加载器若加载失败，返回给拓展类加载器加载，拓展类加载器若加载失败，返回应用程序类加载器加载

根据上文可知，每个类加载器都有它的加载范围路径

在一个项目中，程序进程已经启动了，有一个A.class在应用程序类加载器的范围内，且已经被加载了

但由于项目的原因，需要热部署，且接入一个新的自定义类加载器，加载另一个路径下的A.class

此时如果依然使用双亲委派模型，就无法完成需求，但又不方便重新部署代码，重启项目，此时就需要打破双亲委派了

##### 需求1

实现一个自定义类加载器，能够指定操作系统中路径（有访问权限），加载一份.class文件

假设有一份类在D:\workspace\com\luban\ziya\peter\Byte.class下，全限定名为com.luban.ziya.peter.Byte

该类的源码如下
```java
package com.luban.ziya.peter;

public class Byte {

    public static void main(String[] args) {
        Byte .show();
    }

    public static void show() {
        System.out.println("com.luban.ziya.peter.Byte show function");
    }

}
```

##### 实现1

代码

```java
package com.peter.jvm.example;

import java.io.File;
import java.net.URL;
import java.net.URLClassLoader;

public class URLClassLoaderTest2 {

    static String localpath = "D:\\workspace\\";
    static String classToLoad = "com.luban.ziya.peter.Byte";

    public static void main(String[] args) {
        try {
            File file = new File(localpath);
            URL url = file.toURI().toURL();
            ClassLoader myLoader = new URLClassLoader(new URL[]{url}) {
                protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
                    if (name == classToLoad) {
                        return super.findClass(name);
                    } else {
                        return getParent().loadClass(name);
                    }
                }
            };
            Class clazz = myLoader.loadClass(classToLoad);
            System.out.println(clazz.getName());
            clazz.getMethod("show").invoke((byte)1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

输出结果
```
com.luban.ziya.peter.Byte
com.luban.ziya.peter.Byte show function
```

#### 解释1

来到URLClassLoader.java中，有以下代码

```java
    /**
     * Finds and loads the class with the specified name from the URL search
     * path. Any URLs referring to JAR files are loaded and opened as needed
     * until the class is found.
     *
     * @param name the name of the class
     * @return the resulting class
     * @exception ClassNotFoundException if the class could not be found,
     *            or if the loader is closed.
     * @exception NullPointerException if {@code name} is {@code null}.
     */
    protected Class<?> findClass(final String name)
        throws ClassNotFoundException
    {
        final Class<?> result;
        try {
            result = AccessController.doPrivileged(
                new PrivilegedExceptionAction<Class<?>>() {
                    public Class<?> run() throws ClassNotFoundException {
                        String path = name.replace('.', '/').concat(".class");
                        Resource res = ucp.getResource(path, false);
                        if (res != null) {
                            try {
                                return defineClass(name, res);
                            } catch (IOException e) {
                                throw new ClassNotFoundException(name, e);
                            }
                        } else {
                            return null;
                        }
                    }
                }, acc);
        } catch (java.security.PrivilegedActionException pae) {
            throw (ClassNotFoundException) pae.getException();
        }
        if (result == null) {
            throw new ClassNotFoundException(name);
        }
        return result;
    }
```

在 if (res != null) { 这一行加一个断点

再次启动main函数（debug模式），一路Resume，观察path的值，直到为com/luban/ziya/peter/Byte.class

这里有个res，点开，发现url="file:/D:/workspace/com/luban/ziya/peter/Byte.class

![image](https://user-images.githubusercontent.com/10209135/90924956-03fb2380-e423-11ea-9af5-86dc1421d7d5.png)

#### 需求2

与需求1一样，但类在D:\workspace\java\lang\Byte.class下，全限定名为了java.lang.Byte

类源码如下

```java
package java.lang;

public class Byte {

    public static void main(String[] args) {
        Byte .show();
    }

    public static void show() {
        System.out.println("java.lang.Byte show function");
    }

}
```

#### 实现2-1

与实现1一样，只是变了下String classToLoad的值

```java
public class URLClassLoaderTest2 {

    static String localpath = "D:\\workspace\\";
    static String classToLoad = "java.lang.Byte";

    public static void main(String[] args) {
```

输出结果
```
Exception in thread "main" java.lang.SecurityException: Prohibited package name: java.lang
	at java.lang.ClassLoader.preDefineClass(ClassLoader.java:655)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:754)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:468)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:74)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:369)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:363)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:362)
	at com.luban.ziya.peter.ClassLoaderTest2.loadClass(ClassLoaderTest2.java:45)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:351)
	at com.luban.ziya.peter.ClassLoaderTest2.main(ClassLoaderTest2.java:24)

Process finished with exit code 1
```

#### 解释2-1

查看at java.lang.ClassLoader.preDefineClass(ClassLoader.java:655)

可以发现ClassLoader采用了保护机制，对于java.开头的package，不允许preDefineClass（private修饰的）

```java
    /* Determine protection domain, and check that:
        - not define java.* class,
        - signer of this class matches signers for the rest of the classes in
          package.
    */
    private ProtectionDomain preDefineClass(String name,
                                            ProtectionDomain pd)
    {
        if (!checkName(name))
            throw new NoClassDefFoundError("IllegalName: " + name);

        // Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias
        // relies on the fact that spoofing is impossible if a class has a name
        // of the form "java.*"
        if ((name != null) && name.startsWith("java.")) {
            throw new SecurityException
                ("Prohibited package name: " +
                 name.substring(0, name.lastIndexOf('.')));
        }
        if (pd == null) {
            pd = defaultDomain;
        }

        if (name != null) checkCerts(name, pd.getCodeSource());

        return pd;
    }
```

也不允许其他子类去重写defineClass（final修饰的）

```java
    protected final Class<?> defineClass(String name, byte[] b, int off, int len,
                                         ProtectionDomain protectionDomain)
        throws ClassFormatError
    {
        protectionDomain = preDefineClass(name, protectionDomain);
        String source = defineClassSourceLocation(protectionDomain);
        Class<?> c = defineClass1(name, b, off, len, protectionDomain, source);
        postDefineClass(c, protectionDomain);
        return c;
    }
```

#### 实现2-2

我们变一下实现，不去重写loadClass方法，改为重写findClass方法

```java
package com.peter.jvm.example;

import java.io.File;
import java.net.URL;
import java.net.URLClassLoader;

public class URLClassLoaderTest3 {

    static String localpath = "D:\\workspace\\";
    static String classToLoad = "java.lang.Byte";

    public static void main(String[] args) {
        try {
            File file = new File(localpath);
            URL url = file.toURI().toURL();
            ClassLoader myLoader = new URLClassLoader(new URL[]{url}) {
                protected Class<?> findClass(String name) throws ClassNotFoundException {
                    if (name == classToLoad) {
                        return super.findClass(name);
                    } else {
                        return getParent().loadClass(name);
                    }
                }
            };
            Class clazz = myLoader.loadClass(classToLoad);
            System.out.println(clazz.getName());
            clazz.getMethod("show").invoke((byte)1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

输出结果
```
java.lang.Byte
java.lang.NoSuchMethodException: java.lang.Byte.show()
	at java.lang.Class.getMethod(Class.java:1786)
	at com.peter.jvm.example.URLClassLoaderTest3.main(URLClassLoaderTest3.java:27)
```

#### 解释2-2

实现2-2的输出与实现2-1不一样

Class clazz = myLoader.loadClass(classToLoad); 这一行是通过了的

clazz.getMethod("show").invoke((byte)1); 方法调用的时候出了错

实际上，只是重写findClass方法没有打破双亲委派（前文已经具体解释过），那么java.lang.Byte会最终交给启动类加载器加载，常规的Byte类下当然没有一个show方法了，因此invoke就报错了

### 自定义类加载器例子2

《深入理解JAVA虚拟机》第二版7.4.3节中提到了一个例子，即OSGi

> 双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换（HotSwap）、模块热部署（Hot Deployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、U盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。对于个人计算机来说，重启一次其次没有什么大不了的，但对于一些生产系统爱说，关机重启一次可能就要被列为生产事故，这种情况下热部署对软件开发者，尤其是企业级软件开发者具有很大的吸引力。

目前OSGi已经成为了业界“事实上”的Java模块化标准，而OSGi实现模块化热部署的关键则是它自定义类加载器机制的实现。每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换

在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构

当收到类加载请求时，OSGi将按照下面的顺序进行类搜索

- 将以java.* 开头的类委派给父类加载器加载
- 否则，将委派列表名单内的类委派给父类加载器加载
- 否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载
- 否则，查找当前Bundle的Classpath，使用自己的类加载器加载
- 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载
- 否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载
- 否则，类查找失败

上面的查找顺序中，只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的

> 目前我没有时间深入了解OSGi，周志明说“OSGi中对类加载器的使用是很值得学习的，弄懂了OSGi的实现，就可以算是掌握了类加载器的精髓”，有时间可以去看看周志明的另一本书《深入理解OSGi：Equinox原理、应用与最佳实践》

### SPI机制与线程上下文类加载器

#### SPI机制的定义

SPI，全称为 Service Provider Interface，是一种服务发现机制。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件内容所指向的类

#### SPI机制例子之ServiceLoader

我们以一段代码例子来说明ServiceLoader的用法

ThreadContextClassLoaderTest1
```java
package com.peter.jvm.example2.spi;

import java.util.ServiceLoader;

public class ThreadContextClassLoaderTest1 {

    public static void main(String[] args) {
        ServiceLoader<PayService> services = ServiceLoader.load(PayService.class);
        for (PayService service : services) {
            service.pay();
        }
    }
}
```

PayService
```java
package com.peter.jvm.example2.spi;

public interface PayService {
    void pay();
}
```

AlipayService
```java
package com.peter.jvm.example2.spi;

public class AlipayService implements PayService {

    @Override
    public void pay() {
        System.out.println("AlipayService");
    }
}
```

WxpayService
```java
package com.peter.jvm.example2.spi;

public class WxpayService implements PayService {

    @Override
    public void pay() {
        System.out.println("WxpayService");
    }
}
```

src/main/resources/META-INF/services/com.peter.jvm.example2.spi.PayService

target/classes/META-INF/services/com.peter.jvm.example2.spi.PayService
```
com.peter.jvm.example2.spi.AlipayService
com.peter.jvm.example2.spi.WxpayService
```

输出结果
```
AlipayService
WxpayService
```

解释

ServiceLoader.load(PayService.class); 需要加载com.peter.jvm.example2.spi.PayService类

ServiceLoader会加载META-INF/services/com.peter.jvm.example2.spi.PayService文件中的内容指向的类

文件中指向了2个全限定名，因此两个类都会加载

ServiceLoader实现了Iterator，for (PayService service : services) {service.pay();} 会将两个加载的类都调用pay方法，因此两行输出

假设将META-INF/services/com.peter.jvm.example2.spi.PayService文件内容改为只有com.peter.jvm.example2.spi.AlipayService，则只输出AlipayService（Wxpay同理）

#### ServiceLoader类加载源码

##### ServiceLoader

首先，我们先来了解下ServiceLoader，看看它的类结构。

```java
public final class ServiceLoader<S> implements Iterable<S> {
    //配置文件的路径
    private static final String PREFIX = "META-INF/services/";
    //加载的服务类或接口
    private final Class<S> service;
    //已加载的服务类集合
    private LinkedHashMap<String,S> providers = new LinkedHashMap<>();
    //类加载器
    private final ClassLoader loader;
    //内部类，真正加载服务类
    private LazyIterator lookupIterator;
}
```

##### load方法

ServiceLoader.load(PayService.class); 往下跟踪

重要的是实例化了内部类，LazyIterator

```java
    public static <S> ServiceLoader<S> load(Class<S> service) {
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        return ServiceLoader.load(service, cl);
    }
    
    public static <S> ServiceLoader<S> load(Class<S> service,
                                            ClassLoader loader)
    {
        return new ServiceLoader<>(service, loader);
    }
    
    private ServiceLoader(Class<S> svc, ClassLoader cl) {
        // 要加载的接口
        service = Objects.requireNonNull(svc, "Service interface cannot be null");
	// 类加载器
        loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;
	// 访问控制器
        acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;
        reload();
    }
    
    public void reload() {
        // 先清空
        providers.clear();
	// 实例化内部类
        lookupIterator = new LazyIterator(service, loader);
    }
```

##### 实现iterator接口

iterator接口，都在LazyIterator完成。当我们调用iterator.hasNext和iterator.next方法的时候，实际上调用的都是LazyIterator的相应方法

```java
    public Iterator<S> iterator() {
        return new Iterator<S>() {

            Iterator<Map.Entry<String,S>> knownProviders
                = providers.entrySet().iterator();

            public boolean hasNext() {
                if (knownProviders.hasNext())
                    return true;
                return lookupIterator.hasNext();
            }

            public S next() {
                if (knownProviders.hasNext())
                    return knownProviders.next().getValue();
                return lookupIterator.next();
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }

        };
    }
```

##### hasNextService及nextService

nextService可以很清晰的看到 Class.forName 进行类加载 和 newInstance 进行实例化的实现

相信到了这里，已经很明白了

```java
    private class LazyIterator
        implements Iterator<S>
    {
        Class<S> service;
        ClassLoader loader;
        Enumeration<URL> configs = null;
        Iterator<String> pending = null;
        String nextName = null;
	
        private boolean hasNextService() {
	    // 第二次调用的时候，已经解析完成了，直接返回
            if (nextName != null) {
                return true;
            }
            if (configs == null) {
                try {
		    // META-INF/services/ 加上接口的全限定类名，就是文件服务类的文件
		    // META-INF/services/com.peter.jvm.example2.spi.PayService
                    String fullName = PREFIX + service.getName();
		    // 将文件路径转成URL对象
                    if (loader == null)
                        configs = ClassLoader.getSystemResources(fullName);
                    else
                        configs = loader.getResources(fullName);
                } catch (IOException x) {
                    fail(service, "Error locating configuration files", x);
                }
            }
            while ((pending == null) || !pending.hasNext()) {
                if (!configs.hasMoreElements()) {
                    return false;
                }
		// 解析URL文件对象，读取内容，最后返回
                pending = parse(service, configs.nextElement());
            }
	    // 拿到第一个实现类的类名
            nextName = pending.next();
            return true;
        }
	
        private S nextService() {
            if (!hasNextService())
                throw new NoSuchElementException();
            // 全限定类名
            String cn = nextName;
            nextName = null;
            Class<?> c = null;
            try {
	        // 创建类的Class对象
                c = Class.forName(cn, false, loader);
            } catch (ClassNotFoundException x) {
                fail(service,
                     "Provider " + cn + " not found");
            }
            if (!service.isAssignableFrom(c)) {
                fail(service,
                     "Provider " + cn  + " not a subtype");
            }
            try {
	        // 通过newInstance实例化
                S p = service.cast(c.newInstance());
		// 放入集合，返回实例
                providers.put(cn, p);
                return p;
            } catch (Throwable x) {
                fail(service,
                     "Provider " + cn + " could not be instantiated",
                     x);
            }
            throw new Error();          // This cannot happen
        }
```

#### SPI机制例子之JDBCMysql

来看一段关于mysql测试连接的代码

```java
package com.peter.jvm.example2.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;

public class JDBCMysqlTest1 {

    private static final String driver = "com.mysql.cj.jdbc.Driver";
    private static final String url = "jdbc:mysql://localhost:3306/peter?useUnicode=true&characterEncoding=UTF-8&useLegacyDatetimeCode=false&serverTimezone=UTC";
    private static final String username = "root";
    private static final String password = "123456";
    private static Connection conn = null;

    static {
        try {
            //Class.forName(driver);
        } catch(Exception ex) {
            ex.printStackTrace();
        }
    }

    public static Connection getConnection() throws Exception {
        if (conn == null) {
            conn = DriverManager.getConnection(url, username, password);
            return conn;
        }
        return conn;
    }

    public static void main(String[] args) {
        try {
            Connection conn = JDBCMysqlTest1.getConnection();
            if (conn != null) {
                System.out.println("数据库连接正常！");
            } else {
                System.out.println("数据库连接异常！");
            }
        }
        catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}
```

输出结果
```
数据库连接正常！
```

当然，上面的代码，需要先做一些准备工作：下载并安装MYSQL、下载MYSQL WorkBench、连接数据库、创建数据库，才能运行结果是连接正常

我们会发现 //Class.forName(driver); 是注释了的，不需要用反射的方法加载一次类 com.mysql.cj.jdbc.Driver，也能使用该类，下面来说明原理

#### DriverManager类加载源码

Java 提供了很多服务接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等

以JDBC来举例，java.sql.Driver是sql的接口，它有很多具体实现类（mysql、mongodb等）。接口的作用是一种定义，多种实现

java.sql.DriverManager类中有一个同包的类DriverInfo，类DriverInfo有一个成员变量final Driver driver

代码执行时，driver以具体实现类形式（比如com.mysql.cj.jdbc.Driver）被使用的

java.sql.Driver接口是被启动类加载器加载的，而com.mysql.cj.jdbc.Driver需要被系统类加载器加载

这里就有问题了，程序中我该如何让java.sql.Driver接口以com.mysql.cj.jdbc.Driver类的形式来使用？

答案就是SPI机制之ServiceLoader实现

我们来看一下mysql-connector-java-8.0.20.jar中META-INF\services\java.sql.Driver的内容

![image](https://user-images.githubusercontent.com/10209135/92632841-bdebfe00-f304-11ea-945f-554dfc013709.png)

![image](https://user-images.githubusercontent.com/10209135/92631203-a06a6480-f303-11ea-952b-c145c18aaff2.png)

内容为com.mysql.cj.jdbc.Driver，这里可以感觉到了，JDBCMysql源码中会根据该文件的内容，实现com.mysql.cj.jdbc.Driver的类加载

再来看下DriverManager.java

```java
public class DriverManager {
...
    /**
     * Load the initial JDBC drivers by checking the System property
     * jdbc.properties and then use the {@code ServiceLoader} mechanism
     */
    static {
        loadInitialDrivers();
        println("JDBC DriverManager initialized");
    }
...
    private static void loadInitialDrivers() {
        String drivers;
        try {
            drivers = AccessController.doPrivileged(new PrivilegedAction<String>() {
                public String run() {
                    return System.getProperty("jdbc.drivers");
                }
            });
        } catch (Exception ex) {
            drivers = null;
        }
        // If the driver is packaged as a Service Provider, load it.
        // Get all the drivers through the classloader
        // exposed as a java.sql.Driver.class service.
        // ServiceLoader.load() replaces the sun.misc.Providers()

        AccessController.doPrivileged(new PrivilegedAction<Void>() {
            public Void run() {

                ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
                Iterator<Driver> driversIterator = loadedDrivers.iterator();
                /* Load these drivers, so that they can be instantiated.
                 * It may be the case that the driver class may not be there
                 * i.e. there may be a packaged driver with the service class
                 * as implementation of java.sql.Driver but the actual class
                 * may be missing. In that case a java.util.ServiceConfigurationError
                 * will be thrown at runtime by the VM trying to locate
                 * and load the service.
                 *
                 * Adding a try catch block to catch those runtime errors
                 * if driver not available in classpath but it's
                 * packaged as service and that service is there in classpath.
                 */
                try{
                    while(driversIterator.hasNext()) {
                        driversIterator.next();
                    }
                } catch(Throwable t) {
                // Do nothing
                }
                return null;
            }
        });
...
```

能看到一行 ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);

使用了ServiceLoader，来加载META-INF\services\java.sql.Driver中所指定的类com.mysql.cj.jdbc.Driver，即DriverManager通过SPI机制实现了类加载

#### 线程上下文类加载器

Thread类内部有一个私有成员变量ClassLoader contextClassLoader，这就是线程上下文类加载器

```java
public
class Thread implements Runnable {
..
    /* The context ClassLoader for this thread */
    private ClassLoader contextClassLoader;
```

我们修改一下“SPI机制例子之JDBCMysql”中的代码进行测试
 
```java
package com.peter.jvm.example2.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;

public class JDBCMysqlTest1 {

    private static final String driver = "com.mysql.cj.jdbc.Driver";
    private static final String url = "jdbc:mysql://localhost:3306/peter?useUnicode=true&characterEncoding=UTF-8&useLegacyDatetimeCode=false&serverTimezone=UTC";
    private static final String username = "root";
    private static final String password = "123456";
    private static Connection conn = null;

    static {
        try {
            ClassLoader myLoader = new ClassLoader() {
                @Override
                protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
                    System.out.println("JDBCMysqlTest1 " + name);
                    return super.loadClass(name, resolve);
                }
            };
            Thread.currentThread().setContextClassLoader(myLoader);
        } catch(Exception ex) {
            ex.printStackTrace();
        }
    }

    public static Connection getConnection() throws Exception {
        if (conn == null) {
            conn = DriverManager.getConnection(url, username, password);
            return conn;
        }
        return conn;
    }

    public static void main(String[] args) {
        try {
            Connection conn = JDBCMysqlTest1.getConnection();
            if (conn != null) {
                System.out.println("数据库连接正常！");
            } else {
                System.out.println("数据库连接异常！");
            }
        }
        catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}
```
 
输出结果
```
JDBCMysqlTest1 com.mysql.cj.jdbc.Driver
数据库连接正常！
```
 
解释
 
先加载main函数所在的类JDBCMysqlTest1，执行static{}代码块，再invoke main方法

static{}代码块中，初始化了一个类加载器myLoader，并设置为了当前线程上下文类加载器，Thread.currentThread().setContextClassLoader(myLoader);

invoke main方法中，getConnection函数里，调用DriverManager.getConnection(); 对应字节码是 invokestatic，会触发对DriverManager类加载

对DriverManager类加载，执行对应static{}代码块

```java
    static {
        loadInitialDrivers();
        println("JDBC DriverManager initialized");
    }
    
    private static void loadInitialDrivers() {
...
        AccessController.doPrivileged(new PrivilegedAction<Void>() {
            public Void run() {

                ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
                Iterator<Driver> driversIterator = loadedDrivers.iterator();
```

加个断点可以确认，会执行 ServiceLoader.load(Driver.class); 这句话

ServiceLoader.load(Driver.class) 会走到内部静态方法，调用 Thread.currentThread().getContextClassLoader() 来获取 contextClassLoader 这个类加载器，用于后续类加载

```java
    public static <S> ServiceLoader<S> load(Class<S> service) {
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        return ServiceLoader.load(service, cl);
    }
```

因此执行了JDBCMysqlTest1类中的static{}方法
