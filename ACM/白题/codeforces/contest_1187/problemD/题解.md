
![1.png](https://raw.githubusercontent.com/peteryuanpan/notebook/master/ACM/%E7%99%BD%E9%A2%98/codeforces/contest_1187/problemD/data/1.png)

如图所示

1 9 5 5 3 7

1 5 5 3 7 9

可以通过如下变换

[1 9 5 5 3 7] => [1 5 5 9 3 7] => [1 5 5 3 9 7] => [1 5 5 3 7 9]

而

1 7 5 5 3 9

1 5 5 3 9 7

则无法实现

原因是无论如何排序，都无法令 7 9 变为 9 7

因此猜想算法如下：

1. 对于 i : [1, N]，确认 A[i] 对应的 B[j]，即图中的箭头关系。不妨令 r[i] = j。若存在 A[i] 无法对应一个 B[j]，则 NO。

2. 对于 i : [1, N]，若存在 k : [1, i - 1] 且  A[k] : [1, A[i] - 1] 且 r[k] > r[i]，则 NO。

3. 1、2 无 NO，则 YES。

与前缀最大值有关，可使用树状数组实现
