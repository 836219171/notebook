- [JVM总结](#JVM总结)
  - [为什么说JAVA是一种半编译半解释型语言](#为什么说JAVA是一种半编译半解释型语言)
  - [什么情况下需要破坏双亲委派模型](#什么情况下需要破坏双亲委派模型)
  - [GCRoots的作用以及哪些引用可以作为GCRoots](#GCRoots的作用以及哪些引用可以作为GCRoots)
  - [说一下对象内存分配及进入老年代的策略](#说一下对象内存分配及进入老年代的策略)
  - [说下常用垃圾收集器的工作原理](#说下常用垃圾收集器的工作原理)
  - [如何选择一款垃圾收集器](#如何选择一款垃圾收集器)
  - [GC调优策略经验总结](#GC调优策略经验总结)

# JVM总结

### 为什么说JAVA是一种半编译半解释型语言

JAVA代码并不像C++那样，是一步将代码编译成机器码，交由CPU处理器执行的，而是先编译成class文件，然后交由虚拟机运行，虚拟机还需要翻译字节码成机器码，这就是“半”的含义

体现在两个方面，一是 JAVAC 编译，JAVA 运行，二是解释器解释执行，编译器编译执行

JAVA代码通过JAVAC编译器编译成class文件，虚拟机运行时通过类加载读入class文件，转化为方法区中的类的元信息数据，同时启动Main类的main方法，通过字节码执行引擎执行字节码

字节码是不能被CPU处理器识别的指令，它需要被翻译成汇编码和机器码，翻译的过程最初只有解释器逐行解释执行，后来演化出了编译器将热点代码直接编译成汇编码或机器码的方式来编译执行，还演化出了如栈上分配、指令重排序等优化技术

### 什么情况下需要破坏双亲委派模型

ClassLoader 类中的 loadClass 方法负责进行类加载，其中的关键逻辑是，如果存在父类加载器，优先交给父类加载器加载，若加载失败，则交由 findClass 方法加载，这就是双拼委派模型的实现

双亲委派模型是对系统关键类的保护机制，防止JDK中的类被子类加载器给加载了，它应当就只能被启动类加载器加载

而有些场景下，需要让父类加载器去加载非它管辖范围内的类时，就需要打破双亲委派了，比如 java.sql.DriverManager 是由启动类加载器管辖的，但各厂商对 java.sql.Driver 有不同的实现类，此时启动类加载器就需要委托应用程序类加载器加载实现类了，这就破坏了双亲委派模型。这里具体代码可见 DriverManager 类的 getConnection、isDriverAllowed 方法

### GCRoots的作用以及哪些引用可以作为GCRoots

GCRoots 与可达性分析算法有关，可达性分析算法是用于扫描已创建的对象哪些是没有被直接或间接引用，可以被回收的了，算法中采用了类似图论的方式，将众多引用到对象的有向边联结起来，构建成一张图，那么图的许多起点就是 GCRoots，从 GCRoots 开始能到达的对象说明存在引用关系，而不能到达的对象认为可以被回收

可以作为GCRoots的引用有
- 栈帧的局部变量表中的引用
- 方法区中类变量的引用
- 字符串常量池中的引用
- synchonized持有的对象引用

### 说一下对象内存分配及进入老年代的策略

TODO

### 说下常用垃圾收集器的工作原理

TODO

### 如何选择一款垃圾收集器

多个角度：吞吐量、延迟、内存占用、硬件情况、JDK版本号

根据应用场景
- 如果是数据分析、科学计算类的任务，目标是能尽快算出结果，那吞吐量就是主要关注点
- 如果是SLA应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点
- 如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的

根据经验值之谈
- 在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间
- 如果应用目前采用的垃圾收集器没有出现问题，那就有必要更换，更没有必要去使用G1
- 如果应用追求低延迟停顿，且应用内存足够满足G1要求，G1是一个可以作为尝试的选择，否则使用CMS
- 如果应用追求吞吐量，用G1不会带来什么特别的好处，可以考虑ParallelGC
- JDK9中默认垃圾收集器是G1，而JDK8中默认垃圾收集器是ParallelGC

当然，以上仅都是理论和经验的总结，实战中切不可纸上谈兵，根据系统实际情况去测试才是选择收集器的最终依据

### GC调优策略经验总结

JVM调优经验基本可以等价于GC调优经验，试想，如果GC堆能稳定分配对象并清理垃圾，不会出现OOM、慢执行的情况，那么还有什么是需要调优的呢

因此，但凡谈到JVM调优，都可以往GC堆、GC策略、新生代、老年代方面去谈

下面是经验总结（供参考）
- （1）如果满足这样的指标，则一般不需要进行 GC 优化。即 MinorGC 执行时间不到 50ms，Minor GC 执行不频繁，约 10秒 到 120秒一次（看具体业务）。Full GC 执行时间不到 1秒，Full GC 执行频率不算频繁，约 1小时一次（看具体业务）
- （2）项目上线前，要设置好虚拟机堆区的最大值以及内部区域的比例值，通过监控工具（VisualVM等）测试观察堆区内存变化，是否会频繁发生Full GC，是否可能会内存溢出。同时要设置好虚拟机参数，比如 -XX:+HeapDumpOnOutOfMemoryError，以便能在OOM 时生成堆转储快照
- （3）优化思路，将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过 -Xmn 命令调节新生代大小，最大限度降低新对象直接进入老年代的情况
- （4）大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的，但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 Full GC。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦，写代码应避免之）。-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小
- （5）合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小（最高为15），减少老年代的内存占用，降低 Full GC 发生的频率。同时还要注意虚拟机的一个策略————动态年龄判断
- （6）当出现 OOM 或 GC Overhead Limit Exceeded 时，生成内存堆转储快照或者GC日志，可以使用VisualVM来进行分析，判断内存泄漏还是内存溢出，如果是内存泄漏，则使用工具对GC Roots的引用链进行分析，判断为何垃圾收集器无法回收这些对象；如果是内存溢出，那就应当检查虚拟机的堆参数（-Xmx、-Xms、-Xmn），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗
